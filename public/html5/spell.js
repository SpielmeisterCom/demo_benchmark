/**
 * need.js - A requiresque require.js replacement for usage in browsers.
 */

( function( document ) {
	var modules  = {}

	var arrayContains = function( array, value ) {
		return array.indexOf( value ) !== -1
	}

	var createUrlWithCacheBreaker = function( url ) {
		return url + '?t=' + Date.now()
	}

	var createModuleSource = function( scriptName, source ) {
		return source + '\n//# sourceURL=' + scriptName
	}

	var createRequest = function( url ) {
		var request = new XMLHttpRequest()

		request.open(
			'GET',
			createUrlWithCacheBreaker( url ),
			false
		)

		request.send()

		return request
	}

	var loadModule = function( name, libraryUrl, libraryManager ) {
		var scriptName = name + '.js',
			cachedEntry,
			source

		if( libraryManager ) {
			cachedEntry = libraryManager.get( scriptName )
		}

		if( cachedEntry ) {
			source = cachedEntry

		} else {
			var moduleUrl = libraryUrl ? libraryUrl + '/' + scriptName : scriptName,
				request   = createRequest( moduleUrl )

			if( request.status !== 200 &&
				request.status !== 0 ) {

				throw 'Error: Loading \'' + moduleUrl + '\' failed.'
			}

			source = request.responseText
		}

		try {
			eval( createModuleSource( scriptName, source ) )

		} catch( e ) {

			if( e instanceof SyntaxError ) {
				console.error( 'SyntaxError in ' + scriptName )
				console.error( e.stack )
			}
		}

		return modules[ name ]
	}

	var createModule = function( name, config ) {
		var module = loadModule( name, config.libraryUrl, config.libraryManager )

		if( !module ) throw 'Error: Could not load module \'' + name + '\'.'

		modules[ name ] = module

		return module
	}

	var createModuleInstance = function( dependencies, body, args, config ) {
		var moduleInstanceArgs = []

		if( dependencies ) {
			for( var i = 0; i < dependencies.length; i++ ) {
				var dependencyName   = dependencies[ i ],
					dependencyModule = modules[ dependencyName ]

				if( !dependencyModule && config.hashModuleId ) {
					dependencyModule = modules[ config.hashModuleId( dependencyName ) ]
				}

				if( !dependencyModule ) {
					dependencyModule = createModule( dependencyName, config )
				}

				if( !dependencyModule.instance ) {
					dependencyModule.instance = createModuleInstance( dependencyModule.dependencies, dependencyModule.body, undefined, config )
				}

				moduleInstanceArgs.push( dependencyModule.instance )
			}
		}

		if( args ) moduleInstanceArgs.push( args )

		return body.apply( null, moduleInstanceArgs )
	}

	var createDependentModulesR = function( dependencyName, result ) {
		for( var dependentName in modules ) {
			var dependentModule = modules[ dependentName ]

			if( !dependentModule ) {
				throw 'Error: Module id "' + dependentName + '" could not be resolved.'
			}

			if( arrayContains( dependentModule.dependencies, dependencyName ) &&
				!arrayContains( result, dependentName ) ) {

				result.push( dependentName )

				createDependentModulesR( dependentName, result )
			}
		}

		return result
	}

	var createDependentModules = function( name ) {
		return createDependentModulesR( name, [] )
	}

	var define = function( name ) {
		var numArguments = arguments.length,
			arg1         = arguments[ 1 ]

		if( numArguments < 2 ||
			numArguments > 3 ) {

			throw 'Error: Module definition is invalid.'
		}

		// call this function again through eval
		if( typeof( arg1 ) === 'string' ) {
			eval( createModuleSource( name + '.js', arg1 ) )

			return
		}

		// "redefine" the module
		if( modules[ name ] ) {
			modules[ name ].instance = undefined

			// reset instances of all dependent modules so that consecutive calls to require need to rebuild their dependencies with updated module instances
			var dependentModules = createDependentModules( name )

			for( var i = 0, n = dependentModules.length; i < n; i++ ) {
				modules[ dependentModules[ i ] ].instance = undefined
			}
		}

		// create the module
		modules[ name ] = {
			body         : numArguments === 2 ? arg1 : arguments[ 2 ],
			dependencies : numArguments === 2 ? [] : arg1,
			instance     : undefined
		}
	}

	define.amd = true

	var require = function( name, args, config ) {
		if( !name ) throw 'Error: No module name provided.'

		args    = args || []
		config  = config || {}

		var module = modules[ name ]

		if( !module && config.hashModuleId ) {
			module = modules[ config.hashModuleId( name ) ]
		}

		if( !module ) {
			if( config.loadingAllowed === false ) {
				throw 'Error: Missing module \'' + name + '\'. External loading is disabled. Please make sure that all required modules are shipped.'
			}

			module = createModule( name, config )
		}

		if( !module.instance ) {
			module.instance = createModuleInstance( module.dependencies, module.body, args, config )
		}

		return module.instance
	}

	window.define = define
	window.require = require
	window.createDependentModules = createDependentModules
} )( document )
define(
	'spell/shared/util/platform/initDebugEnvironment',
	[
		'spell/shared/util/platform/private/initDebugEnvironment'
	],
	function(
		initDebugEnvironment
	) {
		'use strict'


		return initDebugEnvironment
	}
)

// Copyright (c) 2012 Turbulenz Limited
define(
	'spell/physics/2D/DebugDraw',
    [
	    'spell/shared/util/platform/Types'
    ],
    function(
        Types
    ) {

        "use strict";

        var Physics2DDebugDraw = function() {
        }

        Physics2DDebugDraw.prototype.setPhysics2DViewport = function (viewport) {
            if (viewport) {
                var port = this._physics2DPort;
                port[0] = viewport[0];
                port[1] = viewport[1];
                port[2] = viewport[2];
                port[3] = viewport[3];
                this._physics2DPortEnabled = true;
            } else {
                this._physics2DPortEnabled = false;
            }
            this._invalidated = true;
        };

        Physics2DDebugDraw.prototype.setScreenViewport = function (viewport) {
            if (viewport) {
                var port = this._screenPort;
                port[0] = viewport[0];
                port[1] = viewport[1];
                port[2] = viewport[2];
                port[3] = viewport[3];
                this._screenPortEnabled = true;
            } else {
                this._screenPortEnabled = false;
            }
            this._invalidated = true;
        };

        Physics2DDebugDraw.prototype.drawLine = function (x1, y1, x2, y2, color) {
            this.renderingContext.setLineColor( color )
            this.renderingContext.drawLine( x1, y1, x2, y2 )
        };

        Physics2DDebugDraw.prototype.drawLinearSpring = function (x1, y1, x2, y2, numCoils, radius, color) {
            if (numCoils <= 0) {
                this.drawLine(x1, y1, x2, y2, color);
                return;
            }

            // Draw linear spring as a sequence of curves approximating
            // a sine wave.
            //
            var dx = (x2 - x1);
            var dy = (y2 - y1);

            var lengthSq = ((dx * dx) + (dy * dy));
            var min = (this.minSpringLength * this.screenToPhysics2D);
            if (lengthSq < (min * min)) {
                // Spring length is below defined epsilon, so we use a line instead.
                this.drawLine(x1, y1, x2, y2, color);
                return;
            }

            // set (nx, ny) to be normal-offset to line between end points of spring
            //   defining twice the amplitude of wave.
            // We use control points which are twice as far from spring line
            //   as the amplitude of wave as the nature of bezier curves means this will
            //   give us a curve that reaches the amplitude perfectly.
            var nx = -dy;
            var ny = dx;
            var nlsq = ((2 * radius) / Math.sqrt((nx * nx) + (ny * ny)));
            nx *= nlsq;
            ny *= nlsq;

            var rec = (1 / (numCoils * 4));
            dx *= rec;
            dy *= rec;

            var i;
            for (i = 0; i < numCoils; i += 1) {
                x2 = (x1 + (dx * 2));
                y2 = (y1 + (dy * 2));
                this.drawCurve(x1, y1, (x1 + dx + nx), (y1 + dy + ny), x2, y2, color);
                x1 = x2;
                y1 = y2;

                x2 = (x1 + (dx * 2));
                y2 = (y1 + (dy * 2));
                this.drawCurve(x1, y1, (x1 + dx - nx), (y1 + dy - ny), x2, y2, color);
                x1 = x2;
                y1 = y2;
            }
        };

        Physics2DDebugDraw.prototype._drawAngleIndicator = function (x, y, ang, rad, size, color) {
            var cos = Math.cos(ang);
            var sin = Math.sin(ang);
            this._drawAnchor(x + (rad * cos), y + (rad * sin), size, color);
        };

        Physics2DDebugDraw.prototype._drawAnchor = function (x, y, rad, color) {
            // 'emulates' a filled circle.
            this.drawCircle(x, y, rad, color);
            this.drawCircle(x, y, rad * 0.75, color);
            this.drawCircle(x, y, rad * 0.5, color);
            this.drawCircle(x, y, rad * 0.25, color);
        };

        Physics2DDebugDraw.prototype.drawSpiral = function (x, y, ang1, ang2, rad1, rad2, color) {
            // Order end points so ang1 < ang2.
            if (ang1 > ang2) {
                var tmp = ang1;
                ang1 = ang2;
                ang2 = tmp;

                tmp = rad1;
                rad1 = rad2;
                rad2 = tmp;
            }

            if (ang1 === ang2) {
                return;
            }

            var deltaRadius = (rad2 - rad1);
            var deltaAngle = (ang2 - ang1);

            // Render spiral in angular segments.
            var segmentCount = Math.ceil(deltaAngle / this.spiralMaxArc);
            var segmentDeltaRadius = (deltaRadius / segmentCount);
            var segmentDeltaAngle = (deltaAngle / segmentCount);

            var cosDelta = Math.cos(segmentDeltaAngle);
            var sinDelta = Math.sin(segmentDeltaAngle);

            // Generate spiral points by rotating (and scaling)
            // radial vector.
            var radialX = Math.cos(ang1);
            var radialY = Math.sin(ang1);
            var radius = rad1;

            var x1 = (x + (rad1 * radialX));
            var y1 = (y + (rad1 * radialY));

            // Gradient at (x1, y1).
            var ux = (deltaRadius * radialX) - (radius * deltaAngle * radialY);
            var uy = (deltaRadius * radialY) + (radius * deltaAngle * radialX);

            var i;
            for (i = 0; i < segmentCount; i += 1) {
                // Compute next point on spiral
                var newRadius = (radius + segmentDeltaRadius);
                var newRadialX = (cosDelta * radialX) - (sinDelta * radialY);
                var newRadialY = (sinDelta * radialX) + (cosDelta * radialY);

                var x2 = (x + (newRadius * newRadialX));
                var y2 = (y + (newRadius * newRadialY));

                // Gradient at (x2, y2)
                var vx = (deltaRadius * newRadialX) - (newRadius * deltaAngle * newRadialY);
                var vy = (deltaRadius * newRadialY) + (newRadius * deltaAngle * newRadialX);

                // Render this spiral segment using a bezier curve (if possible)
                // We find the control point by intersecting the gradients at start and end point.
                var den = ((ux * vy) - (uy * vx));
                if ((den * den) < this.spiralEpsilon) {
                    // Gradients are nearly parallel, use a line!
                    this.drawLine(x1, y1, x2, y2, color);
                } else {
                    // Compute intersection 'time' along gradient (ux, uy).
                    var t = (((x2 - x1) * vy) + ((y1 - y2) * vx)) / den;
                    if (t <= 0) {
                        // Intersection has negative 'time'? Can happen (rare).
                        // Better use a line!
                        this.drawLine(x1, y1, x2, y2, color);
                    } else {
                        this.drawCurve(x1, y1, (x1 + (ux * t)), (y1 + (uy * t)), x2, y2, color);
                    }
                }

                radius = newRadius;
                radialX = newRadialX;
                radialY = newRadialY;
                ux = vx;
                uy = vy;
                x1 = x2;
                y1 = y2;
            }
        };

        // We render a spiral 'spring' in the same way we do a spiral.
        // Only that the expressions for point on spring, and gradient at point
        // are more complex than that of a plain spiral.
        Physics2DDebugDraw.prototype.drawSpiralSpring = function (x, y, ang1, ang2, rad1, rad2, numCoils, color) {
            // Order end points so ang1 < ang2.
            if (ang1 > ang2) {
                var tmp = ang1;
                ang1 = ang2;
                ang2 = tmp;

                tmp = rad1;
                rad1 = rad2;
                rad2 = tmp;
            }

            if (ang1 === ang2) {
                return;
            }

            var deltaRadius = (rad2 - rad1);
            var deltaAngle = (ang2 - ang1);

            // Render spiral in angular segments.
            var segmentCount = Math.max(Math.ceil(deltaAngle / (this.spiralMaxArc * 3)), (40 * numCoils));
            var segmentDeltaAngle = (deltaAngle / segmentCount);
            var segmentDeltaTime = (1 / segmentCount);

            var cosDelta = Math.cos(segmentDeltaAngle);
            var sinDelta = Math.sin(segmentDeltaAngle);

            var spiralSpringSize = this.spiralSpringSize;

            // Coeffecients in expression for point on spiral spring.
            // and gradient of spiral spring at point.
            var Delta = Math.abs(2 * Math.PI * deltaRadius / deltaAngle);
            var spiralA = (spiralSpringSize * Delta);
            var spiralB = (2 * numCoils * Math.PI);
            var spiralAt = (spiralA * spiralB);

            // Generate spiral points by rotating (and scaling)
            // radial vector.
            var radialX = Math.cos(ang1);
            var radialY = Math.sin(ang1);
            var radius = rad1;

            var x1 = (x + (radius * radialX));
            var y1 = (y + (radius * radialY));

            // Gradient at (x1, y1).
            var gradient = (deltaRadius + spiralAt);
            var ux = (gradient * radialX) - (radius * deltaAngle * radialY);
            var uy = (gradient * radialY) + (radius * deltaAngle * radialX);

            var i;
            for (i = 0; i < segmentCount; i += 1) {
                // Compute next point on spiral.
                var t = ((i + 1) * segmentDeltaTime);
                var newRadialX = (cosDelta * radialX) - (sinDelta * radialY);
                var newRadialY = (sinDelta * radialX) + (cosDelta * radialY);

                radius = ((rad1 + (deltaRadius * t)) + (spiralA * Math.sin(spiralB * t)));
                var x2 = (x + (radius * newRadialX));
                var y2 = (y + (radius * newRadialY));

                // Gradient at (x2, y2)
                gradient = (deltaRadius + (spiralAt * Math.cos(spiralB * t)));
                var vx = (gradient * newRadialX) - (radius * deltaAngle * newRadialY);
                var vy = (gradient * newRadialY) + (radius * deltaAngle * newRadialX);

                // Render spiral segment using a bezier curve (if possible).
                // We find the control point by intersecting the gradients at start and end point.
                var den = ((ux * vy) - (uy * vx));

                // Additional constraint that gradient directions in same general direction
                // but not completely equal.
                var dot = ((ux * vx) + (uy * vy));
                if ((den * den) < this.spiralEpsilon || dot < 0 || dot > (1 - this.spiralEpsilon)) {
                    // better use a line!
                    this.drawLine(x1, y1, x2, y2, color);
                } else {
                    // Compute intersection 'time' along gradient (ux, uy).
                    t = (((x2 - x1) * vy) + ((y1 - y2) * vx)) / den;
                    if (t <= 0) {
                        // better use a line!
                        this.drawLine(x1, y1, x2, y2, color);
                    } else {
                        this.drawCurve(x1, y1, (x1 + (ux * t)), (y1 + (uy * t)), x2, y2, color);
                    }
                }

                radialX = newRadialX;
                radialY = newRadialY;
                ux = vx;
                uy = vy;
                x1 = x2;
                y1 = y2;
            }
        };

        Physics2DDebugDraw.prototype.drawCurve = function (x1, y1, cx, cy, x2, y2, color) {
            var r = color[0];
            var g = color[1];
            var b = color[2];
            var a = color[3];

            var stack = this._curveStack;
            var verts = this._curveVerts;
            stack.push(x1, y1, cx, cy, x2, y2);
            while (stack.length > 0) {
                y2 = stack.pop();
                x2 = stack.pop();
                cy = stack.pop();
                cx = stack.pop();
                y1 = stack.pop();
                x1 = stack.pop();

                // (qx, qy) = mid-point of quadratic bezier segment.
                var qx = 0.25 * (x1 + (2 * cx) + x2);
                var qy = 0.25 * (y1 + (2 * cy) + y2);

                // (lx, ly) = mid-point of line from (x1, y1) -> (x2, y2)
                var lx = 0.5 * (x1 + x2);
                var ly = 0.5 * (y1 + y2);

                // If distance between q, l is minimal (by configured epsilon)
                // Then we approximate segment with a straight line.
                var dx = (qx - lx);
                var dy = (qy - ly);
                var err = (this.curveMaxError * this.screenToPhysics2D);
                if (((dx * dx) + (dy * dy)) < (err * err)) {
                    verts.push(x1, y1);
                } else {
                    // Otherwise we decompose segment in two halves
                    // And 'recurse'
                    var m1x = 0.5 * (x1 + cx);
                    var m1y = 0.5 * (y1 + cy);
                    var m2x = 0.5 * (x2 + cx);
                    var m2y = 0.5 * (y2 + cy);
                    var mmx = 0.5 * (m1x + m2x);
                    var mmy = 0.5 * (m1y + m2y);
                    stack.push(mmx, mmy, m2x, m2y, x2, y2);
                    stack.push(x1, y1, m1x, m1y, mmx, mmy);
                }
            }
            verts.push(x2, y2);

            /*jshint bitwise: false*/
            var vCount = (verts.length >> 1);

            /*jshint bitwise: true*/
            var numVertices = this._numVertices;
            var vindex = (numVertices * 6);
            var iindex = (this._numLines * 2);
            this._prepare(vCount, (vCount - 1)); // N vertices, (N - 1) lines

            var vdata = this._vertexData;
            var idata = this._indexData;

            var i, j = 0;
            for (i = 0; i < vCount; i += 1) {
                vdata[vindex] = verts[j];
                vdata[vindex + 1] = verts[j + 1];
                vdata[vindex + 2] = r;
                vdata[vindex + 3] = g;
                vdata[vindex + 4] = b;
                vdata[vindex + 5] = a;
                j += 2;
                vindex += 6;

                if (i > 0) {
                    idata[iindex] = (numVertices + i - 1);
                    idata[iindex + 1] = (numVertices + i);
                    iindex += 2;
                }
            }

            verts.length = 0;
        };

        Physics2DDebugDraw.prototype.drawRectangle = function (x1, y1, x2, y2, color) {
            this.renderingContext.setLineColor( color )
            var dx = x1,
                dy = y2,
                dw = x2 - x1,
                dh = y1 - y2

            this.renderingContext.drawRect( dx, dy, dw, dh )
        };

        Physics2DDebugDraw.prototype.drawCircle = function (x, y, radius, color) {
            this.renderingContext.setLineColor( color )
            this.renderingContext.drawCircle( x, y, radius )
        };

        Physics2DDebugDraw.prototype.drawRigidBody = function (body) {
            body._update();
            var shapes = body.shapes;
            var limit = shapes.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                this._drawShape(shapes[i]);
            }

            if (this.showBodyDetail) {
                var data = body._data;
                this.drawCircle(data[(/*BODY_POS*/ 2)], data[(/*BODY_POS*/ 2) + 1], this.screenToPhysics2D * this.bodyPositionRadius, this.bodyDetailColor);
                this.drawLine(data[(/*BODY_PRE_POS*/ 15)], data[(/*BODY_PRE_POS*/ 15) + 1], data[(/*BODY_POS*/ 2)], data[(/*BODY_POS*/ 2) + 1], this.bodyDetailColor);
            }
        };

        Physics2DDebugDraw.prototype.drawConstraint = function (con) {
            if (con._draw) {
                con._draw(this, con._stiff);
            }
        };

        Physics2DDebugDraw.prototype.drawWorld = function (world, rectangle) {
            var i, limit;
            if (this.showRigidBodies) {
                var bodies = [];
                limit = world.bodyRectangleQuery(rectangle, bodies);
                for (i = 0; i < limit; i += 1) {
                    var body = bodies[i];
                    this.drawRigidBody(body);
                }
            }

            if (this.showContacts) {
                this._drawArbiters(world.dynamicArbiters);
                this._drawArbiters(world.staticArbiters);
            }

            if (this.showConstraints) {
                var constraints = world.constraints;
                limit = constraints.length;
                for (i = 0; i < limit; i += 1) {
                    var con = constraints[i];
                    if (con._active) {
                        this.drawConstraint(con);
                    }
                }
            }
        };

        Physics2DDebugDraw.prototype._drawArbiters = function (arbiters) {
            var rad = (this.screenToPhysics2D * this.contactRadius);
            var imp = (this.screenToPhysics2D * this.contactImpulseScale);

            var limit = arbiters.length;
            var i;
            for (i = 0; i < limit; i += 1) {
                var arb = arbiters[i];
                if (!arb.active) {
                    continue;
                }

                var color = (arb._static ? this.staticContactColor : this.dynamicContactColor);

                var nx, ny;
                if (arb.sensor) {
                    nx = 0;
                    ny = 0;
                } else {
                    var adata = arb._data;
                    nx = adata[(/*ARB_NORMAL*/ 4)];
                    ny = adata[(/*ARB_NORMAL*/ 4) + 1];
                }

                var c1 = arb._contact1._data;
                var x1 = c1[(/*CON_POS*/ 0)];
                var y1 = c1[(/*CON_POS*/ 0) + 1];
                this.drawCircle(x1, y1, rad, color);

                var jn, jt;
                if (this.showContactImpulses && !arb._contact1.virtual) {
                    jn = (c1[(/*CON_JNACC*/ 11)]) * imp;
                    jt = (c1[(/*CON_JTACC*/ 12)]) * imp;
                    this.drawLine(x1, y1, x1 + (nx * jn), y1 + (ny * jn), this.normalImpulseColor);
                    this.drawLine(x1, y1, x1 - (ny * jt), y1 + (nx * jt), this.frictionImpulseColor);
                }

                if (arb._position2Contact) {
                    var c2 = arb._contact2._data;
                    var x2 = c2[(/*CON_POS*/ 0)];
                    var y2 = c2[(/*CON_POS*/ 0) + 1];
                    if (this.showContactImpulses && !arb._contact2.virtual) {
                        jn = (c2[(/*CON_JNACC*/ 11)]) * imp;
                        jt = (c2[(/*CON_JTACC*/ 12)]) * imp;
                        this.drawLine(x2, y2, x2 + (nx * jn), y2 + (ny * jn), this.normalImpulseColor);
                        this.drawLine(x2, y2, x2 - (ny * jt), y2 + (nx * jt), this.frictionImpulseColor);
                    }

                    nx *= rad;
                    ny *= rad;
                    this.drawCircle(x2, y2, rad, color);
                    this.drawLine(x1 + nx, y1 + ny, x2 + nx, y2 + ny, color);
                    this.drawLine(x1 - nx, y1 - ny, x2 - nx, y2 - ny, color);
                }
            }
        };

        // Assumption that shape was updated by a body before call.
        Physics2DDebugDraw.prototype._drawShape = function (shape) {
            var body = shape.body;
            if ((shape.sensor && !this.showSensorsShapes) || (!shape.sensor && !this.showColliderShapes)) {
                return;
            }

            /*jshint bitwise: false*/
            var color = this._colors[shape.body._type | (body.sleeping ? 4 : 0) | (shape.sensor ? 8 : 0) | (body._bullet ? 16 : 0)];

            /*jshint bitwise: true*/
            if (shape._type === (/*TYPE_CIRCLE*/ 0)) {
                this._drawCircleShape(shape, color);
            } else {
                this._drawPolygonShape(shape, color);
            }

            if (this.showShapeDetail) {
                var data = shape._data;
                this.drawRectangle(data[(/*SHAPE_AABB*/ 0)], data[(/*SHAPE_AABB*/ 0) + 1], data[(/*SHAPE_AABB*/ 0) + 2], data[(/*SHAPE_AABB*/ 0) + 3], this.shapeDetailColor);
            }
        };

        Physics2DDebugDraw.prototype._drawCircleShape = function (circle, color) {
            var body = circle.body._data;
            var data = circle._data;
            var cx = data[(/*CIRCLE_WORLD*/ 9)];
            var cy = data[(/*CIRCLE_WORLD*/ 9) + 1];
            var rad = data[(/*CIRCLE_RADIUS*/ 6)];
            this.drawCircle(cx, cy, rad, color);

            if (circle.body._type !== (/*TYPE_STATIC*/ 2)) {
                var cos = body[(/*BODY_AXIS*/ 5)];
                var sin = body[(/*BODY_AXIS*/ 5) + 1];
                this.drawLine(cx + (rad * 0.333 * cos), cy + (rad * 0.333 * sin), cx + (rad * cos), cy + (rad * sin), color);
            }

            if (this.showShapeDetail) {
                this.drawCircle(data[(/*CIRCLE_WORLD*/ 9)], data[(/*CIRCLE_WORLD*/ 9) + 1], this.screenToPhysics2D * this.circleOriginRadius, this.shapeDetailColor);
            }
        };

        Physics2DDebugDraw.prototype._drawPolygonShape = function (polygon, color) {
			var numVertices = this._numVertices;
			var vindex = (numVertices * 6);

			var pdata = polygon._data;
			var pindex = (/*POLY_VERTICES*/ 6);
			var limit = pdata.length;

			var i;

			var vertices = []

			for (i = 0; pindex < limit; pindex += (/*POLY_STRIDE*/ 13), i += 1) {
				vertices.push({
					x: pdata[pindex + (/*POLY_WORLD*/ 2)],
					y: pdata[pindex + (/*POLY_WORLD*/ 2) + 1]
				})

				vindex += 6;
			}


			var firstPoint = vertices[0],
				lastPoint  = undefined

			limit = vertices.length

			for ( i = 0; i < limit; i++ ) {
				var nextPoint = vertices[ i ]

				if( lastPoint ) this.drawLine( lastPoint.x, lastPoint.y, nextPoint.x, nextPoint.y, color )

				lastPoint = nextPoint
			}

			this.drawLine( firstPoint.x, firstPoint.y, lastPoint.x, lastPoint.y, color )
        };

        // =========================================================================
        Physics2DDebugDraw.prototype.begin = function () {
            var gd = this._graphicsDevice;
            var width = gd.width;
            var height = gd.height;

            var screenX, screenY, screenW, screenH;
            var port;
            if (this._screenPortEnabled) {
                port = this._screenPort;
                screenX = port[0];
                screenY = port[1];
                screenW = port[2] - screenX;
                screenH = port[3] - screenY;
            } else {
                screenX = 0;
                screenY = 0;
                screenW = width;
                screenH = height;
            }

            if (width !== this._width || height !== this._height || this._invalidated) {
                this._width = width;
                this._height = height;
                this._invalidated = false;

                var physX, physY, physW, physH;
                if (this._physics2DPortEnabled) {
                    port = this._physics2DPort;
                    physX = port[0];
                    physY = port[1];
                    physW = port[2] - physX;
                    physH = port[3] - physY;
                } else {
                    physX = 0;
                    physY = 0;
                    physW = width / 60;
                    physH = height / 60;
                }

                var clip = this._techniqueParams['clipSpace'];
                clip[0] = (2 * screenW) / (width * physW);
                clip[1] = -(2 * screenH) / (height * physH);
                clip[2] = -(2 * physX * screenW) / (width * physW) + (2 * screenX / width) - 1;
                clip[3] = (2 * physY * screenH) / (height * physH) - (2 * screenY / height) + 1;

                var rx = (clip[0] * 0.5 * width);
                var ry = -(clip[1] * 0.5 * height);
                this.physics2DToScreen = 0.5 * (rx + ry);
                this.screenToPhysics2D = 1 / this.physics2DToScreen;
            }

            gd.setScissor(screenX, height - screenY - screenH, screenW, screenH);
            gd.setTechnique(this._technique);
            gd.setTechniqueParameters(this._techniqueParams);
        };

        Physics2DDebugDraw.prototype.end = function () {
            this._dispatch();
        };

        // =========================================================================
        Physics2DDebugDraw.prototype._prepare = function (numVerts, numLines) {
            var size, newData, i;

            var index = (this._numVertices * 6);
            var total = index + (numVerts * 6);
            var data = this._vertexData;
            if (total > data.length) {
                // allocate new vertex buffer data array.
                size = this._bufferSizeAlgorithm(total);
                newData = this._vertexData = Types.createFloatArray(size);

                for (i = 0; i < index; i += 1) {
                    newData[i] = data[i];
                }
            }
            this._numVertices += numVerts;

            index = (this._numLines * 2);
            total = index + (numLines * 2);
            data = this._indexData;
            if (total > data.length) {
                // allocate new index buffer data array
                size = this._bufferSizeAlgorithm(total);
                newData = this._indexData = Types.Uint16Array.create(size);

                for (i = 0; i < index; i += 1) {
                    newData[i] = data[i];
                }
            }
            this._numLines += numLines;
        };

        Physics2DDebugDraw.prototype._bufferSizeAlgorithm = function (target) {
            // scale factor of 2 is asymtopically optimal in terms of number of resizes
            // performed and copies performed, but we want to try and conserve memory
            // and so choose a less optimal 1.25 so that buffer will never be too much
            // larger than necessary.
            var factor = 1.25;

            // We size buffer to the next power of the factor which is >= target
            var logf = Math.ceil(Math.log(target) / Math.log(factor));
            var size = Math.floor(Math.pow(factor, logf));

            // Additionally ensure that we always take a multiple of of the stride
            // to avoid wasted bytes that could never be used.
            return (6 * Math.ceil(size / 6));
        };

        Physics2DDebugDraw.prototype._dispatch = function () {
            var graphicsDevice = this._graphicsDevice;
            var vertexBuffer = this._vertexBuffer;
            var vertexBufferParameters = this._vertexBufferParameters;
            var vertexData = this._vertexData;
            var indexBuffer = this._indexBuffer;
            var indexBufferParameters = this._indexBufferParameters;
            var indexData = this._indexData;

            var count = this._numVertices;
            if (count === 0) {
                return;
            }

            var newSize;

            // Resize buffer.
            if (count > vertexBufferParameters.numVertices) {
                newSize = this._bufferSizeAlgorithm(count);
                vertexBufferParameters.numVertices = newSize;
                this._vertexBuffer.destroy();
                this._vertexBuffer = vertexBuffer = graphicsDevice.createVertexBuffer(vertexBufferParameters);
            }

            vertexBuffer.setData(vertexData, 0, count);

            count = (this._numLines * 2);

            // Resize buffer.
            if (count > indexBufferParameters.numIndices) {
                newSize = this._bufferSizeAlgorithm(count);
                indexBufferParameters.numIndices = newSize;
                this._indexBuffer.destroy();
                this._indexBuffer = indexBuffer = graphicsDevice.createIndexBuffer(indexBufferParameters);
            }

            indexBuffer.setData(indexData, 0, count);
            graphicsDevice.setStream(vertexBuffer, this._semantics);
            graphicsDevice.setIndexBuffer(indexBuffer);
            graphicsDevice.drawIndexed(graphicsDevice.PRIMITIVE_LINES, count);

            this._numVertices = 0;
            this._numLines = 0;
        };

        Physics2DDebugDraw.prototype.destroy = function () {
            this._graphicsDevice = null;
            this._curveStack.length = 0;
            this._curveVerts.length = 0;
            this._colors.length = 0;

            this._vertexBuffer.destroy();
            this._indexBuffer.destroy();
        };

        Physics2DDebugDraw.create = function (params) {
            var o = new Physics2DDebugDraw();
            var gd = o._graphicsDevice = params.graphicsDevice;

            o._screenPort = Types.createFloatArray(4);
            o._screenPortEnabled = false;
            o._physics2DPort = Types.createFloatArray(4);
            o._physics2DPortEnabled = false;
            o._invalidated = true;

            o.physics2DToScreen = 0;
            o.screenToPhysics2D = 0;

            o.circleMaxError = 0.4; //px
            o.curveMaxError = 0.6; //px
            o.spiralMaxArc = Math.PI / 4; // rad
            o.spiralEpsilon = 1e-5;
            o.spiralSpringSize = 0.75; // percentage of gap between spiral arms for spring.
            o._curveStack = [];
            o._curveVerts = [];

            o.minSpringLength = 0.5; // px

            var v4Build = function v4BuildFn(r, g, b, a) {
                var ret = Types.createFloatArray(4);
                ret[0] = r;
                ret[1] = g;
                ret[2] = b;
                ret[3] = a;
                return ret;
            };

            var bulletColor = v4Build(1.0, 1.0, 1.0, 1.0);
            var staticColor = v4Build(1.0, 0.5, 0.5, 1.0);
            var staticSensorColor = v4Build(0.9, 0.7, 0.7, 0.6);
            var kinematicColor = v4Build(0.8, 0.3, 0.8, 1.0);
            var kinematicSensorColor = v4Build(0.8, 0.4, 0.8, 0.6);
            var dynamicColor = v4Build(0.5, 1.0, 0.5, 1.0);
            var dynamicSensorColor = v4Build(0.7, 0.9, 0.7, 0.6);
            var sleepingDynamicColor = v4Build(0.5, 1.0, 0.5, 0.5);
            var sleepingDynamicSensorColor = v4Build(0.7, 0.9, 0.7, 0.4);
            var sleepingKinematicColor = v4Build(0.8, 0.4, 0.8, 0.5);
            var sleepingKinematicSensorColor = v4Build(0.8, 0.5, 0.8, 0.4);

            o.showConstraints = true;
            o.constraintAnchorRadius = 3.0;
            o.constraintSpringRadius = 3.0;
            o.constraintSpringNumCoils = 3;
            o.constraintSpiralMinRadius = 10.0;
            o.constraintSpiralDeltaRadius = (2.5 / Math.PI);
            o.constraintSpiralNumCoils = 4;
            o.constraintColorA = v4Build(1.0, 0.0, 0.0, 0.8);
            o.constraintSleepingColorA = v4Build(0.7, 0.2, 0.2, 0.6);
            o.constraintColorB = v4Build(0.0, 0.0, 1.0, 0.8);
            o.constraintSleepingColorB = v4Build(0.2, 0.2, 0.7, 0.6);
            o.constraintColorC = v4Build(0.0, 1.0, 0.0, 0.8);
            o.constraintSleepingColorC = v4Build(0.2, 0.7, 0.2, 0.6);
            o.constraintColorD = v4Build(1.0, 0.0, 1.0, 0.8);
            o.constraintSleepingColorD = v4Build(0.7, 0.2, 0.7, 0.6);
            o.constraintErrorColorA = v4Build(1.0, 1.0, 0.5, 0.8);
            o.constraintErrorSleepingColorA = v4Build(0.7, 0.7, 0.5, 0.6);
            o.constraintErrorColorB = v4Build(0.5, 1.0, 1.0, 0.8);
            o.constraintErrorSleepingColorB = v4Build(0.5, 0.7, 0.7, 0.6);
            o.constraintErrorColorC = v4Build(0.4, 1.0, 0.4, 0.8);
            o.constraintErrorSleepingColorC = v4Build(0.4, 0.7, 0.4, 0.6);
            o.constraintErrorColorD = v4Build(1.0, 0.4, 1.0, 0.8);
            o.constraintErrorSleepingColorD = v4Build(0.7, 0.4, 0.7, 0.6);

            o.showContacts = false;
            o.showContactImpulses = false;
            o.contactRadius = 3.0;
            o.contactImpulseScale = 30.0;
            o.dynamicContactColor = v4Build(1.0, 0.0, 0.5, 0.7);
            o.staticContactColor = v4Build(0.5, 0.0, 1.0, 0.7);
            o.normalImpulseColor = v4Build(1.0, 0.0, 0.0, 1.0);
            o.frictionImpulseColor = v4Build(0.0, 0.0, 1.0, 1.0);

            o.showRigidBodies = true;
            o.showColliderShapes = true;
            o.showSensorsShapes = true;
            o.showBodyDetail = false;
            o.showShapeDetail = false;
            o.bodyPositionRadius = 0.5;
            o.circleOriginRadius = 0.5;
            o.bodyDetailColor = v4Build(0.0, 1.0, 1.0, 0.5);
            o.shapeDetailColor = v4Build(1.0, 1.0, 0.0, 0.5);

            // (type | (sleeping << 2) | (sensor << 3) | (bullet << 4))
            var colors = o._colors = [];
            colors[(/*TYPE_STATIC*/ 2) + 4] = staticColor;
            colors[(/*TYPE_STATIC*/ 2) + 12] = staticSensorColor;
            colors[(/*TYPE_DYNAMIC*/ 0)] = dynamicColor;
            colors[(/*TYPE_DYNAMIC*/ 0) + 8] = dynamicSensorColor;
            colors[(/*TYPE_DYNAMIC*/ 0) + 4] = sleepingDynamicColor;
            colors[(/*TYPE_DYNAMIC*/ 0) + 12] = sleepingDynamicSensorColor;
            colors[(/*TYPE_DYNAMIC*/ 0) + 16] = bulletColor;
            colors[(/*TYPE_KINEMATIC*/ 1)] = kinematicColor;
            colors[(/*TYPE_KINEMATIC*/ 1) + 8] = kinematicSensorColor;
            colors[(/*TYPE_KINEMATIC*/ 1) + 4] = sleepingKinematicColor;
            colors[(/*TYPE_KINEMATIC*/ 1) + 12] = sleepingKinematicSensorColor;

            // Load embedded default shader and techniques
            var shader = gd.createShader({
                "version": 1,
                "name": "lines.cgfx",
                "parameters": {
                    "clipSpace": {
                        "type": "float",
                        "columns": 4
                    }
                },
                "techniques": {
                    "alpha": [
                        {
                            "parameters": ["clipSpace"],
                            "semantics": ["POSITION", "COLOR"],
                            "states": {
                                "DepthTestEnable": false,
                                "DepthMask": false,
                                "CullFaceEnable": false,
                                "BlendEnable": true,
                                "BlendFunc": [770, 771]
                            },
                            "programs": ["vp_draw2dlines", "fp_draw2dlines"]
                        }
                    ]
                },
                "programs": {
                    "fp_draw2dlines": {
                        "type": "fragment",
                        "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;\nvoid main()\n{gl_FragColor=tz_Color;}"
                    },
                    "vp_draw2dlines": {
                        "type": "vertex",
                        "code": "#ifdef GL_ES\n#define TZ_LOWP lowp\nprecision mediump float;\nprecision mediump int;\n#else\n#define TZ_LOWP\n#endif\nvarying TZ_LOWP vec4 tz_Color;attribute vec4 ATTR3;attribute vec4 ATTR0;\nvec4 _outpos1;vec4 _outcol1;uniform vec4 clipSpace;void main()\n{vec2 _TMP1;_TMP1=ATTR0.xy*clipSpace.xy+clipSpace.zw;_outpos1=vec4(_TMP1.x,_TMP1.y,0.0,1.0);_outcol1=ATTR3;tz_Color=ATTR3;gl_Position=_outpos1;}"
                    }
                }
            });

            o._techniqueParams = gd.createTechniqueParameters({
                clipSpace: Types.createFloatArray(4)
            });
            o._technique = shader.getTechnique("alpha");

            var initialVertices = 4;
            var initialIndices = 4;

            o._vertexBufferParameters = {
                numVertices: initialVertices,
                attributes: [gd.VERTEXFORMAT_FLOAT2, gd.VERTEXFORMAT_FLOAT4],
                'transient': true
            };
            o._vertexBuffer = gd.createVertexBuffer(o._vertexBufferParameters);

            o._semantics = gd.createSemantics([gd.SEMANTIC_POSITION, gd.SEMANTIC_COLOR]);

            o._indexBufferParameters = {
                numIndices: initialIndices,
                format: gd.INDEXFORMAT_USHORT,
                'transient': true
            };
            o._indexBuffer = gd.createIndexBuffer(o._indexBufferParameters);

            o._vertexData = Types.createFloatArray(60);
            o._indexData = Types.Uint16Array.create(60);
            o._numVertices = 0;
            o._numLines = 0;

            return o;
        };
        Physics2DDebugDraw.version = 1;
        return Physics2DDebugDraw;
    });

// =====================================================================
//
// Physics2D 1D (x) Sweep and Prune Broadphase
//
define(
	'spell/physics/2D/SweepAndPruneHandle',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		var Physics2DSweepAndPruneHandle = function() {
			this._next = null;
			this._prev = null;
			this._aabb = Types.createFloatArray(4);

			this.data = null;
			this.isStatic = false;
		}
		Physics2DSweepAndPruneHandle.allocate = function () {
			if (!this.pool) {
				return new Physics2DSweepAndPruneHandle();
			} else {
				var ret = this.pool;
				this.pool = ret._next;
				ret._next = null;
				return ret;
			}
		};

		Physics2DSweepAndPruneHandle.deallocate = function (handle) {
			handle._prev = null;
			handle._next = this.pool;
			this.pool = handle;

			handle.data = null;
		};
		Physics2DSweepAndPruneHandle.pool = null;

		return Physics2DSweepAndPruneHandle;
})
// =====================================================================
//
// Physics2D 1D (x) Sweep and Prune Broadphase
//
define(
	'spell/physics/2D/SweepAndPrune',
	[
		'spell/physics/2D/SweepAndPruneHandle'
	],
	function(
		Physics2DSweepAndPruneHandle
	) {

		var Physics2DSweepAndPrune = function() {
		}
		Physics2DSweepAndPrune.prototype.sample = function (rectangle, lambda, thisObject) {
			var minX = rectangle[0];
			var minY = rectangle[1];
			var maxX = rectangle[2];
			var maxY = rectangle[3];

			this._validate();

			var d1 = this._list;
			while (d1) {
				var aabb = d1._aabb;

				// Slip element preceeding rectangle.
				if (aabb[2] < minX) {
					d1 = d1._next;
					continue;
				}

				// Discard all list proceeding rectangle.
				if (aabb[0] > maxX) {
					break;
				}

				// Full AABB check (only y-check needed)
				if (aabb[1] <= maxY && minY <= aabb[3]) {
					lambda.call(thisObject, d1, rectangle);
				}
				d1 = d1._next;
			}
		};

		Physics2DSweepAndPrune.prototype.insert = function (data, aabb, isStatic) {
			var handle = Physics2DSweepAndPruneHandle.allocate();
			var ab = handle._aabb;
			ab[0] = aabb[0];
			ab[1] = aabb[1];
			ab[2] = aabb[2];
			ab[3] = aabb[3];

			handle.data = data;
			handle.isStatic = isStatic;

			// Insert at beginning, let broadphase update deal with it.
			var list = this._list;
			handle._next = list;
			if (list) {
				list._prev = handle;
			}
			this._list = handle;

			return handle;
		};

		Physics2DSweepAndPrune.prototype.update = function (handle, aabb, isStatic) {
			var ab = handle._aabb;
			ab[0] = aabb[0];
			ab[1] = aabb[1];
			ab[2] = aabb[2];
			ab[3] = aabb[3];

			// Not used in this broadphase, but must provide consistency
			if (isStatic !== undefined) {
				handle.isStatic = isStatic;
			}
		};

		Physics2DSweepAndPrune.prototype.remove = function (handle) {
			if (!handle._prev) {
				this._list = handle._next;
			} else {
				handle._prev._next = handle._next;
			}

			if (handle._next) {
				handle._next._prev = handle._prev;
			}

			Physics2DSweepAndPruneHandle.deallocate(handle);
		};

		Physics2DSweepAndPrune.prototype.clear = function (callback, thisObject) {
			var handle = this._list;
			while (handle) {
				var next = handle._next;
				if (callback) {
					callback.call(thisObject, handle);
				}
				Physics2DSweepAndPruneHandle.deallocate(handle);
				handle = next;
			}
			this._list = null;
		};

		Physics2DSweepAndPrune.prototype._validate = function () {
			if (!this._list) {
				return;
			}

			var a = this._list._next;
			while (a) {
				var next = a._next;
				var b = a._prev;

				var aMinX = a._aabb[0];
				if (aMinX > b._aabb[0]) {
					// Nothing to do.
					a = next;
					continue;
				}

				while (b._prev && b._prev._aabb[0] > aMinX) {
					b = b._prev;
				}

				// Remove a
				var prev = a._prev;
				prev._next = next;
				if (next) {
					next._prev = prev;
				}

				// Insert a before b
				if (!b._prev) {
					a._prev = null;
					this._list = a;
					a._next = b;
					b._prev = a;
				} else {
					a._prev = b._prev;
					b._prev = a;
					a._prev._next = a;
					a._next = b;
				}

				a = next;
			}
		};

		Physics2DSweepAndPrune.prototype.perform = function (lambda, thisObject) {
			this._validate();

			var d1 = this._list;
			while (d1) {
				var d2 = d1._next;
				var aabb1 = d1._aabb;
				var d1Static = d1.isStatic;

				var maxX = aabb1[2];
				while (d2) {
					var aabb2 = d2._aabb;
					if (aabb2[0] > maxX) {
						break;
					}

					if (d1Static && d2.isStatic) {
						d2 = d2._next;
						continue;
					}

					// Check AABB's fully. (test y-axis, x-axis already checked)
					if (aabb1[1] > aabb2[3] || aabb2[1] > aabb1[3]) {
						d2 = d2._next;
						continue;
					}

					lambda.call(thisObject, d1, d2);
					d2 = d2._next;
				}

				d1 = d1._next;
			}
		};

		Physics2DSweepAndPrune.create = function () {
			var b = new Physics2DSweepAndPrune();
			b._list = null;
			return b;
		};
		Physics2DSweepAndPrune.version = 1;

		return Physics2DSweepAndPrune;
})

// =========================================================================
//
// Custom Constraint
//
// CUSTOM DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CUSTOM_JMAX*/5
///*CUSTOM_GAMMA*/6
define(
	'spell/physics/2D/CustomConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DCustomConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
			this.type = "CUSTOM";
		}
		__extends(Physics2DCustomConstraint, Physics2DConstraint);

		// ===============================================
		Physics2DCustomConstraint.prototype._inWorld = function () {
			var bodies = this.bodies;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				bodies[i].constraints.push(this);
			}
		};

		Physics2DCustomConstraint.prototype._outWorld = function () {
			var bodies = this.bodies;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var constraints = bodies[i].constraints;
				var index = constraints.indexOf(this);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();
			}
		};

		Physics2DCustomConstraint.prototype._pairExists = function (b1, b2) {
			var bodies = this.bodies;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var bodyA = bodies[i];
				if (bodyA === b1 || bodyA === b2) {
					var j;
					for (j = (i + 1); j < limit; j += 1) {
						var bodyB = bodies[j];
						if ((bodyA === b1 && bodyB === b2) || (bodyA === b2 && bodyB === b1)) {
							return true;
						}
					}
				}
			}

			return false;
		};

		Physics2DCustomConstraint.prototype._wakeConnected = function () {
			var bodies = this.bodies;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					body.wake(true);
				}
			}
		};

		Physics2DCustomConstraint.prototype._sleepComputation = function (union) {
			var bodies = this.bodies;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					union(body, this);
				}
			}
		};

		// =====================================================
		Physics2DCustomConstraint.prototype._clearCache = function () {
			var data = this._data;

			var J_ACC = this._J_ACC;
			var limit = (J_ACC + this.dimension);
			var i;
			for (i = J_ACC; i < limit; i += 1) {
				data[i] = 0;
			}

			data[(/*JOINT_PRE_DT*/ 4)] = -1;
		};

		// Compute cholesky decomposition of A into
		// lower triangular matrix L. A stored
		// as symmetric matrix. and L a full matrix
		// for ease of computation.
		Physics2DCustomConstraint.prototype._cholesky = function () {
			var data = this._data;
			var A = this._K_MASS;
			var L = this._K_CHOLESKY;
			var dim = this.dimension;

			var j;
			for (j = 0; j < dim; j += 1) {
				var sum = 0;
				var k;
				for (k = 0; k <= (j - 1); k += 1) {
					var Lval = data[L + (j * dim) + k];
					sum += (Lval * Lval);
				}

				var rec = data[A] - sum;
				var zeroRank = (rec <= 0);
				if (zeroRank) {
					rec = data[A];
				}
				rec = (rec <= 0 ? 0 : Math.sqrt(rec));
				A += 1;
				data[L + (j * dim) + j] = rec;

				var i;
				if (rec !== 0 && !zeroRank) {
					rec = (1 / rec);
					for (i = (j + 1); i < dim; i += 1) {
						sum = 0;
						for (k = 0; k <= (j - 1); k += 1) {
							sum += (data[L + (i * dim) + k] * data[L + (j * dim) + k]);
						}
						data[L + (i * dim) + j] = rec * (data[A] - sum);
						A += 1;
					}
				}

				if (zeroRank) {
					for (i = (j + 1); i < dim; i += 1) {
						data[L + (i * dim) + j] = 0;
					}
					for (i = 0; i < j; i += 1) {
						data[L + (j * dim) + i] = 0;
					}
					A += (dim - j - 1);
				}
			}
		};

		// Perform multiplication with inverse of eff-mass matrix.
		// X = (LL^T)^-1 * X for L = CHOLESKY
		Physics2DCustomConstraint.prototype._transform = function (X /*floatArray*/ ) {
			var data = this._data;
			var Y = this._VECTOR_TMP;
			var L = this._K_CHOLESKY;
			var dim = this.dimension;

			// Y = (L^-1) * X
			var i, lii, sum, k;
			for (i = 0; i < dim; i += 1) {
				sum = data[X + i];
				lii = data[L + (i * dim) + i];
				if (lii !== 0) {
					for (k = 0; k < i; k += 1) {
						sum -= data[L + (i * dim) + k] * data[Y + k];
					}
					data[Y + i] = (sum / lii);
				} else {
					data[Y + i] = 0;
				}
			}

			// X = (L^T)^-1 * Y
			var ix;
			for (ix = 0; ix < dim; ix += 1) {
				i = (dim - 1 - ix);
				lii = data[L + (i * dim) + i];
				if (lii !== 0) {
					sum = data[Y + i];
					for (k = (i + 1); k < dim; k += 1) {
						sum -= data[L + (k * dim) + i] * data[X + k];
					}
					data[X + i] = (sum / lii);
				} else {
					data[X + i] = 0;
				}
			}
		};

		Physics2DCustomConstraint.prototype._effMass = function () {
			var data = this._data;
			var dimension = this.dimension;
			var bodies = this.bodies;
			var limit = bodies.length;
			var length = (limit * 3);

			// Compute non-inverted effective mass
			var JAC = this._JACOBIAN;
			var KMASS = this._K_MASS;
			var i, j, k;
			for (i = 0; i < dimension; i += 1) {
				var JACI = (JAC + (i * length));
				for (j = i; j < dimension; j += 1) {
					var JACJ = (JAC + (j * length));
					var sum = 0;
					for (k = 0; k < limit; k += 1) {
						var body = bodies[k]._data;
						var k3 = (k * 3);
						sum += (body[(/*BODY_IMASS*/ 0)] * ((data[JACI + k3] * data[JACJ + k3]) + (data[JACI + k3 + 1] * data[JACJ + k3 + 1])));
						sum += (body[(/*BODY_IINERTIA*/ 1)] * (data[JACI + k3 + 2] * data[JACJ + k3 + 2]));
					}
					data[KMASS] = sum;
					KMASS += 1;
				}
			}
		};

		Physics2DCustomConstraint.prototype._preStep = function (deltaTime) {
			var dimension = this.dimension;
			var data = this._data;
			var i, limit;

			if (this._posConsts) {
				this._posConsts.call(this);
			}

			var JAC = this._JACOBIAN;
			var K_CHOLESKY = this._K_CHOLESKY;
			var BIAS = this._BIAS;

			if (!this._stiff && !this._velocityOnly) {
				this._posError.call(this, data, BIAS);

				this._jacobian.call(this, data, JAC);
				this._effMass();
				this._cholesky();

				// Compute |BIAS|^2
				var bsq = 0;
				limit = (BIAS + dimension);
				for (i = BIAS; i < limit; i += 1) {
					var bias = data[i];
					bsq += (bias * bias);
				}

				var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
				if (this._breakUnderError && (bsq > (maxError * maxError))) {
					return true;
				}

				var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/ 0)]);
				var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/ 1)]) + (omega * deltaTime))));
				var iG = (1 / (1 + gamma));
				var biasCoef = -(deltaTime * omega * omega * gamma);

				data[(/*CUSTOM_GAMMA*/ 6)] = (gamma * iG);

				// Multiply K_CHOLESKY with (1 / sqrt(iG)).
				//
				//   (We want to mulitply inverted eff-mass with iG.
				//    Instead of iG * K^1 we have:
				//    (g * L)^T^-1 * (g * L)^-1
				//    so we must have g = 1 / sqrt(iG)
				//    so that after multiplication we get iG * K^-1
				limit = (K_CHOLESKY + (dimension * dimension));
				iG = (1 / Math.sqrt(iG));
				for (i = K_CHOLESKY; i < limit; i += 1) {
					data[i] *= iG;
				}

				// Clamp BIAS magnitude to maxError
				// (implicit via scaling of biasCoef)
				bsq *= (biasCoef * biasCoef);
				if (bsq > (maxError * maxError)) {
					biasCoef *= (maxError / Math.sqrt(bsq));
				}

				// Multiply BIAS with biasCoef
				limit = (BIAS + dimension);
				for (i = BIAS; i < limit; i += 1) {
					data[i] *= biasCoef;
				}
			} else {
				this._jacobian.call(this, data, JAC);
				this._effMass();
				this._cholesky();

				// BIAS = 0
				limit = (BIAS + dimension);
				for (i = BIAS; i < limit; i += 1) {
					data[i] = 0;
				}
				data[(/*CUSTOM_GAMMA*/ 6)] = 0;
			}

			var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);

			// Multiply J_ACC with dtRatio.
			var J_ACC = this._J_ACC;
			limit = (J_ACC + this.dimension);
			for (i = J_ACC; i < limit; i += 1) {
				data[i] *= dtRatio;
			}

			data[(/*CUSTOM_JMAX*/ 5)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

			return false;
		};

		Physics2DCustomConstraint.prototype._warmStart = function () {
			this._applyImpulse(this._J_ACC);
		};

		Physics2DCustomConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var data = this._data;
			var JAC = this._JACOBIAN;
			var J = this._J_ACC;

			var bodies = this.bodies;
			var limit = bodies.length;
			var length = (limit * 3);
			var dim = this.dimension;

			var i;
			for (i = 0; i < limit; i += 1) {
				var b = bodies[i];
				if (b === body) {
					var sumX = 0;
					var sumY = 0;
					var sumW = 0;
					var j;
					for (j = 0; j < dim; j += 1) {
						sumX += (data[J + j] * data[JAC + (length * j)]);
						sumY += (data[J + j] * data[JAC + (length * j) + 1]);
						sumW += (data[J + j] * data[JAC + (length * j) + 2]);
					}

					dst[0] = sumX;
					dst[1] = sumY;
					dst[2] = sumW;
					return dst;
				}

				JAC += 3;
			}

			dst[0] = dst[1] = dst[2] = 0;
			return dst;
		};

		Physics2DCustomConstraint.prototype._applyImpulse = function (J, position) {
			var data = this._data;
			var JAC = this._JACOBIAN;

			var bodies = this.bodies;
			var limit = bodies.length;
			var length = (limit * 3);
			var dim = this.dimension;

			var i;
			for (i = 0; i < limit; i += 1) {
				var b = bodies[i];
				var body = b._data;

				var sumX = 0;
				var sumY = 0;
				var sumW = 0;
				var j;
				for (j = 0; j < dim; j += 1) {
					sumX += (data[J + j] * data[JAC + (length * j)]);
					sumY += (data[J + j] * data[JAC + (length * j) + 1]);
					sumW += (data[J + j] * data[JAC + (length * j) + 2]);
				}

				var im = body[(/*BODY_IMASS*/ 0)];
				var dr = sumW * body[(/*BODY_IINERTIA*/ 1)];
				if (position) {
					body[(/*BODY_POS*/ 2)] += sumX * im;
					body[(/*BODY_POS*/ 2) + 1] += sumY * im;
					if (dr !== 0) {
						b._deltaRotation(dr);
					}
				} else {
					body[(/*BODY_VEL*/ 7)] += sumX * im;
					body[(/*BODY_VEL*/ 7) + 1] += sumY * im;
					body[(/*BODY_VEL*/ 7) + 2] += dr;
				}

				JAC += 3;
			}
		};

		Physics2DCustomConstraint.prototype._iterateVel = function () {
			var dimension = this.dimension;
			var data = this._data;
			var i, limit;

			var VECTOR = this._VECTOR;
			var BIAS = this._BIAS;

			// VECTOR = BIAS - velocity()
			var j;
			var bodies = this.bodies;
			var limit2 = bodies.length;
			var JAC = this._JACOBIAN;
			for (i = 0; i < dimension; i += 1) {
				var term = data[BIAS + i];
				for (j = 0; j < limit2; j += 1) {
					var body = bodies[j]._data;
					term -= ((body[(/*BODY_VEL*/ 7)] * data[JAC]) + (body[(/*BODY_VEL*/ 7) + 1] * data[JAC + 1]) + (body[(/*BODY_VEL*/ 7) + 2] * data[JAC + 2]));
					JAC += 3;
				}
				data[VECTOR + i] = term;
			}

			// VECTOR = KMASS * VECTOR
			this._transform(VECTOR);

			// JOLD = JACC
			// JACC += (VECTOR - JOLD * gamma)
			var JACC = this._J_ACC;
			var JOLD = this._VECTOR_TMP;
			var jAcc;
			var gamma = data[(/*CUSTOM_GAMMA*/ 6)];
			for (i = 0; i < dimension; i += 1) {
				jAcc = data[JOLD + i] = data[JACC + i];
				data[JACC + i] += (data[VECTOR + i] - (jAcc * gamma));
			}

			if (this._velClamp) {
				this._velClamp.call(this, data, JACC);
			}

			// jlsq = |JACC|^2
			var jlsq = 0;
			limit = (JACC + dimension);
			for (i = JACC; i < limit; i += 1) {
				jAcc = data[i];
				jlsq += (jAcc * jAcc);
			}

			var jMax = data[(/*CUSTOM_JMAX*/ 5)];
			if (this._breakUnderForce && jlsq > (jMax * jMax)) {
				return true;
			} else if (!this._stiff && jlsq > (jMax * jMax)) {
				// clamp(JACC, jMax)
				jlsq = (jMax / Math.sqrt(jlsq));
				for (i = JACC; i < limit; i += 1) {
					data[i] *= jlsq;
				}
			}

			for (i = 0; i < dimension; i += 1) {
				data[VECTOR + i] = (data[JACC + i] - data[JOLD + i]);
			}

			this._applyImpulse(VECTOR);

			return false;
		};

		Physics2DCustomConstraint.prototype._iteratePos = function () {
			if (this._velocityOnly) {
				return false;
			}

			if (this._posConsts) {
				this._posConsts.call(this);
			}

			var dimension = this.dimension;
			var data = this._data;
			var i, limit;

			var BIAS = this._BIAS;
			this._posError.call(this, data, BIAS);

			// elsq = |BIAS|^2
			// BIAS = -BIAS
			limit = (BIAS + dimension);
			var err;
			var elsq = 0;
			for (i = BIAS; i < limit; i += 1) {
				err = data[i];
				elsq += (err * err);
				data[i] = -err;
			}

			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (this._breakUnderError && (elsq > (maxError * maxError))) {
				return true;
			}

			var JAC = this._JACOBIAN;

			// Recompute jacobian
			this._jacobian.call(this, data, JAC);

			// Recompute effective mass.
			this._effMass();
			this._cholesky();

			// BIAS = KMASS * BIAS
			this._transform(BIAS);
			if (this._posClamp) {
				this._posClamp.call(this, data, BIAS);
			}

			this._applyImpulse(BIAS, true);

			return false;
		};

		Physics2DCustomConstraint.create = function (params) {
			var p = new Physics2DCustomConstraint();

			var dim = p.dimension = params.dimension;
			p.bodies = params.bodies.concat();

			// K_MASS     = (dim * (dim + 1)) / 2
			// K_CHOLSEKY = (dim * dim)
			// BIAS       = dim
			// J_ACC      = dim
			// VECTOR     = dim
			// JACOBIAN   = (dim * bodies.length * 3)
			// VECTOR_TMP = dim
			var dataSize = 7 + (dim * (4 + dim) + ((dim * (dim + 1)) / 2));
			dataSize += (dim * p.bodies.length * 3);
			p._data = Types.createFloatArray(dataSize);
			Physics2DConstraint.prototype.init(p, params);

			p._K_MASS = 7;
			p._K_CHOLESKY = p._K_MASS + ((dim * (dim + 1)) / 2);
			p._BIAS = p._K_CHOLESKY + (dim * dim);
			p._J_ACC = p._BIAS + dim;
			p._VECTOR = p._J_ACC + dim;
			p._JACOBIAN = p._VECTOR + dim;
			p._VECTOR_TMP = p._JACOBIAN + (dim * p.bodies.length * 3);

			p._draw = params.debugDraw;
			p._posConsts = params.positionConstants;
			p._posError = params.position;
			p._posClamp = params.positionClamp;
			p._velClamp = params.velocityClamp;
			p._jacobian = params.jacobian;

			p._velocityOnly = (p._posError === undefined);

			return p;
		};

		return Physics2DCustomConstraint;
})

// =========================================================================
//
// Distance Constraint
//
// DIST DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*DIST_JOINTMIN*/5   // Joint limits
///*DIST_JOINTMAX*/6   //
///*DIST_LANCHOR1*/7   // Local anchor on bodyA (x, y)
///*DIST_LANCHOR2*/9   // Local anchor on bodyB (x, y)
///*DIST_RANCHOR1*/11  // Relative anchor on bodyA (x, y)
///*DIST_RANCHOR2*/13  // Relative anchor on bodyB (x, y)
///*DIST_KMASS*/15     // Effective mass matrix (scalar)
///*DIST_JACC*/16      // Accumulated impulse
///*DIST_JMAX*/17      // Maximum impulse (maxForce derived)
///*DIST_GAMMA*/18     // Soft constraint gamma
///*DIST_BIAS*/19      // Bias for soft constraint (scalar)
///*DIST_NORMAL*/20    // Direction of constraint error (x, y)
///*DIST_CX1*/22       // (RANCHOR1 cross NORMAL)
///*DIST_CX2*/23       // (RANCHOR2 cross NORMAL)
//
///*DIST_DATA_SIZE*/24
define(
	'spell/physics/2D/DistanceConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DDistanceConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
			this.type = "DISTANCE";
			this.dimension = 1;
			// Inherited
			this._ANCHOR_A = (/*DIST_LANCHOR1*/ 7);
			this._ANCHOR_B = (/*DIST_LANCHOR2*/ 9);
			// =======================================================
			// Inherited
			this._JACC = (/*DIST_JACC*/ 16);
		}
		__extends(Physics2DDistanceConstraint, Physics2DConstraint);


		// ===============================================
		Physics2DDistanceConstraint.prototype.getLowerBound = function () {
			return this._data[(/*DIST_JOINTMIN*/ 5)];
		};
		Physics2DDistanceConstraint.prototype.getUpperBound = function () {
			return this._data[(/*DIST_JOINTMAX*/ 6)];
		};

		Physics2DDistanceConstraint.prototype.setLowerBound = function (lowerBound) {
			var data = this._data;
			if (data[(/*DIST_JOINTMIN*/ 5)] !== lowerBound) {
				data[(/*DIST_JOINTMIN*/ 5)] = lowerBound;
				this._equal = (lowerBound === data[(/*DIST_JOINTMAX*/ 6)]);
				this.wake(true);
			}
		};
		Physics2DDistanceConstraint.prototype.setUpperBound = function (upperBound) {
			var data = this._data;
			if (data[(/*DIST_JOINTMAX*/ 6)] !== upperBound) {
				data[(/*DIST_JOINTMAX*/ 6)] = upperBound;
				this._equal = (upperBound === data[(/*DIST_JOINTMIN*/ 5)]);
				this.wake(true);
			}
		};

		Physics2DDistanceConstraint.prototype._posError = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var jointMin = data[(/*DIST_JOINTMIN*/ 5)];
			var jointMax = data[(/*DIST_JOINTMAX*/ 6)];

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*DIST_LANCHOR1*/ 7), (/*DIST_RANCHOR1*/ 11));
			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*DIST_LANCHOR2*/ 9), (/*DIST_RANCHOR2*/ 13));

			var nx = ((b2[(/*BODY_POS*/ 2)] + data[(/*DIST_RANCHOR2*/ 13)]) - (b1[(/*BODY_POS*/ 2)] + data[(/*DIST_RANCHOR1*/ 11)]));
			var ny = ((b2[(/*BODY_POS*/ 2) + 1] + data[(/*DIST_RANCHOR2*/ 13) + 1]) - (b1[(/*BODY_POS*/ 2) + 1] + data[(/*DIST_RANCHOR1*/ 11) + 1]));

			var err = ((nx * nx) + (ny * ny));
			if (err < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
				nx = data[(/*DIST_NORMAL*/ 20)];
				ny = data[(/*DIST_NORMAL*/ 20) + 1];
				err = 0;
			} else {
				err = Math.sqrt(err);
				var rec = (1 / err);
				nx *= rec;
				ny *= rec;
			}

			if (this._equal) {
				err -= jointMin;
				this._slack = false;
			} else if (err < jointMin) {
				err = (jointMin - err);
				nx = -nx;
				ny = -ny;
				this._slack = false;
			} else if (err > jointMax) {
				err -= jointMax;
				this._slack = false;
			} else {
				// Don't set normals to 0.
				// In this case that _slack is true, we do no further work
				// So we permit normals to persist so that should constraint
				// become degenerate we can still choose a 'good' direction.
				//
				// Constraint only becomes degenerate when jointMin = 0 and we reach this
				// limit. In this condition we want negated normals, so that's what we
				// allow to persist.
				nx = -nx;
				ny = -ny;

				err = 0;
				this._slack = true;
			}

			data[(/*DIST_NORMAL*/ 20)] = nx;
			data[(/*DIST_NORMAL*/ 20) + 1] = ny;
			data[(/*DIST_BIAS*/ 19)] = (-err);
		};

		Physics2DDistanceConstraint.prototype._preStep = function (deltaTime) {
			this._posError();
			if (this._slack) {
				return false;
			}

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			// Compute non-inverted effective mass.
			var nx = data[(/*DIST_NORMAL*/ 20)];
			var ny = data[(/*DIST_NORMAL*/ 20) + 1];
			var cx1 = data[(/*DIST_CX1*/ 22)] = ((data[(/*DIST_RANCHOR1*/ 11)] * ny) - (data[(/*DIST_RANCHOR1*/ 11) + 1] * nx));
			var cx2 = data[(/*DIST_CX2*/ 23)] = ((data[(/*DIST_RANCHOR2*/ 13)] * ny) - (data[(/*DIST_RANCHOR2*/ 13) + 1] * nx));
			data[(/*DIST_KMASS*/ 15)] = (b1[(/*BODY_IMASS*/ 0)] + (cx1 * b1[(/*BODY_IINERTIA*/ 1)] * cx1) + b2[(/*BODY_IMASS*/ 0)] + (cx2 * b2[(/*BODY_IINERTIA*/ 1)] * cx2));

			// Invert effective mass
			Physics2DConstraint.prototype.safe_invert(data, (/*DIST_KMASS*/ 15), (/*DIST_JACC*/ 16));

			if (!this._stiff) {
				if (Physics2DConstraint.prototype.soft_params(data, (/*DIST_KMASS*/ 15), (/*DIST_GAMMA*/ 18), (/*DIST_BIAS*/ 19), deltaTime, this._breakUnderError)) {
					return true;
				}
			} else {
				data[(/*DIST_GAMMA*/ 18)] = 0.0;
				data[(/*DIST_BIAS*/ 19)] = 0.0;
			}

			var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
			data[(/*DIST_JACC*/ 16)] *= dtRatio;
			data[(/*DIST_JMAX*/ 17)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

			return false;
		};

		Physics2DDistanceConstraint.prototype._warmStart = function () {
			if (this._slack) {
				return;
			}

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var jAcc = data[(/*DIST_JACC*/ 16)];
			var jx = (data[(/*DIST_NORMAL*/ 20)] * jAcc);
			var jy = (data[(/*DIST_NORMAL*/ 20) + 1] * jAcc);

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (data[(/*DIST_CX1*/ 22)] * jAcc * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (data[(/*DIST_CX2*/ 23)] * jAcc * b2[(/*BODY_IINERTIA*/ 1)]);
		};

		Physics2DDistanceConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var data = this._data;

			var jAcc = data[(/*DIST_JACC*/ 16)];
			var jx = (data[(/*DIST_NORMAL*/ 20)] * jAcc);
			var jy = (data[(/*DIST_NORMAL*/ 20) + 1] * jAcc);

			if (body === this.bodyA) {
				dst[0] = -jx;
				dst[1] = -jy;
				dst[2] = -(data[(/*DIST_CX1*/ 22)] * jAcc);
			} else if (body === this.bodyB) {
				dst[0] = jx;
				dst[1] = jy;
				dst[2] = (data[(/*DIST_CX2*/ 23)] * jAcc);
			} else {
				dst[0] = dst[1] = dst[2] = 0;
			}

			return dst;
		};

		Physics2DDistanceConstraint.prototype._iterateVel = function () {
			if (this._slack) {
				return false;
			}

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			// x = Bias - VelocityError
			var nx = data[(/*DIST_NORMAL*/ 20)];
			var ny = data[(/*DIST_NORMAL*/ 20) + 1];
			var cx1 = data[(/*DIST_CX1*/ 22)];
			var cx2 = data[(/*DIST_CX2*/ 23)];
			var x = (data[(/*DIST_BIAS*/ 19)] - ((nx * (b2[(/*BODY_VEL*/ 7)] - b1[(/*BODY_VEL*/ 7)])) + (ny * (b2[(/*BODY_VEL*/ 7) + 1] - b1[(/*BODY_VEL*/ 7) + 1])) + (cx2 * b2[(/*BODY_VEL*/ 7) + 2]) - (cx1 * b1[(/*BODY_VEL*/ 7) + 2])));

			var jOld = data[(/*DIST_JACC*/ 16)];

			// Impulse.
			// j = K * x - Jacc * gamma
			var j = ((data[(/*DIST_KMASS*/ 15)] * x) - (jOld * data[(/*DIST_GAMMA*/ 18)]));

			// Accumulate and clamp.
			var jAcc = (jOld + j);
			var jMax = data[(/*DIST_JMAX*/ 17)];
			if (!this._equal && jAcc > 0) {
				jAcc = 0;
			}
			if (this._breakUnderForce) {
				if (jAcc > jMax || jAcc < -jMax) {
					return true;
				}
			} else if (!this._stiff) {
				if (jAcc > jMax) {
					jAcc = jMax;
				} else if (jAcc < -jMax) {
					jAcc = -jMax;
				}
			}

			j = (jAcc - jOld);
			data[(/*DIST_JACC*/ 16)] = jAcc;

			// Apply impulse.
			var jx = (nx * j);
			var jy = (ny * j);

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (data[(/*DIST_CX1*/ 22)] * j * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (data[(/*DIST_CX2*/ 23)] * j * b2[(/*BODY_IINERTIA*/ 1)]);

			return false;
		};

		Physics2DDistanceConstraint.prototype._iteratePos = function () {
			this._posError();
			if (this._slack) {
				return false;
			}

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var im1 = b1[(/*BODY_IMASS*/ 0)];
			var im2 = b2[(/*BODY_IMASS*/ 0)];
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];

			var err = data[(/*DIST_BIAS*/ 19)];
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (this._breakUnderError && (err > maxError || err < -maxError)) {
				return true;
			}

			var slop = Physics2DConfig.DIST_SLOP_SQ;
			if ((err * err) < slop) {
				return false;
			}

			err *= Physics2DConfig.DIST_BIAS_COEF;

			var massSum = (im1 + im2);
			var nx = data[(/*DIST_NORMAL*/ 20)];
			var ny = data[(/*DIST_NORMAL*/ 20) + 1];

			var j, jx, jy;

			// Handle large error seperately
			if ((err * err) > Physics2DConfig.DIST_LARGE_ERROR_SQ) {
				if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
					j = (err * Physics2DConfig.DIST_LARGE_ERROR_BIAS / massSum);
					if (this._equal || j < 0) {
						jx = (nx * j);
						jy = (ny * j);
						b1[(/*BODY_POS*/ 2)] -= (jx * im1);
						b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
						b2[(/*BODY_POS*/ 2)] += (jx * im2);
						b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);

						// Recalculate error.
						this._posError();
						err = data[(/*DIST_BIAS*/ 19)] * Physics2DConfig.DIST_BIAS_COEF;
						nx = data[(/*DIST_NORMAL*/ 20)];
						ny = data[(/*DIST_NORMAL*/ 20) + 1];
					}
				}
			}

			var cx1 = ((data[(/*DIST_RANCHOR1*/ 11)] * ny) - (data[(/*DIST_RANCHOR1*/ 11) + 1] * nx));
			var cx2 = ((data[(/*DIST_RANCHOR2*/ 13)] * ny) - (data[(/*DIST_RANCHOR2*/ 13) + 1] * nx));
			data[(/*DIST_KMASS*/ 15)] = (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

			data[(/*DIST_BIAS*/ 19)] = err;
			Physics2DConstraint.prototype.safe_solve(data, (/*DIST_KMASS*/ 15), (/*DIST_BIAS*/ 19), (/*DIST_BIAS*/ 19));
			j = data[(/*DIST_BIAS*/ 19)];

			if (this._equal || j < 0) {
				jx = (nx * j);
				jy = (ny * j);

				b1[(/*BODY_POS*/ 2)] -= (jx * im1);
				b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
				var dr = (-cx1 * ii1 * j);
				if (dr !== 0) {
					this.bodyA._deltaRotation(dr);
				}

				b2[(/*BODY_POS*/ 2)] += (jx * im2);
				b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);
				dr = (cx2 * ii2 * j);
				if (dr !== 0) {
					this.bodyB._deltaRotation(dr);
				}
			}

			return false;
		};

		// params = {
		//   bodyA, bodyB
		//   anchorA, anchorB,
		//   lowerBound, upperBound
		//   .. common constraint params
		// }
		Physics2DDistanceConstraint.create = function (params) {
			var p = new Physics2DDistanceConstraint();
			var data = p._data = Types.createFloatArray(/*DIST_DATA_SIZE*/ 24);
			Physics2DConstraint.prototype.init(p, params);

			var anchor = params.anchorA;
			data[(/*DIST_LANCHOR1*/ 7)] = (anchor ? anchor[0] : 0);
			data[(/*DIST_LANCHOR1*/ 7) + 1] = (anchor ? anchor[1] : 0);

			anchor = params.anchorB;
			data[(/*DIST_LANCHOR2*/ 9)] = (anchor ? anchor[0] : 0);
			data[(/*DIST_LANCHOR2*/ 9) + 1] = (anchor ? anchor[1] : 0);

			var min = data[(/*DIST_JOINTMIN*/ 5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
			var max = data[(/*DIST_JOINTMAX*/ 6)] = (params.upperBound !== undefined ? params.upperBound : 0);
			p._equal = (min === max);

			p._slack = false;

			p.bodyA = params.bodyA;
			p.bodyB = params.bodyB;

			// Seed normal incase initial anchors are degenerate.
			data[(/*DIST_NORMAL*/ 20)] = 1;
			data[(/*DIST_NORMAL*/ 20) + 1] = 0;

			return p;
		};

		// Redirect some methods
		Physics2DDistanceConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
		Physics2DDistanceConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
		Physics2DDistanceConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
		Physics2DDistanceConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
		Physics2DDistanceConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;


		Physics2DDistanceConstraint.prototype._draw = function distanceDrawFn(debug) {
			var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
			var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
			var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
			var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var x1 = (b1[(/*BODY_POS*/ 2)] + data[(/*DIST_RANCHOR1*/ 11)]);
			var y1 = (b1[(/*BODY_POS*/ 2) + 1] + data[(/*DIST_RANCHOR1*/ 11) + 1]);
			var x2 = (b2[(/*BODY_POS*/ 2)] + data[(/*DIST_RANCHOR2*/ 13)]);
			var y2 = (b2[(/*BODY_POS*/ 2) + 1] + data[(/*DIST_RANCHOR2*/ 13) + 1]);

			var nx = (x2 - x1);
			var ny = (y2 - y1);
			var nlsq = ((nx * nx) + (ny * ny));
			if (nlsq > Physics2DConfig.NORMALIZE_SQ_EPSILON) {
				var nl = Math.sqrt(nlsq);
				var rec = (1 / nl);
				nx *= rec;
				ny *= rec;

				var midX = (0.5 * (x1 + x2));
				var midY = (0.5 * (y1 + y2));

				var jointMin = data[(/*DIST_JOINTMIN*/ 5)];
				var jointMax = data[(/*DIST_JOINTMAX*/ 6)];
				var minX1 = (midX - (nx * (jointMin * 0.5)));
				var minY1 = (midY - (ny * (jointMin * 0.5)));
				var minX2 = (midX + (nx * (jointMin * 0.5)));
				var minY2 = (midY + (ny * (jointMin * 0.5)));
				var maxX1 = (midX - (nx * (jointMax * 0.5)));
				var maxY1 = (midY - (ny * (jointMax * 0.5)));
				var maxX2 = (midX + (nx * (jointMax * 0.5)));
				var maxY2 = (midY + (ny * (jointMax * 0.5)));

				debug.drawLine(minX1, minY1, minX2, minY2, colSA);
				debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
				debug.drawLine(maxX2, maxY2, minX2, minY2, colSB);

				if (!this._stiff) {
					var numCoils = debug.constraintSpringNumCoils;
					var radius = (debug.constraintSpringRadius * debug.screenToPhysics2D);
					if (nl > jointMax) {
						debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
						debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB);
					} else if (nl < jointMin) {
						debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
						debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA);
					}
				}
			}

			var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
			debug._drawAnchor(x1, y1, rad, colA);
			debug._drawAnchor(x2, y2, rad, colB);
		};

		return Physics2DDistanceConstraint;
})


// =========================================================================
//
// Line Constraint
//
// LINE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*LINE_JOINTMIN*/5   // Joint limits (axial)
///*LINE_JOINTMAX*/6   //
///*LINE_LANCHOR1*/7   // Local anchor on bodyA (x, y)
///*LINE_LANCHOR2*/9   // Local anchor on bodyB (x, y)
///*LINE_LAXIS*/11     // Local axis on bodyA (x, y)
///*LINE_RANCHOR1*/13  // Relative anchor on bodyA (x, y)
///*LINE_RANCHOR2*/15  // Relative anchor on bodyB (x, y)
///*LINE_RAXIS*/17     // Relative/World axis on bodyA (x, y)
///*LINE_KMASS*/19     // Effective mass [a b; b c] (symmetric)
///*LINE_JACC*/22      // Accumulated impuse (x, y)
///*LINE_JMAX*/24      // Maximum impulse magnitude
///*LINE_GAMMA*/25     // Soft constraint gamma
///*LINE_BIAS*/26      // Soft constraint bias (x, y)
///*LINE_CX1*/28
///*LINE_CX2*/29
///*LINE_DOT1*/30
///*LINE_DOT2*/31
///*LINE_SCALE*/32     // Direction scaling of axis.
//
///*LINE_DATA_SIZE*/33
define(
	'spell/physics/2D/LineConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DLineConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
			this.type = "LINE";
			this.dimension = 2;
			// Inherited
			this._ANCHOR_A = (/*LINE_LANCHOR1*/ 7);
			this._ANCHOR_B = (/*LINE_LANCHOR2*/ 9);
			// ==========================================================
			// Inherited
			this._JACC = (/*LINE_JACC*/ 22);
		}

		__extends(Physics2DLineConstraint, Physics2DConstraint);


		// ===============================================
		Physics2DLineConstraint.prototype.getLowerBound = function () {
			return this._data[(/*LINE_JOINTMIN*/ 5)];
		};
		Physics2DLineConstraint.prototype.getUpperBound = function () {
			return this._data[(/*LINE_JOINTMAX*/ 6)];
		};

		Physics2DLineConstraint.prototype.setLowerBound = function (lowerBound) {
			var data = this._data;
			if (data[(/*LINE_JOINTMIN*/ 5)] !== lowerBound) {
				data[(/*LINE_JOINTMIN*/ 5)] = lowerBound;
				this._equal = (lowerBound === data[(/*LINE_JOINTMAX*/ 6)]);
				this.wake(true);
			}
		};
		Physics2DLineConstraint.prototype.setUpperBound = function (upperBound) {
			var data = this._data;
			if (data[(/*LINE_JOINTMAX*/ 6)] !== upperBound) {
				data[(/*LINE_JOINTMAX*/ 6)] = upperBound;
				this._equal = (upperBound === data[(/*LINE_JOINTMIN*/ 5)]);
				this.wake(true);
			}
		};

		Physics2DLineConstraint.prototype.getAxis = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}
			var data = this._data;
			dst[0] = data[(/*LINE_LAXIS*/ 11)];
			dst[1] = data[(/*LINE_LAXIS*/ 11) + 1];
			return dst;
		};
		Physics2DLineConstraint.prototype.setAxis = function (axis /*v2*/ ) {
			var data = this._data;
			var newX = axis[0];
			var newY = axis[1];
			if (newX !== data[(/*LINE_LAXIS*/ 11)] || newY !== data[(/*LINE_LAXIS*/ 11) + 1]) {
				var nlsq = ((newX * newX) + (newY * newY));
				if (nlsq === 0) {
					return;
				} else {
					nlsq = (1 / Math.sqrt(nlsq));
					newX *= nlsq;
					newY *= nlsq;
				}
				data[(/*LINE_LAXIS*/ 11)] = newX;
				data[(/*LINE_LAXIS*/ 11) + 1] = newY;
				this.wake(true);
			}
		};

		Physics2DLineConstraint.prototype._posError = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*LINE_LANCHOR1*/ 7), (/*LINE_RANCHOR1*/ 13));
			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*LINE_LANCHOR2*/ 9), (/*LINE_RANCHOR2*/ 15));
			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*LINE_LAXIS*/ 11), (/*LINE_RAXIS*/ 17));

			var jointMin = data[(/*LINE_JOINTMIN*/ 5)];
			var jointMax = data[(/*LINE_JOINTMAX*/ 6)];

			var rx1 = data[(/*LINE_RANCHOR1*/ 13)];
			var ry1 = data[(/*LINE_RANCHOR1*/ 13) + 1];
			var rx2 = data[(/*LINE_RANCHOR2*/ 15)];
			var ry2 = data[(/*LINE_RANCHOR2*/ 15) + 1];
			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];

			// Store (dx, dy) in (cx1, cx2) temporarigly.
			// As this information is needed in subsequent calculations for eff-mass.
			// We take care not to alias values!
			var dx = data[(/*LINE_CX1*/ 28)] = ((b2[(/*BODY_POS*/ 2)] + rx2) - (b1[(/*BODY_POS*/ 2)] + rx1));
			var dy = data[(/*LINE_CX2*/ 29)] = ((b2[(/*BODY_POS*/ 2) + 1] + ry2) - (b1[(/*BODY_POS*/ 2) + 1] + ry1));

			var errX = ((nx * dy) - (ny * dx));
			var errY = ((nx * dx) + (ny * dy));
			if (this._equal) {
				errY -= jointMin;
				data[(/*LINE_SCALE*/ 32)] = 1.0;
			} else {
				if (errY > jointMax) {
					errY -= jointMax;
					data[(/*LINE_SCALE*/ 32)] = 1.0;
				} else if (errY < jointMin) {
					errY = (jointMin - errY);
					data[(/*LINE_SCALE*/ 32)] = -1.0;
				} else {
					errY = 0;
					data[(/*LINE_SCALE*/ 32)] = 0.0;
				}
			}

			data[(/*LINE_BIAS*/ 26)] = (-errX);
			data[(/*LINE_BIAS*/ 26) + 1] = (-errY);
		};

		Physics2DLineConstraint.prototype._preStep = function (deltaTime) {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			// Must compute (dx, dy) (stored into cx1/cx2)
			// As well as scale for eff-mass computation.
			this._posError();

			// Compute non-inverted effective mass.
			var rx1 = data[(/*LINE_RANCHOR1*/ 13)];
			var ry1 = data[(/*LINE_RANCHOR1*/ 13) + 1];
			var rx2 = data[(/*LINE_RANCHOR2*/ 15)];
			var ry2 = data[(/*LINE_RANCHOR2*/ 15) + 1];
			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];
			var scale = data[(/*LINE_SCALE*/ 32)];
			var delX = (data[(/*LINE_CX1*/ 28)] + rx1);
			var delY = (data[(/*LINE_CX2*/ 29)] + ry1);

			var cx1 = data[(/*LINE_CX1*/ 28)] = (nx * delY) - (ny * delX);
			var cx2 = data[(/*LINE_CX2*/ 29)] = (nx * ry2) - (ny * rx2);
			var dot1 = data[(/*LINE_DOT1*/ 30)] = (nx * delX) + (ny * delY);
			var dot2 = data[(/*LINE_DOT2*/ 31)] = (nx * rx2) + (ny * ry2);

			var massSum = (b1[(/*BODY_IMASS*/ 0)] + b2[(/*BODY_IMASS*/ 0)]);
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];

			data[(/*LINE_KMASS*/ 19)] = massSum + (dot1 * ii1 * dot1) + (dot2 * ii2 * dot2);
			data[(/*LINE_KMASS*/ 19) + 1] = -scale * ((dot1 * ii1 * cx1) + (dot2 * ii2 * cx2));
			data[(/*LINE_KMASS*/ 19) + 2] = scale * scale * (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

			// Invert effective mass.
			Physics2DConstraint.prototype.safe_invert2(data, (/*LINE_KMASS*/ 19), (/*LINE_JACC*/ 22));

			if (!this._stiff) {
				if (Physics2DConstraint.prototype.soft_params2(data, (/*LINE_KMASS*/ 19), (/*LINE_GAMMA*/ 25), (/*LINE_BIAS*/ 26), deltaTime, this._breakUnderError)) {
					return true;
				}
			} else {
				data[(/*LINE_GAMMA*/ 25)] = 0;
				data[(/*LINE_BIAS*/ 26)] = 0;
				data[(/*LINE_BIAS*/ 26) + 1] = 0;
			}

			var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
			data[(/*LINE_JACC*/ 22)] *= dtRatio;
			data[(/*LINE_JACC*/ 22) + 1] *= dtRatio;
			data[(/*LINE_JMAX*/ 24)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

			return false;
		};

		Physics2DLineConstraint.prototype._warmStart = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var jx = data[(/*LINE_JACC*/ 22)];
			var jy = data[(/*LINE_JACC*/ 22) + 1];
			var scale = data[(/*LINE_SCALE*/ 32)];
			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];

			var lx = (scale * nx * jy) - (ny * jx);
			var ly = (nx * jx) + (scale * ny * jy);

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (lx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (ly * im);
			b1[(/*BODY_VEL*/ 7) + 2] += (((scale * data[(/*LINE_CX1*/ 28)] * jy) - (data[(/*LINE_DOT1*/ 30)] * jx)) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (lx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (ly * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((data[(/*LINE_DOT2*/ 31)] * jx) - (scale * data[(/*LINE_CX2*/ 29)] * jy)) * b2[(/*BODY_IINERTIA*/ 1)]);
		};

		Physics2DLineConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var data = this._data;
			var jx = data[(/*LINE_JACC*/ 22)];
			var jy = data[(/*LINE_JACC*/ 22) + 1];
			var scale = data[(/*LINE_SCALE*/ 32)];
			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];

			var lx = (scale * nx * jy) - (ny * jx);
			var ly = (nx * jx) + (scale * ny * jy);

			if (body === this.bodyA) {
				dst[0] = -lx;
				dst[1] = -ly;
				dst[2] = ((scale * data[(/*LINE_CX1*/ 28)] * jy) - (data[(/*LINE_DOT1*/ 30)] * jx));
			} else if (body === this.bodyB) {
				dst[0] = lx;
				dst[1] = ly;
				dst[2] = ((data[(/*LINE_DOT2*/ 31)] * jx) - (scale * data[(/*LINE_CX2*/ 29)] * jy));
			} else {
				dst[0] = dst[1] = dst[2] = 0;
			}

			return dst;
		};

		Physics2DLineConstraint.prototype._iterateVel = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			// (x, y) = Bias - VelocityError
			var scale = data[(/*LINE_SCALE*/ 32)];
			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];
			var cx1 = data[(/*LINE_CX1*/ 28)];
			var cx2 = data[(/*LINE_CX2*/ 29)];
			var dot1 = data[(/*LINE_DOT1*/ 30)];
			var dot2 = data[(/*LINE_DOT2*/ 31)];

			var vx = (b2[(/*BODY_VEL*/ 7)] - b1[(/*BODY_VEL*/ 7)]);
			var vy = (b2[(/*BODY_VEL*/ 7) + 1] - b1[(/*BODY_VEL*/ 7) + 1]);
			var vw1 = b1[(/*BODY_VEL*/ 7) + 2];
			var vw2 = b2[(/*BODY_VEL*/ 7) + 2];
			var x = (data[(/*LINE_BIAS*/ 26)] - ((nx * vy) - (ny * vx) + (vw2 * dot2) - (vw1 * dot1)));
			var y = (data[(/*LINE_BIAS*/ 26) + 1] - (scale * ((nx * vx) + (ny * vy) - (vw2 * cx2) + (vw1 * cx1))));

			var jOldX = data[(/*LINE_JACC*/ 22)];
			var jOldY = data[(/*LINE_JACC*/ 22) + 1];
			var gamma = data[(/*LINE_GAMMA*/ 25)];

			// Impulse.
			// (jx, jy) = K * (x, y) - Jacc * gamma
			var Kb = data[(/*LINE_KMASS*/ 19) + 1];
			var jx = ((data[(/*LINE_KMASS*/ 19)] * x) + (Kb * y)) - (jOldX * gamma);
			var jy = ((Kb * x) + (data[(/*LINE_KMASS*/ 19) + 2] * y)) - (jOldY * gamma);

			// Accumulate and clamp
			var jAccX = (jOldX + jx);
			var jAccY = (jOldY + jy);
			if (!this._equal && jAccY > 0) {
				jAccY = 0;
			}

			var jlsq = ((jAccX * jAccX) + (jAccY * jAccY));
			var jMax = data[(/*LINE_JMAX*/ 24)];
			if (this._breakUnderForce) {
				if (jlsq > (jMax * jMax)) {
					return true;
				}
			} else if (!this._stiff) {
				if (jlsq > (jMax * jMax)) {
					jlsq = (jMax / Math.sqrt(jlsq));
					jAccX *= jlsq;
					jAccY *= jlsq;
				}
			}

			jx = (jAccX - jOldX);
			jy = (jAccY - jOldY);
			data[(/*LINE_JACC*/ 22)] = jAccX;
			data[(/*LINE_JACC*/ 22) + 1] = jAccY;

			// Apply impulse.
			var lx = (scale * nx * jy) - (ny * jx);
			var ly = (nx * jx) + (scale * ny * jy);

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (lx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (ly * im);
			b1[(/*BODY_VEL*/ 7) + 2] += (((scale * cx1 * jy) - (dot1 * jx)) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (lx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (ly * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((dot2 * jx) - (scale * cx2 * jy)) * b2[(/*BODY_IINERTIA*/ 1)]);

			return false;
		};

		Physics2DLineConstraint.prototype._iteratePos = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			this._posError();
			var errX = data[(/*LINE_BIAS*/ 26)];
			var errY = data[(/*LINE_BIAS*/ 26) + 1];
			var elsq = ((errX * errX) + (errY * errY));

			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (this._breakUnderError && elsq > (maxError * maxError)) {
				return true;
			}

			var slop = Physics2DConfig.LINE_SLOP_SQ;
			if (elsq < slop) {
				return false;
			}

			var bias = Physics2DConfig.LINE_BIAS_COEF;
			errX *= bias;
			errY *= bias;
			elsq *= (bias * bias);

			var im1 = b1[(/*BODY_MASS*/ 0)];
			var im2 = b2[(/*BODY_MASS*/ 0)];
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];
			var massSum = (im1 + im2);

			var nx = data[(/*LINE_RAXIS*/ 17)];
			var ny = data[(/*LINE_RAXIS*/ 17) + 1];
			var scale = data[(/*LINE_SCALE*/ 32)];

			var lx, ly;

			// Solve large error case seperately.
			if (elsq > Physics2DConfig.LINE_LARGE_ERROR_SQ) {
				if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
					var K = (Physics2DConfig.LINE_LARGE_ERROR_BIAS / massSum);
					lx = K * ((ny * errX) - (scale * nx * errY));
					ly = K * ((nx * errX * scale) - (ny * errX));

					b1[(/*BODY_POS*/ 2)] -= (lx * im1);
					b1[(/*BODY_POS*/ 2) + 1] -= (ly * im1);
					b2[(/*BODY_POS*/ 2)] += (lx * im2);
					b2[(/*BODY_POS*/ 2) + 1] += (ly * im2);

					this._posError();
					nx = data[(/*LINE_RAXIS*/ 17)];
					ny = data[(/*LINE_RAXIS*/ 17) + 1];
					scale = data[(/*LINE_SCALE*/ 32)];

					errX = (data[(/*LINE_BIAS*/ 26)] * bias);
					errY = (data[(/*LINE_BIAS*/ 26) + 1] * bias);
				}
			}

			// Compute non-inverted effective mass.
			var rx1 = data[(/*LINE_RANCHOR1*/ 13)];
			var ry1 = data[(/*LINE_RANCHOR1*/ 13) + 1];
			var rx2 = data[(/*LINE_RANCHOR2*/ 15)];
			var ry2 = data[(/*LINE_RANCHOR2*/ 15) + 1];
			var delX = (data[(/*LINE_CX1*/ 28)] + rx1);
			var delY = (data[(/*LINE_CX2*/ 29)] + ry1);

			var cx1 = (nx * delY) - (ny * delX);
			var cx2 = (nx * ry2) - (ny * rx2);
			var dot1 = (nx * delX) + (ny * delY);
			var dot2 = (nx * rx2) + (ny * ry2);

			data[(/*LINE_KMASS*/ 19)] = massSum + (dot1 * ii1 * dot1) + (dot2 * ii2 * dot2);
			data[(/*LINE_KMASS*/ 19) + 1] = -scale * ((dot1 * ii1 * cx1) + (dot2 * ii2 * cx2));
			data[(/*LINE_KMASS*/ 19) + 2] = scale * scale * (massSum + (cx1 * ii1 * cx1) + (cx2 * ii2 * cx2));

			data[(/*LINE_BIAS*/ 26)] = errX;
			data[(/*LINE_BIAS*/ 26) + 1] = errY;
			Physics2DConstraint.prototype.safe_solve2(data, (/*LINE_KMASS*/ 19), (/*LINE_BIAS*/ 26), (/*LINE_BIAS*/ 26));
			var jx = data[(/*LINE_BIAS*/ 26)];
			var jy = data[(/*LINE_BIAS*/ 26) + 1];

			if (!this._equal && jy > 0) {
				jy = 0;
			}

			lx = (scale * nx * jy) - (ny * jx);
			ly = (nx * jx) + (scale * ny * jy);

			b1[(/*BODY_POS*/ 2)] -= (lx * im1);
			b1[(/*BODY_POS*/ 2) + 1] -= (ly * im1);
			var dr = (((scale * cx1 * jy) - (dot1 * jx)) * ii1);
			if (dr !== 0) {
				this.bodyA._deltaRotation(dr);
			}

			b2[(/*BODY_POS*/ 2)] += (lx * im2);
			b2[(/*BODY_POS*/ 2) + 1] += (ly * im2);
			dr = (((dot2 * jx) - (scale * cx2 * jy)) * ii2);
			if (dr !== 0) {
				this.bodyB._deltaRotation(dr);
			}

			return false;
		};

		// params = {
		//   bodyA, bodyB
		//   anchorA, anchorB, axis
		//   lowerBound, upperBound
		//   .. common constraint params
		// }
		Physics2DLineConstraint.create = function (params) {
			var p = new Physics2DLineConstraint();
			var data = p._data = Types.createFloatArray(/*LINE_DATA_SIZE*/ 33);
			Physics2DConstraint.prototype.init(p, params);

			var anchor = params.anchorA;
			data[(/*LINE_LANCHOR1*/ 7)] = (anchor ? anchor[0] : 0);
			data[(/*LINE_LANCHOR1*/ 7) + 1] = (anchor ? anchor[1] : 0);

			anchor = params.anchorB;
			data[(/*LINE_LANCHOR2*/ 9)] = (anchor ? anchor[0] : 0);
			data[(/*LINE_LANCHOR2*/ 9) + 1] = (anchor ? anchor[1] : 0);

			anchor = params.axis;
			data[(/*LINE_LAXIS*/ 11)] = anchor[0];
			data[(/*LINE_LAXIS*/ 11) + 1] = anchor[1];

			var min = data[(/*LINE_JOINTMIN*/ 5)] = (params.lowerBound !== undefined ? params.lowerBound : Number.NEGATIVE_INFINITY);
			var max = data[(/*LINE_JOINTMAX*/ 6)] = (params.upperBound !== undefined ? params.upperBound : Number.POSITIVE_INFINITY);
			p._equal = (min === max);

			p.bodyA = params.bodyA;
			p.bodyB = params.bodyB;

			return p;
		};

		// Redirect some methods
		Physics2DLineConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
		Physics2DLineConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
		Physics2DLineConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
		Physics2DLineConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
		Physics2DLineConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;



		Physics2DLineConstraint.prototype._draw = function lineDrawFn(debug) {
			var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
			var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
			var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
			var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);
			var colSC = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var x1 = (b1[(/*BODY_POS*/ 2)] + data[(/*LINE_RANCHOR1*/ 13)]);
			var y1 = (b1[(/*BODY_POS*/ 2) + 1] + data[(/*LINE_RANCHOR1*/ 13) + 1]);
			var x2 = (b2[(/*BODY_POS*/ 2)] + data[(/*LINE_RANCHOR2*/ 15)]);
			var y2 = (b2[(/*BODY_POS*/ 2) + 1] + data[(/*LINE_RANCHOR2*/ 15) + 1]);
			var dx = data[(/*LINE_RAXIS*/ 17)];
			var dy = data[(/*LINE_RAXIS*/ 17) + 1];

			var jointMin = data[(/*LINE_JOINTMIN*/ 5)];
			var jointMax = data[(/*LINE_JOINTMAX*/ 6)];
			if (jointMin === Number.NEGATIVE_INFINITY) {
				jointMin = -1e20;
			}
			if (jointMax === Number.POSITIVE_INFINITY) {
				jointMax = 1e20;
			}

			var delX = (x2 - x1);
			var delY = (y2 - y1);
			var pn = (delX * dx) + (delY * dy);

			var ex1 = (x1 + (dx * jointMin));
			var ey1 = (y1 + (dy * jointMin));
			var ex2 = (x1 + (dx * jointMax));
			var ey2 = (y1 + (dy * jointMax));

			var t;
			if (pn > jointMin) {
				t = Math.min(pn, jointMax);
				debug.drawLine(ex1, ey1, x1 + (dx * t), y1 + (dy * t), colSA);
			}
			if (pn < jointMax) {
				t = Math.max(pn, jointMin);
				debug.drawLine(ex2, ey2, x1 + (dx * t), y1 + (dy * t), colSB);
			}

			if (!this._stiff) {
				var anchX = (pn < jointMin ? ex1 : (pn > jointMax ? ex2 : (x1 + (dx * pn))));
				var anchY = (pn < jointMin ? ey1 : (pn > jointMax ? ey2 : (y1 + (dy * pn))));

				var numCoils = debug.constraintSpringNumCoils;
				var radius = (debug.constraintSpringRadius * debug.screenToPhysics2D);
				debug.drawLinearSpring(anchX, anchY, x2, y2, numCoils, radius, colSC);
			}

			var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
			debug._drawAnchor(x1, y1, rad, colA);
			debug._drawAnchor(x2, y2, rad, colB);
		};

		return Physics2DLineConstraint;
})

// =========================================================================
//
// Point Constraint
//
// POINT DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POINT_LANCHOR1*/5  // Locally defined anchor on first body.
///*POINT_LANCHOR2*/7  // Locally defined anchor on second body.
///*POINT_RANCHOR1*/9  // Relatively defined anchor on first body.
///*POINT_RANCHOR2*/11 // Relatively defined anchor on second body.
///*POINT_KMASS*/13    // Effective mass matrix [ a b ; b c] symmetric.
///*POINT_JACC*/16     // Accumulated impulses (x, y).
///*POINT_JMAX*/18     // Maximimum impulse magnitude (maxForce derived).
///*POINT_GAMMA*/19    // Gamma for soft constraint.
///*POINT_BIAS*/20     // Bias for soft constraint (x, y) (maxError derived).
//
///*POINT_DATA_SIZE*/22
define(
	'spell/physics/2D/PointConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
		) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DPointConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
			this.type = "POINT";
			this.dimension = 2;
			// ===============================================
			// Inherited
			this._ANCHOR_A = (/*POINT_LANCHOR1*/ 5);
			this._ANCHOR_B = (/*POINT_LANCHOR2*/ 7);
			// =========================================================
			// Inherited
			this._JACC = (/*POINT_JACC*/ 16);
		}

		__extends(Physics2DPointConstraint, Physics2DConstraint);


		Physics2DPointConstraint.prototype._preStep = function (deltaTime) {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*POINT_LANCHOR1*/ 5), (/*POINT_RANCHOR1*/ 9));
			var rx1 = data[(/*POINT_RANCHOR1*/ 9)];
			var ry1 = data[(/*POINT_RANCHOR1*/ 9) + 1];

			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*POINT_LANCHOR2*/ 7), (/*POINT_RANCHOR2*/ 11));
			var rx2 = data[(/*POINT_RANCHOR2*/ 11)];
			var ry2 = data[(/*POINT_RANCHOR2*/ 11) + 1];

			// Compute non-inverted effective mass.
			var massSum = (b1[(/*BODY_IMASS*/ 0)] + b2[(/*BODY_IMASS*/ 0)]);
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];
			data[(/*POINT_KMASS*/ 13)] = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
			data[(/*POINT_KMASS*/ 13) + 1] = -(rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
			data[(/*POINT_KMASS*/ 13) + 2] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);

			// Invert effective mass
			Physics2DConstraint.prototype.safe_invert2(data, (/*POINT_KMASS*/ 13), (/*POINT_JACC*/ 16));

			if (!this._stiff) {
				data[(/*POINT_BIAS*/ 20)] = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
				data[(/*POINT_BIAS*/ 20) + 1] = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
				if (Physics2DConstraint.prototype.soft_params2(data, (/*POINT_KMASS*/ 13), (/*POINT_GAMMA*/ 19), (/*POINT_BIAS*/ 20), deltaTime, this._breakUnderError)) {
					return true;
				}
			} else {
				data[(/*POINT_GAMMA*/ 19)] = 0.0;
				data[(/*POINT_BIAS*/ 20)] = 0.0;
				data[(/*POINT_BIAS*/ 20) + 1] = 0.0;
			}

			var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
			data[(/*POINT_JACC*/ 16)] *= dtRatio;
			data[(/*POINT_JACC*/ 16) + 1] *= dtRatio;
			data[(/*POINT_JMAX*/ 18)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

			return false;
		};

		Physics2DPointConstraint.prototype._warmStart = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var jx = data[(/*POINT_JACC*/ 16)];
			var jy = data[(/*POINT_JACC*/ 16) + 1];

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (((data[(/*POINT_RANCHOR1*/ 9)] * jy) - (data[(/*POINT_RANCHOR1*/ 9) + 1] * jx)) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((data[(/*POINT_RANCHOR2*/ 11)] * jy) - (data[(/*POINT_RANCHOR2*/ 11) + 1] * jx)) * b2[(/*BODY_IINERTIA*/ 1)]);
		};

		Physics2DPointConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var data = this._data;

			var jx = data[(/*POINT_JACC*/ 16)];
			var jy = data[(/*POINT_JACC*/ 16) + 1];

			if (body === this.bodyA) {
				dst[0] = -jx;
				dst[1] = -jy;
				dst[2] = -((data[(/*WELD_RANCHOR1*/ 9)] * jy) - (data[(/*WELD_RANCHOR1*/ 9) + 1] * jx));
			} else if (body === this.bodyB) {
				dst[0] = jx;
				dst[1] = jy;
				dst[2] = ((data[(/*WELD_RANCHOR2*/ 11)] * jy) - (data[(/*WELD_RANCHOR2*/ 11) + 1] * jx));
			} else {
				dst[0] = dst[1] = dst[2] = 0;
			}

			return dst;
		};

		Physics2DPointConstraint.prototype._iterateVel = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var rx1 = data[(/*POINT_RANCHOR1*/ 9)];
			var ry1 = data[(/*POINT_RANCHOR1*/ 9) + 1];
			var rx2 = data[(/*POINT_RANCHOR2*/ 11)];
			var ry2 = data[(/*POINT_RANCHOR2*/ 11) + 1];

			// (x, y) = Bias - VelocityError
			var vw1 = b1[(/*BODY_VEL*/ 7) + 2];
			var vw2 = b2[(/*BODY_VEL*/ 7) + 2];
			var x = (data[(/*POINT_BIAS*/ 20)] - (b2[(/*BODY_VEL*/ 7)] - (ry2 * vw2)) + (b1[(/*BODY_VEL*/ 7)] - (ry1 * vw1)));
			var y = (data[(/*POINT_BIAS*/ 20) + 1] - (b2[(/*BODY_VEL*/ 7) + 1] + (rx2 * vw2)) + (b1[(/*BODY_VEL*/ 7) + 1] + (rx1 * vw1)));

			var jOldX = data[(/*POINT_JACC*/ 16)];
			var jOldY = data[(/*POINT_JACC*/ 16) + 1];
			var Kb = data[(/*POINT_KMASS*/ 13) + 1];
			var gamma = data[(/*POINT_GAMMA*/ 19)];

			// Impulse.
			// (jx, jy) = K * (x, y) - (JAcc * gamma);
			var jx = ((data[(/*POINT_KMASS*/ 13)] * x) + (Kb * y)) - (jOldX * gamma);
			var jy = ((Kb * x) + (data[(/*POINT_KMASS*/ 13) + 2] * y)) - (jOldY * gamma);

			// Accumulate and clamp.
			var jAccX = (jOldX + jx);
			var jAccY = (jOldY + jy);
			var jsq = ((jAccX * jAccX) + (jAccY * jAccY));
			var jMax = data[(/*POINT_JMAX*/ 18)];
			if (this._breakUnderForce) {
				if (jsq > (jMax * jMax)) {
					return true;
				}
			} else if (!this._stiff) {
				if (jsq > (jMax * jMax)) {
					jsq = (jMax / Math.sqrt(jsq));
					jAccX *= jsq;
					jAccY *= jsq;
				}
			}

			jx = (jAccX - jOldX);
			jy = (jAccY - jOldY);
			data[(/*POINT_JACC*/ 16)] = jAccX;
			data[(/*POINT_JACC*/ 16) + 1] = jAccY;

			// Apply impulse
			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (((rx1 * jy) - (ry1 * jx)) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((rx2 * jy) - (ry2 * jx)) * b2[(/*BODY_IINERTIA*/ 1)]);

			return false;
		};

		Physics2DPointConstraint.prototype._iteratePos = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var im1 = b1[(/*BODY_IMASS*/ 0)];
			var im2 = b2[(/*BODY_IMASS*/ 0)];
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*POINT_LANCHOR1*/ 5), (/*POINT_RANCHOR1*/ 9));
			var rx1 = data[(/*POINT_RANCHOR1*/ 9)];
			var ry1 = data[(/*POINT_RANCHOR1*/ 9) + 1];

			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*POINT_LANCHOR2*/ 7), (/*POINT_RANCHOR2*/ 11));
			var rx2 = data[(/*POINT_RANCHOR2*/ 11)];
			var ry2 = data[(/*POINT_RANCHOR2*/ 11) + 1];

			// Positional error
			var errX = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
			var errY = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
			var elsq = ((errX * errX) + (errY * errY));
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (this._breakUnderError && (elsq > (maxError * maxError))) {
				return true;
			}

			if (elsq < Physics2DConfig.POINT_SLOP_SQ) {
				return false;
			}

			var scale = Physics2DConfig.POINT_BIAS_COEF;
			errX *= scale;
			errY *= scale;
			elsq *= (scale * scale);

			var massSum = (im1 + im2);
			var jx, jy;

			// Handle large seperation  for stability
			if (elsq > Physics2DConfig.POINT_LARGE_ERROR_SQ) {
				if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
					// We resolve error assuming infinite inertia (ignore rotation).
					var K = (Physics2DConfig.POINT_LARGE_ERROR_BIAS / massSum);
					jx = (errX * K);
					jy = (errY * K);

					// Clamp
					var jsq = ((jx * jx) + (jy * jy));
					var maxJ = Physics2DConfig.POINT_LARGE_ERROR_MAX;
					if (jsq > (maxJ * maxJ)) {
						jsq = (maxJ / Math.sqrt(jsq));
						jx *= jsq;
						jy *= jsq;
					}

					// Apply impulse
					b1[(/*BODY_POS*/ 2)] -= (jx * im1);
					b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
					b2[(/*BODY_POS*/ 2)] += (jx * im1);
					b2[(/*BODY_POS*/ 2) + 1] += (jy * im1);

					// Recompute error.
					errX = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
					errY = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
					errX *= scale;
					errY *= scale;
					elsq = ((errX * errX) + (errY * errY));
				}
			}

			// Compute non-inverted effective mass.
			data[(/*POINT_KMASS*/ 13)] = (massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2));
			data[(/*POINT_KMASS*/ 13) + 1] = (-(rx1 * ii1 * ry1) - (rx2 * ii2 * ry2));
			data[(/*POINT_KMASS*/ 13) + 2] = (massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2));

			if (elsq > Physics2DConfig.POINT_MAX_ERROR_SQ) {
				elsq = (Physics2DConfig.POINT_MAX_ERROR / Math.sqrt(elsq));
				errX *= elsq;
				errY *= elsq;
			}

			data[(/*POINT_BIAS*/ 20)] = errX;
			data[(/*POINT_BIAS*/ 20) + 1] = errY;
			Physics2DConstraint.prototype.safe_solve2(data, (/*POINT_KMASS*/ 13), (/*POINT_BIAS*/ 20), (/*POINT_BIAS*/ 20));
			jx = data[(/*POINT_BIAS*/ 20)];
			jy = data[(/*POINT_BIAS*/ 20) + 1];

			// Apply impulse
			b1[(/*BODY_POS*/ 2)] -= (jx * im1);
			b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
			var dW = -(((rx1 * jy) - (ry1 * jx)) * ii1);
			if (dW !== 0) {
				this.bodyA._deltaRotation(dW);
			}

			b2[(/*BODY_POS*/ 2)] += (jx * im2);
			b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);
			dW = (((rx2 * jy) - (ry2 * jx)) * ii2);
			if (dW !== 0) {
				this.bodyB._deltaRotation(dW);
			}

			return false;
		};

		// params = {
		//   bodyA, bodyB,
		//   anchorA, anchorB,
		//   ... common constraint params
		// }
		Physics2DPointConstraint.create = function (params) {
			var p = new Physics2DPointConstraint();
			var data = p._data = Types.createFloatArray((/*POINT_DATA_SIZE*/ 22));
			Physics2DConstraint.prototype.init(p, params);

			var anchor = params.anchorA;
			data[(/*POINT_LANCHOR1*/ 5)] = (anchor ? anchor[0] : 0);
			data[(/*POINT_LANCHOR1*/ 5) + 1] = (anchor ? anchor[1] : 0);

			anchor = params.anchorB;
			data[(/*POINT_LANCHOR2*/ 7)] = (anchor ? anchor[0] : 0);
			data[(/*POINT_LANCHOR2*/ 7) + 1] = (anchor ? anchor[1] : 0);

			p.bodyA = params.bodyA;
			p.bodyB = params.bodyB;

			return p;
		};

		// Inherited
		Physics2DPointConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
		Physics2DPointConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
		Physics2DPointConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
		Physics2DPointConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
		Physics2DPointConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;


		Physics2DPointConstraint.prototype._draw = function pointDrawFn(debug) {
			var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
			var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
			var colE = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var x1 = (b1[(/*BODY_POS*/ 2)] + data[(/*POINT_RANCHOR1*/ 9)]);
			var y1 = (b1[(/*BODY_POS*/ 2) + 1] + data[(/*POINT_RANCHOR1*/ 9) + 1]);
			var x2 = (b2[(/*BODY_POS*/ 2)] + data[(/*POINT_RANCHOR2*/ 11)]);
			var y2 = (b2[(/*BODY_POS*/ 2) + 1] + data[(/*POINT_RANCHOR2*/ 11) + 1]);

			var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
			debug._drawAnchor(x1, y1, rad, colA);
			debug._drawAnchor(x2, y2, rad, colB);

			if (this._stiff) {
				debug.drawLine(x1, y1, x2, y2, colE);
			} else {
				var numCoils = debug.constraintSpringNumCoils;
				var radius = (debug.constraintSpringRadius * debug.screenToPhysics2D);
				debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE);
			}
		};
		return Physics2DPointConstraint;
})


// =========================================================================
//
// Weld Constraint
//
// WELD DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*WELD_LANCHOR1*/5  // Locally defined anchor on first body.
///*WELD_LANCHOR2*/7  // Locally defined anchor on second body.
///*WELD_RANCHOR1*/9  // Relatively defined anchor on first body.
///*WELD_RANCHOR2*/11 // Relatively defined anchor on second body.
///*WELD_PHASE*/13    // Rotational phase between bodies
///*WELD_KMASS*/14    // Effective mass matrix [ a b c ; b d e ; c e f ] symmetric.
///*WELD_JACC*/20     // Accumulated impulse (x, y, w).
///*WELD_JMAX*/23     // Maximum impulse magnitude (maxForce derived).
///*WELD_GAMMA*/24    // Gamma for soft constraint
///*WELD_BIAS*/25     // Bias for soft constraint (x, y, w) (maxError derived).
//
///*WELD_DATA_SIZE*/28
define(
	'spell/physics/2D/WeldConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
		) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

	var Physics2DWeldConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
			this.type = "WELD";
			this.dimension = 3;
			// ===============================================
			// Inherited
			this._ANCHOR_A = (/*WELD_LANCHOR1*/ 5);
			this._ANCHOR_B = (/*WELD_LANCHOR2*/ 7);
			// =======================================================
			// Inherited
			this._JACC = (/*WELD_JACC*/ 20);
		}
		__extends(Physics2DWeldConstraint, Physics2DConstraint);


		Physics2DWeldConstraint.prototype.getPhase = function () {
			return this._data[(/*WELD_PHASE*/ 13)];
		};
		Physics2DWeldConstraint.prototype.setPhase = function (phase) {
			var data = this._data;
			if (phase !== data[(/*WELD_PHASE*/ 13)]) {
				data[(/*WELD_PHASE*/ 13)] = phase;
				this.wake(true);
			}
		};

		Physics2DWeldConstraint.prototype._preStep = function (deltaTime) {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*WELD_LANCHOR1*/ 5), (/*WELD_RANCHOR1*/ 9));
			var rx1 = data[(/*WELD_RANCHOR1*/ 9)];
			var ry1 = data[(/*WELD_RANCHOR1*/ 9) + 1];

			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*WELD_LANCHOR2*/ 7), (/*WELD_RANCHOR2*/ 11));
			var rx2 = data[(/*WELD_RANCHOR2*/ 11)];
			var ry2 = data[(/*WELD_RANCHOR2*/ 11) + 1];

			// Compute non-inverted effective mass.
			var massSum = (b1[(/*BODY_IMASS*/ 0)] + b2[(/*BODY_IMASS*/ 0)]);
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];
			data[(/*WELD_KMASS*/ 14)] = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
			data[(/*WELD_KMASS*/ 14) + 1] = -(rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
			data[(/*WELD_KMASS*/ 14) + 2] = -(ry1 * ii1) - (ry2 * ii2);
			data[(/*WELD_KMASS*/ 14) + 3] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);
			data[(/*WELD_KMASS*/ 14) + 4] = (rx1 * ii1) + (rx2 * ii2);
			data[(/*WELD_KMASS*/ 14) + 5] = ii1 + ii2;

			// Invert effective mass
			Physics2DConstraint.prototype.safe_invert3(data, (/*WELD_KMASS*/ 14), (/*WELD_JACC*/ 20));

			if (!this._stiff) {
				data[(/*WELD_BIAS*/ 25)] = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
				data[(/*WELD_BIAS*/ 25) + 1] = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
				data[(/*WELD_BIAS*/ 25) + 2] = ((b1[(/*BODY_POS*/ 2) + 2] + data[(/*WELD_PHASE*/ 13)]) - b2[(/*BODY_POS*/ 2) + 2]);
				if (Physics2DConstraint.prototype.soft_params3(data, (/*WELD_KMASS*/ 14), (/*WELD_GAMMA*/ 24), (/*WELD_BIAS*/ 25), deltaTime, this._breakUnderError)) {
					return true;
				}
			} else {
				data[(/*WELD_GAMMA*/ 24)] = 0.0;
				data[(/*WELD_BIAS*/ 25)] = 0.0;
				data[(/*WELD_BIAS*/ 25) + 1] = 0.0;
				data[(/*WELD_BIAS*/ 25) + 2] = 0.0;
			}

			var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
			data[(/*WELD_JACC*/ 20)] *= dtRatio;
			data[(/*WELD_JACC*/ 20) + 1] *= dtRatio;
			data[(/*WELD_JACC*/ 20) + 2] *= dtRatio;
			data[(/*WELD_JMAX*/ 23)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

			return false;
		};

		Physics2DWeldConstraint.prototype._warmStart = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var jx = data[(/*WELD_JACC*/ 20)];
			var jy = data[(/*WELD_JACC*/ 20) + 1];
			var jz = data[(/*WELD_JACC*/ 20) + 2];

			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (((data[(/*WELD_RANCHOR1*/ 9)] * jy) - (data[(/*WELD_RANCHOR1*/ 9) + 1] * jx) + jz) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((data[(/*WELD_RANCHOR2*/ 11)] * jy) - (data[(/*WELD_RANCHOR2*/ 11) + 1] * jx) + jz) * b2[(/*BODY_IINERTIA*/ 1)]);
		};

		Physics2DWeldConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var data = this._data;
			var jx = data[(/*WELD_JACC*/ 20)];
			var jy = data[(/*WELD_JACC*/ 20) + 1];
			var jz = data[(/*WELD_JACC*/ 20) + 2];

			if (body === this.bodyA) {
				dst[0] = -jx;
				dst[1] = -jy;
				dst[2] = -((data[(/*WELD_RANCHOR1*/ 9)] * jy) - (data[(/*WELD_RANCHOR1*/ 9) + 1] * jx) + jz);
			} else if (body === this.bodyB) {
				dst[0] = jx;
				dst[1] = jy;
				dst[2] = ((data[(/*WELD_RANCHOR2*/ 11)] * jy) - (data[(/*WELD_RANCHOR2*/ 11) + 1] * jx) + jz);
			} else {
				dst[0] = dst[1] = dst[2] = 0;
			}

			return dst;
		};

		Physics2DWeldConstraint.prototype._iterateVel = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var rx1 = data[(/*WELD_RANCHOR1*/ 9)];
			var ry1 = data[(/*WELD_RANCHOR1*/ 9) + 1];
			var rx2 = data[(/*WELD_RANCHOR2*/ 11)];
			var ry2 = data[(/*WELD_RANCHOR2*/ 11) + 1];

			// (x, y, z) = Bias - VelocityError
			var vw1 = b1[(/*BODY_VEL*/ 7) + 2];
			var vw2 = b2[(/*BODY_VEL*/ 7) + 2];
			var x = (data[(/*WELD_BIAS*/ 25)] - (b2[(/*BODY_VEL*/ 7)] - (ry2 * vw2)) + (b1[(/*BODY_VEL*/ 7)] - (ry1 * vw1)));
			var y = (data[(/*WELD_BIAS*/ 25) + 1] - (b2[(/*BODY_VEL*/ 7) + 1] + (rx2 * vw2)) + (b1[(/*BODY_VEL*/ 7) + 1] + (rx1 * vw1)));
			var z = (data[(/*WELD_BIAS*/ 25) + 2] - vw2 + vw1);

			var jOldX = data[(/*WELD_JACC*/ 20)];
			var jOldY = data[(/*WELD_JACC*/ 20) + 1];
			var jOldZ = data[(/*WELD_JACC*/ 20) + 2];
			var gamma = data[(/*WELD_GAMMA*/ 24)];

			// Impulse.
			// (jx, jy, jz) = K * (x, y, z) - (JAcc * gamma);
			var Kb = data[(/*WELD_KMASS*/ 14) + 1];
			var Kc = data[(/*WELD_KMASS*/ 14) + 2];
			var Ke = data[(/*WELD_KMASS*/ 14) + 4];
			var jx = ((data[(/*WELD_KMASS*/ 14)] * x) + (Kb * y) + (Kc * z)) - (jOldX * gamma);
			var jy = ((Kb * x) + (data[(/*WELD_KMASS*/ 14) + 3] * y) + (Ke * z)) - (jOldY * gamma);
			var jz = ((Kc * x) + (Ke * y) + (data[(/*WELD_KMASS*/ 14) + 5] * z)) - (jOldZ * gamma);

			// Accumulate and clamp.
			var jAccX = (jOldX + jx);
			var jAccY = (jOldY + jy);
			var jAccZ = (jOldZ + jz);
			var jsq = ((jAccX * jAccX) + (jAccY * jAccY) + (jAccZ * jAccZ));
			var jMax = data[(/*WELD_JMAX*/ 23)];
			if (this._breakUnderForce) {
				if (jsq > (jMax * jMax)) {
					return true;
				}
			} else if (!this._stiff) {
				if (jsq > (jMax * jMax)) {
					jsq = (jMax / Math.sqrt(jsq));
					jAccX *= jsq;
					jAccY *= jsq;
					jAccZ *= jsq;
				}
			}

			jx = (jAccX - jOldX);
			jy = (jAccY - jOldY);
			jz = (jAccZ - jOldZ);
			data[(/*WELD_JACC*/ 20)] = jAccX;
			data[(/*WELD_JACC*/ 20) + 1] = jAccY;
			data[(/*WELD_JACC*/ 20) + 2] = jAccZ;

			// Apply impulse
			var im = b1[(/*BODY_IMASS*/ 0)];
			b1[(/*BODY_VEL*/ 7)] -= (jx * im);
			b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
			b1[(/*BODY_VEL*/ 7) + 2] -= (((rx1 * jy) - (ry1 * jx) + jz) * b1[(/*BODY_IINERTIA*/ 1)]);

			im = b2[(/*BODY_IMASS*/ 0)];
			b2[(/*BODY_VEL*/ 7)] += (jx * im);
			b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
			b2[(/*BODY_VEL*/ 7) + 2] += (((rx2 * jy) - (ry2 * jx) + jz) * b2[(/*BODY_IINERTIA*/ 1)]);

			return false;
		};

		Physics2DWeldConstraint.prototype._iteratePos = function () {
			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var im1 = b1[(/*BODY_IMASS*/ 0)];
			var im2 = b2[(/*BODY_IMASS*/ 0)];
			var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = b2[(/*BODY_IINERTIA*/ 1)];

			Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*WELD_LANCHOR1*/ 5), (/*WELD_RANCHOR1*/ 9));
			var rx1 = data[(/*WELD_RANCHOR1*/ 9)];
			var ry1 = data[(/*WELD_RANCHOR1*/ 9) + 1];

			Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*WELD_LANCHOR2*/ 7), (/*WELD_RANCHOR2*/ 11));
			var rx2 = data[(/*WELD_RANCHOR2*/ 11)];
			var ry2 = data[(/*WELD_RANCHOR2*/ 11) + 1];

			// Positional error
			var errX = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
			var errY = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
			var errZ = ((b1[(/*BODY_POS*/ 2) + 2] + data[(/*WELD_PHASE*/ 13)]) - b2[(/*BODY_POS*/ 2) + 2]);

			var elsq = ((errX * errX) + (errY * errY));
			var wlsq = (errZ * errZ);
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (this._breakUnderError && (elsq + wlsq > (maxError * maxError))) {
				return true;
			}

			if (elsq < Physics2DConfig.WELD_LINEAR_SLOP_SQ && wlsq < Physics2DConfig.WELD_ANGULAR_SLOP_SQ) {
				return false;
			}

			var scale = Physics2DConfig.WELD_BIAS_COEF;
			errX *= scale;
			errY *= scale;
			errZ *= scale;
			elsq *= (scale * scale);

			var massSum = (im1 + im2);
			var jx, jy;

			// Handle large error seperately.
			if (elsq > Physics2DConfig.WELD_LARGE_ERROR_SQ) {
				if (massSum > Physics2DConfig.EFF_MASS_EPSILON) {
					var K = (Physics2DConfig.WELD_BIAS_COEF / massSum);
					jx = (errX * K);
					jy = (errY * K);

					// Clamp
					var jsq = ((jx * jx) + (jy * jy));
					var maxJ = Physics2DConfig.WELD_LARGE_ERROR_MAX;
					if (jsq > (maxJ * maxJ)) {
						jsq = (maxJ / Math.sqrt(jsq));
						jx *= jsq;
						jy *= jsq;
					}

					// Apply impulse
					b1[(/*BODY_POS*/ 2)] -= (jx * im1);
					b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
					b2[(/*BODY_POS*/ 2)] += (jx * im1);
					b2[(/*BODY_POS*/ 2) + 1] += (jy * im1);

					// Recompute error.
					errX = ((b1[(/*BODY_POS*/ 2)] + rx1) - (b2[(/*BODY_POS*/ 2)] + rx2));
					errY = ((b1[(/*BODY_POS*/ 2) + 1] + ry1) - (b2[(/*BODY_POS*/ 2) + 1] + ry2));
					errX *= scale;
					errY *= scale;
					elsq = ((errX * errX) + (errY * errY));
				}
			}

			// Compute non-inverted effective mass.
			data[(/*WELD_KMASS*/ 14)] = massSum + (ry1 * ii1 * ry1) + (ry2 * ii2 * ry2);
			data[(/*WELD_KMASS*/ 14) + 1] = -(rx1 * ii1 * ry1) - (rx2 * ii2 * ry2);
			data[(/*WELD_KMASS*/ 14) + 2] = -(ry1 * ii1) - (ry2 * ii2);
			data[(/*WELD_KMASS*/ 14) + 3] = massSum + (rx1 * ii1 * rx1) + (rx2 * ii2 * rx2);
			data[(/*WELD_KMASS*/ 14) + 4] = (rx1 * ii1) + (rx2 * ii2);
			data[(/*WELD_KMASS*/ 14) + 5] = ii1 + ii2;

			if (elsq > Physics2DConfig.WELD_MAX_LINEAR_ERROR_SQ) {
				elsq = (Physics2DConfig.WELD_MAX_LINEAR_ERROR / Math.sqrt(elsq));
				errX *= elsq;
				errY *= elsq;
			}

			var maxW = Physics2DConfig.WELD_MAX_ANGULAR_ERROR;
			if (errZ > maxW) {
				errZ = maxW;
			} else if (errZ < -maxW) {
				errZ = -maxW;
			}

			data[(/*WELD_BIAS*/ 25)] = errX;
			data[(/*WELD_BIAS*/ 25) + 1] = errY;
			data[(/*WELD_BIAS*/ 25) + 2] = errZ;
			Physics2DConstraint.prototype.safe_solve3(data, (/*WELD_KMASS*/ 14), (/*WELD_BIAS*/ 25), (/*WELD_BIAS*/ 25));
			jx = data[(/*WELD_BIAS*/ 25)];
			jy = data[(/*WELD_BIAS*/ 25) + 1];
			var jz = data[(/*WELD_BIAS*/ 25) + 2];

			// Apply impulse
			b1[(/*BODY_POS*/ 2)] -= (jx * im1);
			b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
			var dW = -(((rx1 * jy) - (ry1 * jx) + jz) * ii1);
			if (dW !== 0) {
				this.bodyA._deltaRotation(dW);
			}

			b2[(/*BODY_POS*/ 2)] += (jx * im2);
			b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);
			dW = (((rx2 * jy) - (ry2 * jx) + jz) * ii2);
			if (dW !== 0) {
				this.bodyB._deltaRotation(dW);
			}

			return false;
		};

		// params = {
		//   bodyA, bodyB,
		//   anchorA, anchorB,
		//   phase
		//   ... common constraint params
		// }
		Physics2DWeldConstraint.create = function (params) {
			var p = new Physics2DWeldConstraint();
			var data = p._data = Types.createFloatArray((/*WELD_DATA_SIZE*/ 28));
			Physics2DConstraint.prototype.init(p, params);

			var anchor = params.anchorA;
			data[(/*WELD_LANCHOR1*/ 5)] = (anchor ? anchor[0] : 0);
			data[(/*WELD_LANCHOR1*/ 5) + 1] = (anchor ? anchor[1] : 0);

			anchor = params.anchorB;
			data[(/*WELD_LANCHOR2*/ 7)] = (anchor ? anchor[0] : 0);
			data[(/*WELD_LANCHOR2*/ 7) + 1] = (anchor ? anchor[1] : 0);

			data[(/*WELD_PHASE*/ 13)] = (params.phase !== undefined ? params.phase : 0);

			p.bodyA = params.bodyA;
			p.bodyB = params.bodyB;

			return p;
		};

		// Inherited
		Physics2DWeldConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
		Physics2DWeldConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
		Physics2DWeldConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
		Physics2DWeldConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
		Physics2DWeldConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;

		Physics2DWeldConstraint.prototype._draw = function weldDrawFn(debug) {
			var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
			var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
			var colE = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);

			var data = this._data;
			var b1 = this.bodyA._data;
			var b2 = this.bodyB._data;

			var x1 = (b1[(/*BODY_POS*/ 2)] + data[(/*WELD_RANCHOR1*/ 9)]);
			var y1 = (b1[(/*BODY_POS*/ 2) + 1] + data[(/*WELD_RANCHOR1*/ 9) + 1]);
			var x2 = (b2[(/*BODY_POS*/ 2)] + data[(/*WELD_RANCHOR2*/ 11)]);
			var y2 = (b2[(/*BODY_POS*/ 2) + 1] + data[(/*WELD_RANCHOR2*/ 11) + 1]);

			var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
			debug._drawAnchor(x1, y1, rad, colA);
			debug._drawAnchor(x2, y2, rad, colB);

			if (this._stiff) {
				debug.drawLine(x1, y1, x2, y2, colE);
			} else {
				var numCoils = debug.constraintSpringNumCoils;
				var radius = (debug.constraintSpringRadius * debug.screenToPhysics2D);
				debug.drawLinearSpring(x1, y1, x2, y2, numCoils, radius, colE);

				var minRadius = (debug.constraintSpiralMinRadius * debug.screenToPhysics2D);
				var deltaRadius = (debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D);
				var indicatorSize = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
				numCoils = debug.constraintSpiralNumCoils;

				var target, min;

				// angle indication on bodyA
				min = b1[(/*BODY_POS*/ 2) + 2];
				target = (b2[(/*BODY_POS*/ 2) + 2] - data[(/*WELD_PHASE*/ 13)]);

				var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
				var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

				debug.drawSpiralSpring(b1[(/*BODY_POS*/ 2)], b1[(/*BODY_POS*/ 2) + 1], min, target, minRadius, minRadius + ((target - min) * deltaRadius), numCoils, colSB);
				debug._drawAngleIndicator(b1[(/*BODY_POS*/ 2)], b1[(/*BODY_POS*/ 2) + 1], min, minRadius, indicatorSize, colSA);

				min = b2[(/*BODY_POS*/ 2) + 2];
				target = (data[(/*WELD_PHASE*/ 13)] + b1[(/*BODY_POS*/ 2) + 2]);

				debug.drawSpiralSpring(b2[(/*BODY_POS*/ 2)], b2[(/*BODY_POS*/ 2) + 1], min, target, minRadius, minRadius + ((target - min) * deltaRadius), numCoils, colSA);
				debug._drawAngleIndicator(b2[(/*BODY_POS*/ 2)], b2[(/*BODY_POS*/ 2) + 1], min, minRadius, indicatorSize, colSB);
			}
		};

		return Physics2DWeldConstraint;
})

// =========================================================================
//
// Motor Constraint
//
// MOTOR DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*MOTOR_RATE*/5   // Motor rate
///*MOTOR_RATIO*/6  // Motor ratio
///*MOTOR_KMASS*/7  // Effective mass (scalar)
///*MOTOR_JACC*/8   // Accumulated impulse (scalar)
///*MOTOR_JMAX*/9   // Maximum impulse (maxForce derived)
//
///*MOTOR_DATA_SIZE*/10
define(
	'spell/physics/2D/MotorConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
		Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DMotorConstraint = function() {
			Physics2DConstraint.apply(this, arguments);
				this.type = "MOTOR";
				this.dimension = 1;
				// ==========================================================
				// Inherited
				this._JACC = (/*MOTOR_JACC*/ 8);
			}
			__extends(Physics2DMotorConstraint, Physics2DConstraint);

			// // Inherited
			// wake  = Physics2DConstraint.prototype.wake;
			// sleep = Physics2DConstraint.prototype.sleep;
			// configure  = Physics2DConstraint.prototype.configure;
			// isEnabled  = Physics2DConstraint.prototype.isEnabled;
			// isDisabled = Physics2DConstraint.prototype.isDisabled;
			// enable     = Physics2DConstraint.prototype.enable;
			// disable    = Physics2DConstraint.prototype.disable;
			// addEventListener    = Physics2DConstraint.prototype.addEventListener;
			// removeEventListener = Physics2DConstraint.prototype.removeEventListener;
			// ===============================================
			Physics2DMotorConstraint.prototype.getRate = function () {
				return this._data[(/*MOTOR_RATE*/ 5)];
			};
			Physics2DMotorConstraint.prototype.getRatio = function () {
				return this._data[(/*MOTOR_RATIO*/ 6)];
			};

			Physics2DMotorConstraint.prototype.setRate = function (rate) {
				var data = this._data;
				if (data[(/*MOTOR_RATE*/ 5)] !== rate) {
					data[(/*MOTOR_RATE*/ 5)] = rate;
					this.wake(true);
				}
			};
			Physics2DMotorConstraint.prototype.setRatio = function (ratio) {
				var data = this._data;
				if (data[(/*MOTOR_RATIO*/ 6)] !== ratio) {
					data[(/*MOTOR_RATIO*/ 6)] = ratio;
					this.wake(true);
				}
			};

			Physics2DMotorConstraint.prototype._preStep = function (deltaTime) {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				// Compute non-inverted effective mass
				var ratio = data[(/*MOTOR_RATIO*/ 6)];
				data[(/*MOTOR_KMASS*/ 7)] = (b1[(/*BODY_IINERTIA*/ 1)] + (ratio * ratio * b2[(/*BODY_IINERTIA*/ 1)]));

				// Invert eff-mass matrix
				Physics2DConstraint.prototype.safe_invert(data, (/*MOTOR_KMASS*/ 7), (/*MOTOR_JACC*/ 8));

				var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
				data[(/*MOTOR_JACC*/ 8)] *= dtRatio;
				data[(/*MOTOR_JMAX*/ 9)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

				return false;
			};

			Physics2DMotorConstraint.prototype._warmStart = function () {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				var j = data[(/*MOTOR_JACC*/ 8)];
				b1[(/*BODY_VEL*/ 7) + 2] -= (j * b1[(/*BODY_IINERTIA*/ 1)]);
				b2[(/*BODY_VEL*/ 7) + 2] += (data[(/*MOTOR_RATIO*/ 6)] * j * b2[(/*BODY_IINERTIA*/ 1)]);
			};

			Physics2DMotorConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(3);
				}

				var data = this._data;

				dst[0] = dst[1] = 0;
				dst[2] = (body === this.bodyA ? -1 : (body === this.bodyB ? data[(/*MOTOR_RATIO*/ 6)] : 0)) * data[(/*MOTOR_JACC*/ 8)];
				return dst;
			};

			Physics2DMotorConstraint.prototype._iterateVel = function () {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				var ratio = data[(/*MOTOR_RATIO*/ 6)];
				var j = (data[(/*MOTOR_KMASS*/ 7)] * (data[(/*MOTOR_RATE*/ 5)] + b1[(/*BODY_VEL*/ 7) + 2] - (ratio * b2[(/*BODY_VEL*/ 7) + 2])));
				var jOld = data[(/*MOTOR_JACC*/ 8)];
				var jAcc = (jOld + j);
				var jMax = data[(/*MOTOR_JMAX*/ 9)];
				if (this._breakUnderForce && (jAcc > jMax || jAcc < -jMax)) {
					return true;
				} else {
					if (jAcc > jMax) {
						jAcc = jMax;
					} else if (jAcc < -jMax) {
						jAcc = -jMax;
					}
				}

				j = (jAcc - jOld);
				data[(/*MOTOR_JACC*/ 8)] = jAcc;

				b1[(/*BODY_VEL*/ 7) + 2] -= (j * b1[(/*BODY_IINERTIA*/ 1)]);
				b2[(/*BODY_VEL*/ 7) + 2] += (ratio * j * b2[(/*BODY_IINERTIA*/ 1)]);

				return false;
			};

			// Velocity only constraint.
			Physics2DMotorConstraint.prototype._iteratePos = function () {
				return false;
			};

			Physics2DMotorConstraint.create = function (params) {
				var p = new Physics2DMotorConstraint();
				var data = p._data = Types.createFloatArray((/*MOTOR_DATA_SIZE*/ 10));
				Physics2DConstraint.prototype.init(p, params);

				data[(/*MOTOR_RATE*/ 5)] = (params.rate !== undefined ? params.rate : 0);
				data[(/*MOTOR_RATIO*/ 6)] = (params.ratio !== undefined ? params.ratio : 1);

				p.bodyA = params.bodyA;
				p.bodyB = params.bodyB;

				return p;
			};

			// Point these methods at specific methods on the base class.
			Physics2DMotorConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
			Physics2DMotorConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
			Physics2DMotorConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
			Physics2DMotorConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
			Physics2DMotorConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;

			return Physics2DMotorConstraint;
})
// =========================================================================
//
//
// Pulley Constraint
//
// PULLEY DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*PULLEY_JOINTMIN*/5   // Joint limits
///*PULLEY_JOINTMAX*/6   //
///*PULLEY_RATIO*/7      // Pulley ratio
///*PULLEY_KMASS*/8      // Effective-mass (scalar)
///*PULLEY_JACC*/9       // Accumulated impulse (scalar)
///*PULLEY_JMAX*/10      // Maximum impulse (maxForce derived)
///*PULLEY_LANCHOR1*/11  // Local anchor position on bodyA (x, y)
///*PULLEY_LANCHOR2*/13  // Local anchor position on bodyB (x, y)
///*PULLEY_LANCHOR3*/15  // Local anchor position on bodyC (x, y)
///*PULLEY_LANCHOR4*/17  // Local anchor position on bodyD (x, y)
///*PULLEY_RANCHOR1*/19  // Relative anchor position on bodyA (x, y)
///*PULLEY_RANCHOR2*/21  // Relative anchor position on bodyB (x, y)
///*PULLEY_RANCHOR3*/23  // Relative anchor position on bodyC (x, y)
///*PULLEY_RANCHOR4*/25  // Relative anchor position on bodyD (x, y)
///*PULLEY_GAMMA*/27     // Soft constraint gamma
///*PULLEY_BIAS*/28      // Soft constraint bias (scalar)
///*PULLEY_N12*/29       // Direction of constraint (r1 -> r2) (x, y)
///*PULLEY_N34*/31       // Direction of constraint (r3 -> r4) (x, y)
///*PULLEY_CX1*/33       // (RANCHOR1 cross N12)
///*PULLEY_CX2*/34       // (RANCHOR2 cross N12)
///*PULLEY_CX3*/35       // (RANCHOR3 cross N34)
///*PULLEY_CX4*/36       // (RANCHOR4 cross N34)
//
///*PULLEY_DATA_SIZE*/37

define(
	'spell/physics/2D/PulleyConstraint',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Constraint',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DConstraint,
	    Types
		) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DPulleyConstraint = function() {
				Physics2DConstraint.apply(this, arguments);
				this.type = "PULLEY";
				this.dimension = 1;
				// Inherited
				this._ANCHOR_A = (/*PULLEY_LANCHOR1*/ 11);
				this._ANCHOR_B = (/*PULLEY_LANCHOR2*/ 13);
				this._ANCHOR_C = (/*PULLEY_LANCHOR3*/ 15);
				this._ANCHOR_D = (/*PULLEY_LANCHOR4*/ 17);
				// =====================================================
				// Inherited
				this._JACC = (/*PULLEY_JACC*/ 9);
			}
			__extends(Physics2DPulleyConstraint, Physics2DConstraint);


			// ===============================================
			Physics2DPulleyConstraint.prototype.getRatio = function () {
				return this._data[(/*PULLEY_RATIO*/ 7)];
			};
			Physics2DPulleyConstraint.prototype.setRatio = function (ratio) {
				var data = this._data;
				if (data[(/*PULLEY_RATIO*/ 7)] !== ratio) {
					data[(/*PULLEY_RATIO*/ 7)] = ratio;
					this.wake(true);
				}
			};

			Physics2DPulleyConstraint.prototype.getLowerBound = function () {
				return this._data[(/*PULLEY_JOINTMIN*/ 5)];
			};
			Physics2DPulleyConstraint.prototype.getUpperBound = function () {
				return this._data[(/*PULLEY_JOINTMAX*/ 6)];
			};

			Physics2DPulleyConstraint.prototype.setLowerBound = function (lowerBound) {
				var data = this._data;
				if (data[(/*PULLEY_JOINTMIN*/ 5)] !== lowerBound) {
					data[(/*PULLEY_JOINTMIN*/ 5)] = lowerBound;
					this._equal = (lowerBound === data[(/*PULLEY_JOINTMAX*/ 6)]);
					this.wake(true);
				}
			};
			Physics2DPulleyConstraint.prototype.setUpperBound = function (upperBound) {
				var data = this._data;
				if (data[(/*PULLEY_JOINTMAX*/ 6)] !== upperBound) {
					data[(/*PULLEY_JOINTMAX*/ 6)] = upperBound;
					this._equal = (upperBound === data[(/*PULLEY_JOINTMIN*/ 5)]);
					this.wake(true);
				}
			};

			Physics2DPulleyConstraint.prototype.getAnchorC = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var INDEX = this._ANCHOR_C;
				dst[0] = data[INDEX];
				dst[1] = data[INDEX + 1];
				return dst;
			};
			Physics2DPulleyConstraint.prototype.setAnchorC = function (anchor /*v2*/ ) {
				var data = this._data;
				var INDEX = this._ANCHOR_C;
				var newX = anchor[0];
				var newY = anchor[1];
				if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
					data[INDEX] = newX;
					data[INDEX + 1] = newY;
					this.wake(true);
				}
			};

			Physics2DPulleyConstraint.prototype.getAnchorD = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var INDEX = this._ANCHOR_D;
				dst[0] = data[INDEX];
				dst[1] = data[INDEX + 1];
				return dst;
			};
			Physics2DPulleyConstraint.prototype.setAnchorD = function (anchor /*v2*/ ) {
				var data = this._data;
				var INDEX = this._ANCHOR_D;
				var newX = anchor[0];
				var newY = anchor[1];
				if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
					data[INDEX] = newX;
					data[INDEX + 1] = newY;
					this.wake(true);
				}
			};

			// =========================================================
			Physics2DPulleyConstraint.prototype._inWorld = function () {
				this.bodyA.constraints.push(this);
				this.bodyB.constraints.push(this);
				if (this.bodyB !== this.bodyC) {
					this.bodyC.constraints.push(this);
				}
				this.bodyD.constraints.push(this);
			};

			Physics2DPulleyConstraint.prototype._outWorld = function () {
				var constraints = this.bodyA.constraints;
				var index = constraints.indexOf(this);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();

				constraints = this.bodyB.constraints;
				index = constraints.indexOf(this);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();

				if (this.bodyB !== this.bodyC) {
					constraints = this.bodyB.constraints;
					index = constraints.indexOf(this);
					constraints[index] = constraints[constraints.length - 1];
					constraints.pop();
				}

				constraints = this.bodyD.constraints;
				index = constraints.indexOf(this);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();
			};

			Physics2DPulleyConstraint.prototype._pairExists = function (b1, b2) {
				var bodyA = this.bodyA;
				var bodyB = this.bodyB;
				var bodyC = this.bodyC;
				var bodyD = this.bodyD;

				return ((b1 === bodyA && (b2 === bodyB || b2 === bodyC || b2 === bodyD)) || (b1 === bodyB && (b2 === bodyA || b2 === bodyC || b2 === bodyD)) || (b1 === bodyC && (b2 === bodyA || b2 === bodyB || b2 === bodyD)) || (b1 === bodyD && (b2 === bodyA || b2 === bodyB || b2 === bodyC)));
			};

			Physics2DPulleyConstraint.prototype._wakeConnected = function () {
				var body = this.bodyA;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					body.wake(true);
				}

				body = this.bodyB;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					body.wake(true);
				}

				body = this.bodyC;
				if (body !== this.bodyB && body._type === (/*TYPE_DYNAMIC*/ 0)) {
					body.wake(true);
				}

				body = this.bodyD;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					body.wake(true);
				}
			};

			Physics2DPulleyConstraint.prototype._sleepComputation = function (union) {
				var body = this.bodyA;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					union(body, this);
				}

				body = this.bodyB;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					union(body, this);
				}

				body = this.bodyC;
				if (body !== this.bodyB && body._type === (/*TYPE_DYNAMIC*/ 0)) {
					union(body, this);
				}

				body = this.bodyD;
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					union(body, this);
				}
			};

			Physics2DPulleyConstraint.prototype._posError = function () {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				Physics2DConstraint.prototype.rotateAnchor(data, b1, (/*PULLEY_LANCHOR1*/ 11), (/*PULLEY_RANCHOR1*/ 19));
				Physics2DConstraint.prototype.rotateAnchor(data, b2, (/*PULLEY_LANCHOR2*/ 13), (/*PULLEY_RANCHOR2*/ 21));
				Physics2DConstraint.prototype.rotateAnchor(data, b3, (/*PULLEY_LANCHOR3*/ 15), (/*PULLEY_RANCHOR3*/ 23));
				Physics2DConstraint.prototype.rotateAnchor(data, b4, (/*PULLEY_LANCHOR4*/ 17), (/*PULLEY_RANCHOR4*/ 25));

				var jointMin = data[(/*PULLEY_JOINTMIN*/ 5)];
				var jointMax = data[(/*PULLEY_JOINTMAX*/ 6)];

				var n12x = ((b2[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR2*/ 21)]) - (b1[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR1*/ 19)]));
				var n12y = ((b2[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR2*/ 21) + 1]) - (b1[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR1*/ 19) + 1]));
				var n34x = ((b4[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR4*/ 25)]) - (b3[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR3*/ 23)]));
				var n34y = ((b4[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR4*/ 25) + 1]) - (b3[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR3*/ 23) + 1]));

				var err12 = ((n12x * n12x) + (n12y * n12y));
				var err34 = ((n34x * n34x) + (n34y * n34y));
				var rec;
				if (err12 < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
					err12 = 0;
					n12x = data[(/*PULLEY_N12*/ 29)];
					n12y = data[(/*PULLEY_N12*/ 29) + 1];
				} else {
					err12 = Math.sqrt(err12);
					rec = (1 / err12);
					n12x *= rec;
					n12y *= rec;
				}

				var ratio = data[(/*PULLEY_RATIO*/ 7)];
				if (err34 < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
					err34 = 0;
					n34x = data[(/*PULLEY_N34*/ 31)];
					n34y = data[(/*PULLEY_N34*/ 31) + 1];
				} else {
					err34 = Math.sqrt(err34);
					rec = (ratio / err34);
					n34x *= rec;
					n34y *= rec;
				}

				var err = (err12 + (err34 * ratio));
				if (this._equal) {
					err -= jointMin;
					this._slack = false;
				} else if (err < jointMin) {
					err = (jointMin - err);
					n12x = -n12x;
					n12y = -n12y;
					n34x = -n34x;
					n34y = -n34y;
					this._slack = false;
				} else if (err > jointMax) {
					err -= jointMax;
					this._slack = false;
				} else {
					// Don't set normals to 0.
					// In this case that _slack is true, we do no further work
					// So we permit normals to persist so that should constraint
					// become degenerate we can still choose a 'good' direction.
					//
					// Constraint only becomes degenerate when jointMin = 0 and we reach this
					// limit. In this condition we want negated normals, so that's what we
					// allow to persist.
					n12x = -n12x;
					n12y = -n12y;
					n34x = -n34x;
					n34y = -n34y;

					err = 0;
					this._slack = true;
				}

				data[(/*PULLEY_N12*/ 29)] = n12x;
				data[(/*PULLEY_N12*/ 29) + 1] = n12y;
				data[(/*PULLEY_N34*/ 31)] = n34x;
				data[(/*PULLEY_N34*/ 31) + 1] = n34y;
				data[(/*PULLEY_BIAS*/ 28)] = (-err);
			};

			Physics2DPulleyConstraint.prototype._preStep = function (deltaTime) {
				this._posError();
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				// Compute non-inverted effective mass.
				var ratioSq = data[(/*PULLEY_RATIO*/ 7)];
				ratioSq *= ratioSq;
				var n12x = data[(/*PULLEY_N12*/ 29)];
				var n12y = data[(/*PULLEY_N12*/ 29) + 1];
				var n34x = data[(/*PULLEY_N34*/ 31)];
				var n34y = data[(/*PULLEY_N34*/ 31) + 1];
				var cx1 = data[(/*PULLEY_CX1*/ 33)] = ((data[(/*PULLEY_RANCHOR1*/ 19)] * n12y) - (data[(/*PULLEY_RANCHOR1*/ 19) + 1] * n12x));
				var cx2 = data[(/*PULLEY_CX2*/ 34)] = ((data[(/*PULLEY_RANCHOR2*/ 21)] * n12y) - (data[(/*PULLEY_RANCHOR2*/ 21) + 1] * n12x));
				var cx3 = data[(/*PULLEY_CX3*/ 35)] = ((data[(/*PULLEY_RANCHOR3*/ 23)] * n34y) - (data[(/*PULLEY_RANCHOR3*/ 23) + 1] * n34x));
				var cx4 = data[(/*PULLEY_CX4*/ 36)] = ((data[(/*PULLEY_RANCHOR4*/ 25)] * n34y) - (data[(/*PULLEY_RANCHOR4*/ 25) + 1] * n34x));
				var im3 = b3[(/*BODY_IMASS*/ 0)];
				var ii3 = b3[(/*BODY_IINERTIA*/ 1)];
				var K = (b1[(/*BODY_IMASS*/ 0)] + b2[(/*BODY_IMASS*/ 0)] + (ratioSq * (im3 + b4[(/*BODY_IMASS*/ 0)])) + (cx1 * b1[(/*BODY_IINERTIA*/ 1)] * cx1) + (cx2 * b2[(/*BODY_IINERTIA*/ 1)] * cx2) + (cx3 * ii3 * cx3) + (cx4 * b4[(/*BODY_IINERTIA*/ 1)] * cx4));
				if (b2 === b3) {
					K -= 2 * ((((n12x * n34x) + (n12y * n34y)) * im3) + (cx2 * cx3 * ii3));
				}
				data[(/*PULLEY_KMASS*/ 8)] = K;

				// Invert effective mass
				Physics2DConstraint.prototype.safe_invert(data, (/*PULLEY_KMASS*/ 8), (/*PULLEY_JACC*/ 9));

				if (!this._stiff) {
					if (Physics2DConstraint.prototype.soft_params(data, (/*PULLEY_KMASS*/ 8), (/*PULLEY_GAMMA*/ 27), (/*PULLEY_BIAS*/ 28), deltaTime, this._breakUnderError)) {
						return true;
					}
				} else {
					data[(/*PULLEY_GAMMA*/ 27)] = 0;
					data[(/*PULLEY_BIAS*/ 28)] = 0;
				}

				var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
				data[(/*PULLEY_JACC*/ 9)] *= dtRatio;
				data[(/*PULLEY_JMAX*/ 10)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

				return false;
			};

			Physics2DPulleyConstraint.prototype._warmStart = function () {
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				var jAcc = data[(/*PULLEY_JACC*/ 9)];
				var jx = (data[(/*PULLEY_N12*/ 29)] * jAcc);
				var jy = (data[(/*PULLEY_N12*/ 29) + 1] * jAcc);

				var im = b1[(/*BODY_IMASS*/ 0)];
				b1[(/*BODY_VEL*/ 7)] -= (jx * im);
				b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
				b1[(/*BODY_VEL*/ 7) + 2] -= (data[(/*PULLEY_CX1*/ 33)] * jAcc * b1[(/*BODY_IINERTIA*/ 1)]);

				im = b2[(/*BODY_IMASS*/ 0)];
				b2[(/*BODY_VEL*/ 7)] += (jx * im);
				b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
				b2[(/*BODY_VEL*/ 7) + 2] += (data[(/*PULLEY_CX2*/ 34)] * jAcc * b2[(/*BODY_IINERTIA*/ 1)]);

				jx = (data[(/*PULLEY_N34*/ 31)] * jAcc);
				jy = (data[(/*PULLEY_N34*/ 31) + 1] * jAcc);

				im = b3[(/*BODY_IMASS*/ 0)];
				b3[(/*BODY_VEL*/ 7)] -= (jx * im);
				b3[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
				b3[(/*BODY_VEL*/ 7) + 2] -= (data[(/*PULLEY_CX3*/ 35)] * jAcc * b3[(/*BODY_IINERTIA*/ 1)]);

				im = b4[(/*BODY_IMASS*/ 0)];
				b4[(/*BODY_VEL*/ 7)] += (jx * im);
				b4[(/*BODY_VEL*/ 7) + 1] += (jy * im);
				b4[(/*BODY_VEL*/ 7) + 2] += (data[(/*PULLEY_CX4*/ 36)] * jAcc * b4[(/*BODY_IINERTIA*/ 1)]);
			};

			Physics2DPulleyConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(3);
				}

				var jAcc = data[(/*PULLEY_JACC*/ 9)];

				var data = this._data;
				if (body === this.bodyA) {
					dst[0] = -(data[(/*PULLEY_N12*/ 29)] * jAcc);
					dst[1] = -(data[(/*PULLEY_N12*/ 29) + 1] * jAcc);
					dst[2] = -data[(/*PULLEY_CX1*/ 33)] * jAcc;
				} else if (body === this.bodyD) {
					dst[0] = (data[(/*PULLEY_N34*/ 31)] * jAcc);
					dst[1] = (data[(/*PULLEY_N34*/ 31) + 1] * jAcc);
					dst[2] = data[(/*PULLEY_CX4*/ 36)] * jAcc;
				} else {
					var sumX = 0;
					var sumY = 0;
					var sumW = 0;
					if (body === this.bodyB) {
						sumX += (data[(/*PULLEY_N12*/ 29)] * jAcc);
						sumY += (data[(/*PULLEY_N12*/ 29) + 1] * jAcc);
						sumW += data[(/*PULLEY_CX2*/ 34)] * jAcc;
					}
					if (body === this.bodyC) {
						sumX -= (data[(/*PULLEY_N34*/ 31)] * jAcc);
						sumY -= (data[(/*PULLEY_N34*/ 31) + 1] * jAcc);
						sumW -= data[(/*PULLEY_CX3*/ 35)] * jAcc;
					}
					dst[0] = sumX;
					dst[1] = sumY;
					dst[2] = sumW;
				}

				return dst;
			};

			Physics2DPulleyConstraint.prototype._iterateVel = function () {
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				// x = Bias - VelocityError
				var n12x = data[(/*PULLEY_N12*/ 29)];
				var n12y = data[(/*PULLEY_N12*/ 29) + 1];
				var n34x = data[(/*PULLEY_N34*/ 31)];
				var n34y = data[(/*PULLEY_N34*/ 31) + 1];
				var cx1 = data[(/*PULLEY_CX1*/ 33)];
				var cx2 = data[(/*PULLEY_CX2*/ 34)];
				var cx3 = data[(/*PULLEY_CX3*/ 35)];
				var cx4 = data[(/*PULLEY_CX4*/ 36)];
				var x = (data[(/*PULLEY_BIAS*/ 28)] - ((n12x * (b2[(/*BODY_VEL*/ 7)] - b1[(/*BODY_VEL*/ 7)])) + (n12y * (b2[(/*BODY_VEL*/ 7) + 1] - b1[(/*BODY_VEL*/ 7) + 1])) + (n34x * (b4[(/*BODY_VEL*/ 7)] - b3[(/*BODY_VEL*/ 7)])) + (n34y * (b4[(/*BODY_VEL*/ 7) + 1] - b3[(/*BODY_VEL*/ 7) + 1])) + (cx2 * b2[(/*BODY_VEL*/ 7) + 2]) - (cx1 * b1[(/*BODY_VEL*/ 7) + 2]) + (cx4 * b4[(/*BODY_VEL*/ 7) + 2]) - (cx3 * b3[(/*BODY_VEL*/ 7) + 2])));

				var jOld = data[(/*PULLEY_JACC*/ 9)];

				// Impulse.
				// j = K * x - jAcc * gamma
				var j = ((data[(/*PULLEY_KMASS*/ 8)] * x) - (jOld * data[(/*PULLEY_GAMMA*/ 27)]));

				// Accumulate and clamp.
				var jAcc = (jOld + j);
				var jMax = data[(/*PULLEY_JMAX*/ 10)];
				if (!this._equal && jAcc > 0) {
					jAcc = 0;
				}
				if (this._breakUnderForce) {
					if (jAcc > jMax || jAcc < -jMax) {
						return true;
					}
				} else if (!this._stiff) {
					if (jAcc > jMax) {
						jAcc = jMax;
					} else if (jAcc < -jMax) {
						jAcc = -jMax;
					}
				}

				j = (jAcc - jOld);
				data[(/*PULLEY_JACC*/ 9)] = jAcc;

				// Apply impulse.
				var jx = (data[(/*PULLEY_N12*/ 29)] * j);
				var jy = (data[(/*PULLEY_N12*/ 29) + 1] * j);

				var im = b1[(/*BODY_IMASS*/ 0)];
				b1[(/*BODY_VEL*/ 7)] -= (jx * im);
				b1[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
				b1[(/*BODY_VEL*/ 7) + 2] -= (cx1 * j * b1[(/*BODY_IINERTIA*/ 1)]);

				im = b2[(/*BODY_IMASS*/ 0)];
				b2[(/*BODY_VEL*/ 7)] += (jx * im);
				b2[(/*BODY_VEL*/ 7) + 1] += (jy * im);
				b2[(/*BODY_VEL*/ 7) + 2] += (cx2 * j * b2[(/*BODY_IINERTIA*/ 1)]);

				jx = (data[(/*PULLEY_N34*/ 31)] * j);
				jy = (data[(/*PULLEY_N34*/ 31) + 1] * j);

				im = b3[(/*BODY_IMASS*/ 0)];
				b3[(/*BODY_VEL*/ 7)] -= (jx * im);
				b3[(/*BODY_VEL*/ 7) + 1] -= (jy * im);
				b3[(/*BODY_VEL*/ 7) + 2] -= (cx3 * j * b3[(/*BODY_IINERTIA*/ 1)]);

				im = b4[(/*BODY_IMASS*/ 0)];
				b4[(/*BODY_VEL*/ 7)] += (jx * im);
				b4[(/*BODY_VEL*/ 7) + 1] += (jy * im);
				b4[(/*BODY_VEL*/ 7) + 2] += (cx4 * j * b4[(/*BODY_IINERTIA*/ 1)]);

				return false;
			};

			Physics2DPulleyConstraint.prototype._iteratePos = function () {
				this._posError();
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				var im1 = b1[(/*BODY_IMASS*/ 0)];
				var im2 = b2[(/*BODY_IMASS*/ 0)];
				var im3 = b3[(/*BODY_IMASS*/ 0)];
				var im4 = b4[(/*BODY_IMASS*/ 0)];
				var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
				var ii2 = b2[(/*BODY_IINERTIA*/ 1)];
				var ii3 = b3[(/*BODY_IINERTIA*/ 1)];
				var ii4 = b4[(/*BODY_IINERTIA*/ 1)];

				var err = data[(/*PULLEY_BIAS*/ 28)];
				var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];

				if (this._breakUnderError && (err > maxError || err < -maxError)) {
					return true;
				}

				var slop = Physics2DConfig.PULLEY_SLOP_SQ;
				if ((err * err) < slop) {
					return false;
				}

				err *= Physics2DConfig.PULLEY_BIAS_COEF;

				var ratioSq = data[(/*PULLEY_RATIO*/ 7)];
				ratioSq *= ratioSq;

				var K = (im1 + im2 + (ratioSq * (im3 + im4)));
				var n12x = data[(/*PULLEY_N12*/ 29)];
				var n12y = data[(/*PULLEY_N12*/ 29) + 1];
				var n34x = data[(/*PULLEY_N34*/ 31)];
				var n34y = data[(/*PULLEY_N34*/ 31) + 1];
				if (b2 === b3) {
					K -= 2 * ((n12x * n34x) + (n12y * n34y)) * im2;
				}

				var j, jx, jy;

				// Handle large error seperately.
				if ((err * err) > Physics2DConfig.PULLEY_LARGE_ERROR_SQ) {
					if (K > Physics2DConfig.EFF_MASS_EPSILON) {
						j = (err * Physics2DConfig.PULLEY_LARGE_ERROR_BIAS / K);
						if (this._equal || j < 0) {
							jx = (n12x * j);
							jy = (n12y * j);
							b1[(/*BODY_POS*/ 2)] -= (jx * im1);
							b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
							b2[(/*BODY_POS*/ 2)] += (jx * im2);
							b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);

							jx = (n34x * j);
							jy = (n34y * j);
							b3[(/*BODY_POS*/ 2)] -= (jx * im3);
							b3[(/*BODY_POS*/ 2) + 1] -= (jy * im3);
							b4[(/*BODY_POS*/ 2)] += (jx * im4);
							b4[(/*BODY_POS*/ 2) + 1] += (jy * im4);

							// Recalculate error.
							this._posError();
							n12x = data[(/*PULLEY_N12*/ 29)];
							n12y = data[(/*PULLEY_N12*/ 29) + 1];
							n34x = data[(/*PULLEY_N34*/ 31)];
							n34y = data[(/*PULLEY_N34*/ 31) + 1];
							err = data[(/*PULLEY_BIAS*/ 28)] * Physics2DConfig.PULLEY_BIAS_COEF;
						}
					}
				}

				var cx1 = ((data[(/*PULLEY_RANCHOR1*/ 19)] * n12y) - (data[(/*PULLEY_RANCHOR1*/ 19) + 1] * n12x));
				var cx2 = ((data[(/*PULLEY_RANCHOR2*/ 21)] * n12y) - (data[(/*PULLEY_RANCHOR2*/ 21) + 1] * n12x));
				var cx3 = ((data[(/*PULLEY_RANCHOR3*/ 23)] * n34y) - (data[(/*PULLEY_RANCHOR3*/ 23) + 1] * n34x));
				var cx4 = ((data[(/*PULLEY_RANCHOR4*/ 25)] * n34y) - (data[(/*PULLEY_RANCHOR4*/ 25) + 1] * n34x));
				K += ((cx1 * ii1 * cx1) + (cx2 * ii2 * cx2) + (cx3 * ii3 * cx3) + (cx4 * ii4 * cx4));
				if (b2 === b2) {
					K -= (2 * cx2 * ii2 * cx3);
				}

				data[(/*PULLEY_KMASS*/ 8)] = K;
				data[(/*PULLEY_BIAS*/ 28)] = err;
				Physics2DConstraint.prototype.safe_solve(data, (/*PULLEY_KMASS*/ 8), (/*PULLEY_BIAS*/ 28), (/*PULLEY_BIAS*/ 28));
				j = data[(/*PULLEY_BIAS*/ 28)];

				if (this._equal || j < 0) {
					var dr;
					jx = (n12x * j);
					jy = (n12y * j);
					b1[(/*BODY_POS*/ 2)] -= (jx * im1);
					b1[(/*BODY_POS*/ 2) + 1] -= (jy * im1);
					dr = (-cx1 * j * ii1);
					if (dr !== 0) {
						this.bodyA._deltaRotation(dr);
					}

					b2[(/*BODY_POS*/ 2)] += (jx * im2);
					b2[(/*BODY_POS*/ 2) + 1] += (jy * im2);
					dr = (cx2 * j * ii2);
					if (dr !== 0) {
						this.bodyB._deltaRotation(dr);
					}

					jx = (n34x * j);
					jy = (n34y * j);
					b3[(/*BODY_POS*/ 2)] -= (jx * im3);
					b3[(/*BODY_POS*/ 2) + 1] -= (jy * im3);
					dr = (-cx3 * j * ii3);
					if (dr !== 0) {
						this.bodyC._deltaRotation(dr);
					}

					b4[(/*BODY_POS*/ 2)] += (jx * im4);
					b4[(/*BODY_POS*/ 2) + 1] += (jy * im4);
					dr = (cx4 * j * ii4);
					if (dr !== 0) {
						this.bodyD._deltaRotation(dr);
					}
				}

				return false;
			};

			// params = {
			//   bodyA, bodyB, bodyC, bodyD // bodyB permitted equal to bodyC
			//   anchorA, anchorB, anchorC, anchorD
			//   lowerBound, upperBound, ratio
			//   .. common constraint params
			// }
			Physics2DPulleyConstraint.create = function (params) {
				var p = new Physics2DPulleyConstraint();
				var data = p._data = Types.createFloatArray((/*PULLEY_DATA_SIZE*/ 37));
				Physics2DConstraint.prototype.init(p, params);

				var anchor = params.anchorA;
				data[(/*PULLEY_LANCHOR1*/ 11)] = (anchor ? anchor[0] : 0);
				data[(/*PULLEY_LANCHOR1*/ 11) + 1] = (anchor ? anchor[1] : 0);

				anchor = params.anchorB;
				data[(/*PULLEY_LANCHOR2*/ 13)] = (anchor ? anchor[0] : 0);
				data[(/*PULLEY_LANCHOR2*/ 13) + 1] = (anchor ? anchor[1] : 0);

				anchor = params.anchorC;
				data[(/*PULLEY_LANCHOR3*/ 15)] = (anchor ? anchor[0] : 0);
				data[(/*PULLEY_LANCHOR3*/ 15) + 1] = (anchor ? anchor[1] : 0);

				anchor = params.anchorD;
				data[(/*PULLEY_LANCHOR4*/ 17)] = (anchor ? anchor[0] : 0);
				data[(/*PULLEY_LANCHOR4*/ 17) + 1] = (anchor ? anchor[1] : 0);

				var min = data[(/*PULLEY_JOINTMIN*/ 5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
				var max = data[(/*PULLEY_JOINTMAX*/ 6)] = (params.upperBound !== undefined ? params.upperBound : 0);
				p._equal = (min === max);

				data[(/*PULLEY_RATIO*/ 7)] = (params.ratio !== undefined ? params.ratio : 1);

				p._slack = false;

				p.bodyA = params.bodyA;
				p.bodyB = params.bodyB;
				p.bodyC = params.bodyC;
				p.bodyD = params.bodyD;

				// Seed normal incase initial anchors are degenerate.
				data[(/*PULLEY_N12*/ 29)] = 1;
				data[(/*PULLEY_N12*/ 29) + 1] = 0;
				data[(/*PULLEY_N34*/ 31)] = 1;
				data[(/*PULLEY_N34*/ 31) + 1] = 0;

				return p;
			};

			Physics2DPulleyConstraint.prototype._draw = function _pulleyDrawFn(debug) {
				var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
				var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
				var colC = (this.sleeping ? debug.constraintSleepingColorC : debug.constraintColorC);
				var colD = (this.sleeping ? debug.constraintSleepingColorD : debug.constraintColorD);
				var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
				var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);
				var colSC = (this.sleeping ? debug.constraintErrorSleepingColorC : debug.constraintErrorColorC);
				var colSD = (this.sleeping ? debug.constraintErrorSleepingColorD : debug.constraintErrorColorD);

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;
				var b3 = this.bodyC._data;
				var b4 = this.bodyD._data;

				var x1 = (b1[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR1*/ 19)]);
				var y1 = (b1[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR1*/ 19) + 1]);
				var x2 = (b2[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR2*/ 21)]);
				var y2 = (b2[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR2*/ 21) + 1]);
				var x3 = (b3[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR3*/ 23)]);
				var y3 = (b3[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR3*/ 23) + 1]);
				var x4 = (b4[(/*BODY_POS*/ 2)] + data[(/*PULLEY_RANCHOR4*/ 25)]);
				var y4 = (b4[(/*BODY_POS*/ 2) + 1] + data[(/*PULLEY_RANCHOR4*/ 25) + 1]);

				var n12x = (x2 - x1);
				var n12y = (y2 - y1);
				var n34x = (x4 - x3);
				var n34y = (y4 - y3);
				var nL12 = Math.sqrt((n12x * n12x) + (n12y * n12y));
				var nL34 = Math.sqrt((n34x * n34x) + (n34y * n34y));
				var ratio = data[(/*PULLEY_RATIO*/ 7)];
				this._drawLink(debug, x1, y1, x2, y2, n12x, n12y, nL12, (nL34 * ratio), 1.0, colSA, colSB);
				this._drawLink(debug, x3, y3, x4, y4, n34x, n34y, nL34, nL12, (1 / ratio), colSC, colSD);

				var rad = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
				debug._drawAnchor(x1, y1, rad, colA);
				debug._drawAnchor(x2, y2, rad, colB);
				debug._drawAnchor(x3, y3, rad, colC);
				debug._drawAnchor(x4, y4, rad, colD);
			};

			Physics2DPulleyConstraint.prototype._drawLink = function _drawLinkFn(debug, x1, y1, x2, y2, nx, ny, nl, bias, scale, colSA, colSB) {
				if (nl > Physics2DConfig.NORMALIZE_EPSILON) {
					var rec = (1 / nl);
					nx *= rec;
					ny *= rec;

					var midX = (0.5 * (x1 + x2));
					var midY = (0.5 * (y1 + y2));

					var data = this._data;
					var jointMin = (data[(/*PULLEY_JOINTMIN*/ 5)] - bias) * scale;
					if (jointMin < 0) {
						jointMin = 0;
					}
					var jointMax = (data[(/*PULLEY_JOINTMAX*/ 6)] - bias) * scale;
					if (jointMax < 0) {
						jointMax = 0;
					}

					var minX1 = (midX - (nx * (jointMin * 0.5)));
					var minY1 = (midY - (ny * (jointMin * 0.5)));
					var minX2 = (midX + (nx * (jointMin * 0.5)));
					var minY2 = (midY + (ny * (jointMin * 0.5)));
					var maxX1 = (midX - (nx * (jointMax * 0.5)));
					var maxY1 = (midY - (ny * (jointMax * 0.5)));
					var maxX2 = (midX + (nx * (jointMax * 0.5)));
					var maxY2 = (midY + (ny * (jointMax * 0.5)));

					debug.drawLine(minX1, minY1, minX2, minY2, colSA);
					debug.drawLine(maxX1, maxY1, minX1, minY1, colSB);
					debug.drawLine(maxX2, maxY2, minX2, minY2, colSB);

					if (!this._stiff) {
						var numCoils = debug.constraintSpringNumCoils;
						var radius = (debug.constraintSpringRadius * debug.screenToPhysics2D);
						if (nl > jointMax) {
							debug.drawLinearSpring(maxX1, maxY1, x1, y1, numCoils, radius, colSB);
							debug.drawLinearSpring(maxX2, maxY2, x2, y2, numCoils, radius, colSB);
						} else if (nl < jointMin) {
							debug.drawLinearSpring(minX1, minY1, x1, y1, numCoils, radius, colSA);
							debug.drawLinearSpring(minX2, minY2, x2, y2, numCoils, radius, colSA);
						}
					}
				}
			};

		return Physics2DPulleyConstraint;
})





define(
	'spell/physics/2D/Constraint',
	[
		'spell/shared/util/platform/Types'
	],
	function(Types) {
		var Physics2DConstraint = function() {
		}
		// Abstract methods to be overridden by subclasses
		Physics2DConstraint.prototype._inWorld = function () {
			//debug.abort("abstract method");
		};
		Physics2DConstraint.prototype._outWorld = function () {
			//debug.abort("abstract method");
		};
		Physics2DConstraint.prototype._pairExists = function (b1, b2) {
			//debug.abort("abstract method");
			return false;
		};
		Physics2DConstraint.prototype._wakeConnected = function () {
			//debug.abort("abstract method");
		};
		Physics2DConstraint.prototype._sleepComputation = function (union) {
			//debug.abort("abstract method");
		};
		Physics2DConstraint.prototype._preStep = function (deltaTime) {
			//debug.abort("abstract method");
			return false;
		};
		Physics2DConstraint.prototype._warmStart = function () {
			//debug.abort("abstract method");
		};
		Physics2DConstraint.prototype._iterateVel = function () {
			//debug.abort("abstract method");
			return false;
		};
		Physics2DConstraint.prototype._iteratePos = function () {
			//debug.abort("abstract method");
			return false;
		};

		Physics2DConstraint.prototype.init = function (con, params) {
			var data = con._data;
			data[(/*JOINT_FREQUENCY*/ 0)] = (params.frequency !== undefined ? params.frequency : 10.0);
			data[(/*JOINT_DAMPING*/ 1)] = (params.damping !== undefined ? params.damping : 1.0);
			data[(/*JOINT_MAX_FORCE*/ 2)] = (params.maxForce !== undefined ? params.maxForce : Number.POSITIVE_INFINITY);
			data[(/*JOINT_MAX_ERROR*/ 3)] = (params.maxError !== undefined ? params.maxError : Number.POSITIVE_INFINITY);
			data[(/*JOINT_PRE_DT*/ 4)] = -1;

			con._removeOnBreak = (params.removeOnBreak !== undefined ? params.removeOnBreak : true);
			con._breakUnderError = (params.breakUnderError !== undefined ? params.breakUnderError : false);
			con._breakUnderForce = (params.breakUnderForce !== undefined ? params.breakUnderForce : false);
			con._stiff = (params.stiff !== undefined ? params.stiff : true);
			con._ignoreInteractions = (params.ignoreInteractions !== undefined ? params.ignoreInteractions : false);
			con.sleeping = (params.sleeping !== undefined ? params.sleeping : false);
			con._active = (params.disabled !== undefined ? (!params.disabled) : true);

			con.world = null;
			con._islandRoot = null;
			con._islandRank = 0;
			con._island = null;
			con._isBody = false;

			con._wakeTime = 0;

			con._onBreak = [];
			con._onWake = [];
			con._onSleep = [];

			con.userData = (params.userData || null);
		};

		Physics2DConstraint.prototype.configure = function (params) {
			var data = this._data;
			if (params.frequency !== undefined) {
				data[(/*JOINT_FREQUENCY*/ 0)] = params.frequency;
			}
			if (params.damping !== undefined) {
				data[(/*JOINT_DAMPING*/ 1)] = params.damping;
			}
			if (params.maxForce !== undefined) {
				data[(/*JOINT_MAX_FORCE*/ 2)] = params.maxForce;
			}
			if (params.maxError !== undefined) {
				data[(/*JOINT_MAX_ERROR*/ 3)] = params.maxError;
			}
			if (params.removeOnBreak !== undefined) {
				this._removeOnBreak = params.removeOnBreak;
			}
			if (params.breakUnderError !== undefined) {
				this._breakUnderError = params.breakUnderError;
			}
			if (params.breakUnderForce !== undefined) {
				this._breakUnderForce = params.breakUnderForce;
			}
			if (params.ignoreInteractions !== undefined) {
				this._ignoreInteractions = params.ignoreInteractions;
			}
			if (params.stiff !== undefined) {
				this._stiff = params.stiff;
			}
			this.wake(true);
		};

		// ===============================================
		Physics2DConstraint.prototype.addEventListener = function (eventType, callback) {
			var events = (eventType === 'wake' ? this._onWake : eventType === 'sleep' ? this._onSleep : eventType === 'break' ? this._onBreak : null);

			if (events === null) {
				return false;
			}

			var index = events.indexOf(callback);
			if (index !== -1) {
				return false;
			}

			events.push(callback);

			this.wake();

			return true;
		};

		Physics2DConstraint.prototype.removeEventListener = function (eventType, callback) {
			var events = (eventType === 'wake' ? this._onWake : eventType === 'sleep' ? this._onSleep : eventType === 'break' ? this._onBreak : null);

			if (events === null) {
				return false;
			}

			var index = events.indexOf(callback);
			if (index === -1) {
				return false;
			}

			// Need to keep order, cannot use swap-pop
			events.splice(index, 1);

			this.wake();

			return true;
		};

		// ===============================================
		Physics2DConstraint.prototype.wake = function (automated) {
			if (!this.world) {
				this.sleeping = false;
				return;
			}

			this.world._wakeConstraint(this, !automated);
		};
		Physics2DConstraint.prototype.sleep = function () {
			if (!this.world) {
				this.sleeping = true;
				return;
			}

			this.world._forceSleepConstraint(this);
		};

		// ================================================
		Physics2DConstraint.prototype.isEnabled = function () {
			return this._active;
		};

		Physics2DConstraint.prototype.isDisabled = function () {
			return (!this._active);
		};

		Physics2DConstraint.prototype.enable = function () {
			if (!this._active) {
				this._active = true;
				if (this.world) {
					this.world._enabledConstraint(this);
					this.wake(true);
				}
			}
		};

		Physics2DConstraint.prototype.disable = function () {
			if (this._active) {
				if (this.world) {
					// Emulate a non-automated wake
					// to prevent wake callback.
					this.wake(false);
					this.world._disabledConstraint(this);
				}
				this._active = false;
			}
		};

		// ================================================
		Physics2DConstraint.prototype.getAnchorA = function (dst) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}
			var data = this._data;
			var INDEX = this._ANCHOR_A;
			dst[0] = data[INDEX];
			dst[1] = data[INDEX + 1];
			return dst;
		};
		Physics2DConstraint.prototype.getAnchorB = function (dst) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}
			var data = this._data;
			var INDEX = this._ANCHOR_B;
			dst[0] = data[INDEX];
			dst[1] = data[INDEX + 1];
			return dst;
		};

		Physics2DConstraint.prototype.setAnchorA = function (anchor) {
			var data = this._data;
			var INDEX = this._ANCHOR_A;
			var newX = anchor[0];
			var newY = anchor[1];
			if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
				data[INDEX] = newX;
				data[INDEX + 1] = newY;
				this.wake(true);
			}
		};
		Physics2DConstraint.prototype.setAnchorB = function (anchor) {
			var data = this._data;
			var INDEX = this._ANCHOR_B;
			var newX = anchor[0];
			var newY = anchor[1];
			if (newX !== data[INDEX] || newY !== data[INDEX + 1]) {
				data[INDEX] = newX;
				data[INDEX + 1] = newY;
				this.wake(true);
			}
		};

		Physics2DConstraint.prototype.rotateAnchor = function (data /*floatArray*/ , body, LOCAL, RELATIVE) {
			var x = data[LOCAL];
			var y = data[LOCAL + 1];
			var cos = body[(/*BODY_AXIS*/ 5)];
			var sin = body[(/*BODY_AXIS*/ 5) + 1];

			data[RELATIVE] = ((cos * x) - (sin * y));
			data[RELATIVE + 1] = ((sin * x) + (cos * y));
		};

		// ================================================
		Physics2DConstraint.prototype.dtRatio = function (data /*floatArray*/ , deltaTime) {
			var preDt = data[(/*JOINT_PRE_DT*/ 4)];
			var dtRatio = (preDt === -1 ? 1.0 : (deltaTime / preDt));
			data[(/*JOINT_PRE_DT*/ 4)] = deltaTime;
			return dtRatio;
		};

		// ================================================
		Physics2DConstraint.prototype.twoBodyInWorld = function () {
			this.bodyA.constraints.push(this);
			this.bodyB.constraints.push(this);
		};

		Physics2DConstraint.prototype.twoBodyOutWorld = function () {
			var constraints = this.bodyA.constraints;
			var index = constraints.indexOf(this);
			constraints[index] = constraints[constraints.length - 1];
			constraints.pop();

			constraints = this.bodyB.constraints;
			index = constraints.indexOf(this);
			constraints[index] = constraints[constraints.length - 1];
			constraints.pop();
		};

		Physics2DConstraint.prototype.twoBodyPairExists = function (b1, b2) {
			return ((b1 === this.bodyA && b2 === this.bodyB) || (b2 === this.bodyA && b1 === this.bodyB));
		};

		Physics2DConstraint.prototype.twoBodyWakeConnected = function () {
			var body = this.bodyA;
			if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
				body.wake(true);
			}

			body = this.bodyB;
			if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
				body.wake(true);
			}
		};

		Physics2DConstraint.prototype.twoBodySleepComputation = function (union) {
			var body = this.bodyA;
			if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
				union(body, this);
			}

			body = this.bodyB;
			if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
				union(body, this);
			}
		};

		// ================================================
		Physics2DConstraint.prototype._clearCache = function () {
			//debug.abort("abstract method");
		};

		Physics2DConstraint.prototype.clearCache = function () {
			var data = this._data;
			data[this._JACC] = 0;
			data[(/*JOINT_PRE_DT*/ 4)] = -1;
		};
		Physics2DConstraint.prototype.clearCache2 = function () {
			var data = this._data;
			var INDEX = this._JACC;
			data[INDEX] = data[INDEX + 1] = 0;
			data[(/*JOINT_PRE_DT*/ 4)] = -1;
		};
		Physics2DConstraint.prototype.clearCache3 = function () {
			var data = this._data;
			var INDEX = this._JACC;
			data[INDEX] = data[INDEX + 1] = data[INDEX + 2] = 0;
			data[(/*JOINT_PRE_DT*/ 4)] = -1;
		};

		// ================================================
		// Soft constraint parameter logic.
		// storing gamma at index GAMMA
		// scaling effective mass at KMASS
		// scaling bias at BIAS
		// and returning true if constraint was broken.
		Physics2DConstraint.prototype.soft_params = function (data /*floatArray*/ , KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
			var bias = data[BIAS];
			var bsq = (bias * bias);
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (breakUnderError && (bsq > (maxError * maxError))) {
				return true;
			}

			var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/ 0)]);
			var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/ 1)]) + (omega * deltaTime))));
			var iG = (1 / (1 + gamma));
			var biasCoef = (deltaTime * omega * omega * gamma);

			data[GAMMA] = (gamma * iG);
			data[KMASS] *= iG;

			bias *= biasCoef;
			bsq *= (biasCoef * biasCoef);
			if (bsq > (maxError * maxError)) {
				bsq = (maxError / Math.sqrt(bsq));
				bias *= bsq;
			}
			data[BIAS] = bias;
			return false;
		};
		Physics2DConstraint.prototype.soft_params2 = function (data /*floatArray*/ , KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
			var biasX = data[BIAS];
			var biasY = data[BIAS + 1];
			var bsq = ((biasX * biasX) + (biasY * biasY));
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (breakUnderError && (bsq > (maxError * maxError))) {
				return true;
			}

			var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/ 0)]);
			var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/ 1)]) + (omega * deltaTime))));
			var iG = (1 / (1 + gamma));
			var biasCoef = (deltaTime * omega * omega * gamma);

			data[GAMMA] = (gamma * iG);
			data[KMASS] *= iG;
			data[KMASS + 1] *= iG;
			data[KMASS + 2] *= iG;

			biasX *= biasCoef;
			biasY *= biasCoef;
			bsq *= (biasCoef * biasCoef);
			if (bsq > (maxError * maxError)) {
				bsq = (maxError / Math.sqrt(bsq));
				biasX *= bsq;
				biasY *= bsq;
			}
			data[BIAS] = biasX;
			data[BIAS + 1] = biasY;
			return false;
		};
		Physics2DConstraint.prototype.soft_params3 = function (data /*floatArray*/ , KMASS, GAMMA, BIAS, deltaTime, breakUnderError) {
			var biasX = data[BIAS];
			var biasY = data[BIAS + 1];
			var biasZ = data[BIAS + 2];
			var bsq = ((biasX * biasX) + (biasY * biasY) + (biasZ * biasZ));
			var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
			if (breakUnderError && (bsq > (maxError * maxError))) {
				return true;
			}

			var omega = (2 * Math.PI * data[(/*JOINT_FREQUENCY*/ 0)]);
			var gamma = (1 / (deltaTime * omega * ((2 * data[(/*JOINT_DAMPING*/ 1)]) + (omega * deltaTime))));
			var iG = (1 / (1 + gamma));
			var biasCoef = (deltaTime * omega * omega * gamma);

			data[GAMMA] = (gamma * iG);
			data[KMASS] *= iG;
			data[KMASS + 1] *= iG;
			data[KMASS + 2] *= iG;
			data[KMASS + 3] *= iG;
			data[KMASS + 4] *= iG;
			data[KMASS + 5] *= iG;

			biasX *= biasCoef;
			biasY *= biasCoef;
			biasZ *= biasCoef;
			bsq *= (biasCoef * biasCoef);
			if (bsq > (maxError * maxError)) {
				bsq = (maxError / Math.sqrt(bsq));
				biasX *= bsq;
				biasY *= bsq;
				biasZ *= bsq;
			}
			data[BIAS] = biasX;
			data[BIAS + 1] = biasY;
			data[BIAS + 2] = biasZ;
			return false;
		};

		// Solve K * j = err, permitting degeneracies in K
		// indices JMASS, ERR, IMP
		// ERR may be equal to IMP.
		Physics2DConstraint.prototype.safe_solve = function (data /*floatArray*/ , KMASS, ERR, IMP) {
			var err = data[ERR];
			var K = data[KMASS];
			data[IMP] = (K !== 0 ? (err / K) : 0);
		};
		Physics2DConstraint.prototype.safe_solve2 = function (data /*floatArray*/ , KMASS, ERR, IMP) {
			var errX = data[ERR];
			var errY = data[ERR + 1];

			var Ka = data[KMASS];
			var Kb = data[KMASS + 1];
			var Kc = data[KMASS + 2];
			var det = ((Ka * Kc) - (Kb * Kb));
			if (det === 0) {
				// Consider ranks seperately.
				data[IMP] = (Ka !== 0 ? (errX / Ka) : 0);
				data[IMP + 1] = (Kc !== 0 ? (errY / Kc) : 0);
			} else {
				// Full matrix inversion.
				det = (1 / det);
				data[IMP] = (det * ((Kc * errX) - (Kb * errY)));
				data[IMP + 1] = (det * ((Ka * errY) - (Kb * errX)));
			}
		};
		Physics2DConstraint.prototype.safe_solve3 = function (data /*floatArray*/ , KMASS, ERR, IMP) {
			var errX = data[ERR];
			var errY = data[ERR + 1];
			var errZ = data[ERR + 2];

			var Ka = data[KMASS];
			var Kb = data[KMASS + 1];
			var Kc = data[KMASS + 2];
			var Kd = data[KMASS + 3];
			var Ke = data[KMASS + 4];
			var Kf = data[KMASS + 5];

			var A = ((Kd * Kf) - (Ke * Ke));
			var B = ((Kc * Ke) - (Kb * Kf));
			var C = ((Kb * Ke) - (Kc * Kd));
			var det = ((Ka * A) + (Kb * B) + (Kc * C));
			if (det === 0) {
				det = ((Ka * Kd) - (Kb * Kb));
				if (det !== 0) {
					// Invert matrix ignoring bottom rank.
					// [Ka Kb #]
					// [Kb Kd #]
					// [#  #  #]
					det = (1 / det);
					data[IMP] = (det * ((Kd * errX) - (Kb * errY)));
					data[IMP + 1] = (det * ((Ka * errY) - (Kb * errX)));
					data[IMP + 2] = (Kf !== 0 ? (errZ / Kf) : 0);
					return;
				}

				det = ((Ka * Kf) - (Kc * Kc));
				if (det !== 0) {
					// Invert matrix ignoring bottom rank.
					// [Ka # Kc]
					// [#  #  #]
					// [Kc # Kf]
					det = (1 / det);
					data[IMP] = (det * ((Kf * errX) - (Kc * errZ)));
					data[IMP + 1] = (Kd !== 0 ? (errY / Kd) : 0);
					data[IMP + 2] = (det * ((Ka * errZ) - (Kc * errX)));
					return;
				}

				det = ((Kd * Kf) - (Ke * Ke));
				if (det !== 0) {
					// Invert matrix ignoring top rank
					// [#  #  #]
					// [# Kd Ke]
					// [# Ke Kf]
					det = (1 / det);
					data[IMP] = (Ka !== 0 ? (errX / Ka) : 0);
					data[IMP + 1] = (det * ((Kf * errY) - (Ke * errZ)));
					data[IMP + 2] = (det * ((Kd * errZ) - (Ke * errY)));
					return;
				}

				// Consider all ranks seperately.
				data[IMP] = (Ka !== 0 ? (errX / Ka) : 0);
				data[IMP + 1] = (Kd !== 0 ? (errY / Kd) : 0);
				data[IMP + 2] = (Kf !== 0 ? (errZ / Kf) : 0);
			} else {
				// Full matrix inversion.
				det = (1 / det);
				var D = ((Ka * Kf) - (Kc * Kc));
				var E = ((Kb * Kc) - (Ka * Ke));
				var F = ((Ka * Kd) - (Kb * Kb));
				data[IMP] = (det * ((A * errX) + (B * errY) + (C * errZ)));
				data[IMP + 1] = (det * ((B * errX) + (D * errY) + (E * errZ)));
				data[IMP + 2] = (det * ((C * errX) + (E * errY) + (F * errZ)));
			}
		};

		// Invert matrix stored symmetrically in data at
		// indices KMASS
		// with accumulated impulse at indices JACC
		Physics2DConstraint.prototype.safe_invert = function (data /*floatArray*/ , KMASS, JACC) {
			// Invert [K != 0] into [1 / K]
			// And otherwise into [0] with zero-ed JACC
			var K = data[KMASS];
			if (K === 0) {
				data[JACC] = 0;
			} else {
				data[KMASS] = (1 / K);
			}
		};
		Physics2DConstraint.prototype.safe_invert2 = function (data /*floatArray*/ , KMASS, JACC) {
			var Ka = data[KMASS];
			var Kb = data[KMASS + 1];
			var Kc = data[KMASS + 2];

			var det = ((Ka * Kc) - (Kb * Kb));
			if (det === 0) {
				// Consider both ranks seperately.
				if (Ka !== 0) {
					data[KMASS] = (1 / Ka);
				} else {
					data[JACC] = 0.0;
				}

				if (Kc !== 0) {
					data[KMASS + 2] = (1 / Kc);
				} else {
					data[JACC + 1] = 0.0;
				}

				data[KMASS + 1] = 0.0;
			} else {
				// Full matrix inversion.
				det = (1 / det);
				data[KMASS] = (det * Kc);
				data[KMASS + 1] = (det * -Kb);
				data[KMASS + 2] = (det * Ka);
			}
		};
		Physics2DConstraint.prototype.safe_invert3 = function (data /*floatArray*/ , KMASS, JACC) {
			var Ka = data[KMASS];
			var Kb = data[KMASS + 1];
			var Kc = data[KMASS + 2];
			var Kd = data[KMASS + 3];
			var Ke = data[KMASS + 4];
			var Kf = data[KMASS + 5];

			var A = ((Kd * Kf) - (Ke * Ke));
			var B = ((Kc * Ke) - (Kb * Kf));
			var C = ((Kb * Ke) - (Kc * Kd));
			var det = ((Ka * A) + (Kb * B) + (Kc * C));
			if (det === 0) {
				det = ((Ka * Kd) - (Kb * Kb));
				if (det !== 0) {
					// Invert matrix ignoring bottom rank
					// [Ka Kb #]
					// [Kb Kd #]
					// [#  #  #]
					det = (1 / det);
					data[KMASS] = (det * Kd);
					data[KMASS + 1] = (det * -Kb);
					data[KMASS + 3] = (det * Ka);

					// Consider bottom rank seperately.
					if (Kf !== 0) {
						data[KMASS + 5] = (1 / Kf);
					} else {
						data[JACC + 2] = 0;
					}

					data[KMASS + 2] = data[KMASS + 4] = 0;
					return;
				}

				det = ((Ka * Kf) - (Kc * Kc));
				if (det !== 0) {
					// Invert matrix ignoring middle rank
					// [Ka # Kc]
					// [#  #  #]
					// [Kc # Kf]
					det = (1 / det);
					data[KMASS] = (det * Kf);
					data[KMASS + 2] = (det * -Kc);
					data[KMASS + 5] = (det * Ka);

					// Consider middle rank seperately.
					if (Kd !== 0) {
						data[KMASS + 3] = (1 / Kd);
					} else {
						data[JACC + 1] = 0;
					}

					data[KMASS + 1] = data[KMASS + 4] = 0;
					return;
				}

				det = ((Kd * Kf) - (Ke * Ke));
				if (det !== 0) {
					// Invert matrix ignoring top rank
					// [#  #  #]
					// [# Kd Ke]
					// [# Ke Kf]
					det = (1 / det);
					data[KMASS + 3] = (det * Kf);
					data[KMASS + 4] = (det * -Ke);
					data[KMASS + 5] = (det * Kd);

					// Consider top rank seperately.
					if (Ka !== 0) {
						data[KMASS] = (1 / Ka);
					} else {
						data[JACC] = 0;
					}

					data[KMASS + 1] = data[KMASS + 2] = 0;
					return;
				}

				// Consider all ranks seperately
				if (Ka !== 0) {
					data[KMASS] = (1 / Ka);
				} else {
					data[JACC] = 0;
				}

				if (Kd !== 0) {
					data[KMASS + 3] = (1 / Kd);
				} else {
					data[JACC + 1] = 0;
				}

				if (Kf !== 0) {
					data[KMASS + 5] = (1 / Kf);
				} else {
					data[JACC + 2] = 0;
				}

				data[KMASS + 1] = data[KMASS + 2] = data[KMASS + 4] = 0;
			} else {
				// Full matrix inversion.
				det = (1 / det);
				data[KMASS] = (det * A);
				data[KMASS + 1] = (det * B);
				data[KMASS + 2] = (det * C);
				data[KMASS + 3] = (det * ((Ka * Kf) - (Kc * Kc)));
				data[KMASS + 4] = (det * ((Kb * Kc) - (Ka * Ke)));
				data[KMASS + 5] = (det * ((Ka * Kd) - (Kb * Kb)));
			}
		};
		return Physics2DConstraint;
})

// =========================================================================
//
// Angle Constraint
//
// ANGLE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*ANGLE_JOINTMIN*/5 // Joint limits
///*ANGLE_JOINTMAX*/6 //
///*ANGLE_RATIO*/7    // Angle ratio for constraint
///*ANGLE_KMASS*/8    // Effective mass matrix (Scalar)
///*ANGLE_JACC*/9     // Accumulated impulse
///*ANGLE_JMAX*/10    // Maximum impulse (maxForce derived)
///*ANGLE_GAMMA*/11   // Gamma for soft constraint
///*ANGLE_BIAS*/12    // Bias for soft constraint (scalar)
///*ANGLE_SCALE*/13   // Scaling for impulse direction.
//
///*ANGLE_DATA_SIZE*/14
define(
	'spell/physics/2D/AngleConstraint',
	[
		'spell/physics/2D/Constraint',
		'spell/physics/2D/Config',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConstraint,
		Physics2DConfig,
		Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DAngleConstraint = function() {
				Physics2DConstraint.apply(this, arguments);
				this.type = "ANGLE";
				this.dimension = 1;
				// =======================================================
				// Inherited
				this._JACC = (/*ANGLE_JACC*/ 9);
			}
			__extends(Physics2DAngleConstraint, Physics2DConstraint);

			// ===============================================
			Physics2DAngleConstraint.prototype.getLowerBound = function () {
				return this._data[(/*ANGLE_JOINTMIN*/ 5)];
			};
			Physics2DAngleConstraint.prototype.getUpperBound = function () {
				return this._data[(/*ANGLE_JOINTMAX*/ 6)];
			};
			Physics2DAngleConstraint.prototype.getRatio = function () {
				return this._data[(/*ANGLE_RATIO*/ 7)];
			};

			Physics2DAngleConstraint.prototype.setLowerBound = function (lowerBound) {
				var data = this._data;
				if (data[(/*ANGLE_JOINTMIN*/ 5)] !== lowerBound) {
					data[(/*ANGLE_JOINTMIN*/ 5)] = lowerBound;
					this._equal = (lowerBound === data[(/*ANGLE_JOINTMAX*/ 6)]);
					this.wake(true);
				}
			};
			Physics2DAngleConstraint.prototype.setUpperBound = function (upperBound) {
				var data = this._data;
				if (data[(/*ANGLE_JOINTMAX*/ 6)] !== upperBound) {
					data[(/*ANGLE_JOINTMAX*/ 6)] = upperBound;
					this._equal = (upperBound === data[(/*ANGLE_JOINTMIN*/ 5)]);
					this.wake(true);
				}
			};
			Physics2DAngleConstraint.prototype.setRatio = function (ratio) {
				var data = this._data;
				if (data[(/*ANGLE_RATIO*/ 7)] !== ratio) {
					data[(/*ANGLE_RATIO*/ 7)] = ratio;
					this.wake(true);
				}
			};

			Physics2DAngleConstraint.prototype._posError = function () {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				var ratio = data[(/*ANGLE_RATIO*/ 7)];
				var jointMin = data[(/*ANGLE_JOINTMIN*/ 5)];
				var jointMax = data[(/*ANGLE_JOINTMAX*/ 6)];

				var err = ((ratio * b2[(/*BODY_POS*/ 2) + 2]) - b1[(/*BODY_POS*/ 2) + 2]);
				if (this._equal) {
					err -= jointMax;
					this._slack = false;
					data[(/*ANGLE_SCALE*/ 13)] = 1;
				} else {
					if (err < jointMin) {
						err = (jointMin - err);
						this._slack = false;
						data[(/*ANGLE_SCALE*/ 13)] = -1;
					} else if (err > jointMax) {
						err -= jointMax;
						this._slack = false;
						data[(/*ANGLE_SCALE*/ 13)] = 1;
					} else {
						err = 0;
						this._slack = true;
						data[(/*ANGLE_SCALE*/ 13)] = 0;
					}
				}
				data[(/*ANGLE_BIAS*/ 12)] = (-err);
			};

			Physics2DAngleConstraint.prototype._preStep = function (deltaTime) {
				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				// Compute effective mass before existing on _slack
				// As effective-mass is not recomputed in iteratePos
				// for stiff constraints.
				var ratio = data[(/*ANGLE_RATIO*/ 7)];

				// Compute non-inverted effective mass.
				var ii1 = b1[(/*BODY_IINERTIA*/ 1)];
				var ii2 = b2[(/*BODY_IINERTIA*/ 1)];
				data[(/*ANGLE_KMASS*/ 8)] = ii1 + (ratio * ratio * ii2);

				// Invert effective mass
				Physics2DConstraint.prototype.safe_invert(data, (/*ANGLE_KMASS*/ 8), (/*ANGLE_JACC*/ 9));

				this._posError();
				if (this._slack) {
					return false;
				}

				if (!this._stiff) {
					if (Physics2DConstraint.prototype.soft_params(data, (/*ANGLE_KMASS*/ 8), (/*ANGLE_GAMMA*/ 11), (/*ANGLE_BIAS*/ 12), deltaTime, this._breakUnderError)) {
						return true;
					}
				} else {
					data[(/*ANGLE_GAMMA*/ 11)] = 0;
					data[(/*ANGLE_BIAS*/ 12)] = 0;
				}

				var dtRatio = Physics2DConstraint.prototype.dtRatio(data, deltaTime);
				data[(/*ANGLE_JACC*/ 9)] *= dtRatio;
				data[(/*ANGLE_JMAX*/ 10)] = (data[(/*JOINT_MAX_FORCE*/ 2)] * deltaTime);

				return false;
			};

			Physics2DAngleConstraint.prototype._warmStart = function () {
				if (this._slack) {
					return;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				var j = (data[(/*ANGLE_JACC*/ 9)] * data[(/*ANGLE_SCALE*/ 13)]);
				b1[(/*BODY_VEL*/ 7) + 2] -= (j * b1[(/*BODY_IINERTIA*/ 1)]);
				b2[(/*BODY_VEL*/ 7) + 2] += (j * data[(/*ANGLE_RATIO*/ 7)] * b2[(/*BODY_IINERTIA*/ 1)]);
			};

			Physics2DAngleConstraint.prototype.getImpulseForBody = function (body, dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(3);
				}

				var data = this._data;
				var j = (data[(/*ANGLE_JACC*/ 9)] * data[(/*ANGLE_SCALE*/ 13)]);

				dst[0] = dst[1] = 0;
				dst[2] = (body === this.bodyA ? -1 : (body === this.bodyB ? data[(/*ANGLE_RATIO*/ 7)] : 0)) * j;

				return dst;
			};

			Physics2DAngleConstraint.prototype._iterateVel = function () {
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				// x = Bias - VelocityError
				var scale = data[(/*ANGLE_SCALE*/ 13)];
				var ratio = data[(/*ANGLE_RATIO*/ 7)];
				var x = (data[(/*ANGLE_BIAS*/ 12)] - (scale * ((ratio * b2[(/*BODY_VEL*/ 7) + 2]) - b1[(/*BODY_VEL*/ 7) + 2])));

				var jOld = data[(/*ANGLE_JACC*/ 9)];

				// Impulse.
				// j = K * x - Jacc * gamma
				var j = (data[(/*ANGLE_KMASS*/ 8)] * x) - (jOld * data[(/*ANGLE_GAMMA*/ 11)]);

				// Accumulate and clamp
				var jAcc = (jOld + j);
				var jMax = data[(/*ANGLE_JMAX*/ 10)];
				if (this._breakUnderForce) {
					if (jAcc > jMax || jAcc < -jMax) {
						return true;
					} else if (!this._equal && jAcc > 0) {
						jAcc = 0;
					}
				} else if (!this._stiff) {
					if (!this._equal) {
						if (jAcc > 0) {
							jAcc = 0;
						} else if (jAcc < -jMax) {
							jAcc = -jMax;
						}
					} else {
						if (jAcc > jMax) {
							jAcc = jMax;
						} else if (jAcc < -jMax) {
							jAcc = -jMax;
						}
					}
				} else if (!this._equal && jAcc > 0) {
					jAcc = 0;
				}

				j = (jAcc - jOld);
				data[(/*ANGLE_JACC*/ 9)] = jAcc;

				// Apply impulse
				j *= scale;
				b1[(/*BODY_VEL*/ 7) + 2] -= (j * b1[(/*BODY_IINERTIA*/ 1)]);
				b2[(/*BODY_VEL*/ 7) + 2] += (j * ratio * b2[(/*BODY_IINERTIA*/ 1)]);

				return false;
			};

			Physics2DAngleConstraint.prototype._iteratePos = function () {
				this._posError();
				if (this._slack) {
					return false;
				}

				var data = this._data;
				var err = data[(/*ANGLE_BIAS*/ 12)];
				var maxError = data[(/*JOINT_MAX_ERROR*/ 3)];
				if (this._breakUnderError && (err > maxError || err < -maxError)) {
					return true;
				}

				var slop = Physics2DConfig.ANGLE_SLOP_SQ;
				if ((err * err) < slop) {
					return false;
				}

				err *= Physics2DConfig.ANGLE_BIAS_COEF;
				var j = (err * Physics2DConfig.ANGLE_BIAS_COEF * data[(/*ANGLE_KMASS*/ 8)]);

				if (this._equal || j < 0) {
					var b = this.bodyA;
					j *= data[(/*ANGLE_SCALE*/ 13)];
					var dr = (-j * b._data[(/*BODY_IINERTIA*/ 1)]);
					if (dr !== 0) {
						b._deltaRotation(dr);
					}

					b = this.bodyB;
					dr = (j * b._data[(/*BODY_IINERTIA*/ 1)]);
					if (dr !== 0) {
						b._deltaRotation(dr);
					}
				}

				return false;
			};

			// params = {
			//   bodyA, bodyB,
			//   lowerBound, upperBound, ratio
			//   ... common constraint params
			// }
			Physics2DAngleConstraint.create = function (params) {
				var p = new Physics2DAngleConstraint();
				var data = p._data = Types.createFloatArray((/*ANGLE_DATA_SIZE*/ 14));
				Physics2DConstraint.prototype.init(p, params);

				data[(/*ANGLE_RATIO*/ 7)] = (params.ratio !== undefined ? params.ratio : 1);
				var min = data[(/*ANGLE_JOINTMIN*/ 5)] = (params.lowerBound !== undefined ? params.lowerBound : 0);
				var max = data[(/*ANGLE_JOINTMAX*/ 6)] = (params.upperBound !== undefined ? params.upperBound : 0);
				p._equal = (min === max);

				p._slack = false;

				p.bodyA = params.bodyA;
				p.bodyB = params.bodyB;

				return p;
			};

			// Inherited
			Physics2DAngleConstraint.prototype._inWorld = Physics2DConstraint.prototype.twoBodyInWorld;
			Physics2DAngleConstraint.prototype._outWorld = Physics2DConstraint.prototype.twoBodyOutWorld;
			Physics2DAngleConstraint.prototype._pairExists = Physics2DConstraint.prototype.twoBodyPairExists;
			Physics2DAngleConstraint.prototype._wakeConnected = Physics2DConstraint.prototype.twoBodyWakeConnected;
			Physics2DAngleConstraint.prototype._sleepComputation = Physics2DConstraint.prototype.twoBodySleepComputation;


			Physics2DAngleConstraint.prototype._draw = function angleDrawFn(debug) {
				var colA = (this.sleeping ? debug.constraintSleepingColorA : debug.constraintColorA);
				var colB = (this.sleeping ? debug.constraintSleepingColorB : debug.constraintColorB);
				var colSA = (this.sleeping ? debug.constraintErrorSleepingColorA : debug.constraintErrorColorA);
				var colSB = (this.sleeping ? debug.constraintErrorSleepingColorB : debug.constraintErrorColorB);

				var data = this._data;
				var b1 = this.bodyA._data;
				var b2 = this.bodyB._data;

				var ratio = data[(/*ANGLE_RATIO*/ 7)];
				this._drawForBody(debug, b1, b2, ratio, -1, colSA, colSB, colA);
				this._drawForBody(debug, b2, b1, (1 / ratio), (1 / ratio), colSA, colSB, colB);
			};

			Physics2DAngleConstraint.prototype._drawForBody = function _drawForBodyFn(debug, b1, b2, bodyScale, limitScale, colA, colB, col) {
				var data = this._data;
				var jointMin = data[(/*ANGLE_JOINTMIN*/ 5)];
				var jointMax = data[(/*ANGLE_JOINTMAX*/ 6)];

				var min = (b2[(/*BODY_POS*/ 2) + 2] * bodyScale) + (jointMin * limitScale);
				var max = (b2[(/*BODY_POS*/ 2) + 2] * bodyScale) + (jointMax * limitScale);
				if (min > max) {
					var tmp = min;
					min = max;
					max = tmp;
				}

				var minRadius = (debug.constraintSpiralMinRadius * debug.screenToPhysics2D);
				var deltaRadius = (debug.constraintSpiralDeltaRadius * debug.screenToPhysics2D);
				var indicatorSize = (debug.constraintAnchorRadius * debug.screenToPhysics2D);
				var numCoils = debug.constraintSpiralNumCoils;

				var x = b1[(/*BODY_POS*/ 2)];
				var y = b1[(/*BODY_POS*/ 2) + 1];
				var rot = b1[(/*BODY_POS*/ 2) + 2];

				var dr;
				if (rot > min) {
					dr = Math.min(rot, max);
					debug.drawSpiral(x, y, min, dr, minRadius, minRadius + ((dr - min) * deltaRadius), colA);
				} else if (!this._stiff && rot < min) {
					debug.drawSpiralSpring(x, y, rot, min, minRadius + ((rot - min) * deltaRadius), minRadius, numCoils, colA);
				}

				if (rot < max) {
					dr = Math.max(rot, min);
					debug.drawSpiral(x, y, dr, max, minRadius + ((dr - min) * deltaRadius), minRadius + ((max - min) * deltaRadius), colB);
				} else if (!this._stiff && rot > max) {
					debug.drawSpiralSpring(x, y, rot, max, minRadius + ((rot - min) * deltaRadius), minRadius + ((max - min) * deltaRadius), numCoils, colB);
				}

				debug._drawAngleIndicator(x, y, rot, minRadius + ((rot - min) * deltaRadius), indicatorSize, col);
			};

			return Physics2DAngleConstraint;
})

define(
	'spell/physics/2D/Callback',
	[
	],
	function() {
		var Physics2DCallback = function() {
			// All events
			this.thisObject = null;
			this.callback = null;

			// Used to ensure time ordering of deferred events.
			// -1 if event corresponds to action performed before step()
			// 0  if event is a standard event during step()
			// 1  if event is result of a continuous collision during step()
			this.time = 0;

			// Interaction events
			this.index = 0;
			this.arbiter = null;

			this.next = null;
		}
		Physics2DCallback.allocate = function () {
			if (Physics2DCallback.pool) {
				var ret = Physics2DCallback.pool;
				Physics2DCallback.pool = ret.next;
				ret.next = null;
				return ret;
			} else {
				return (new Physics2DCallback());
			}
		};

		Physics2DCallback.deallocate = function (callback) {
			callback.next = Physics2DCallback.pool;
			Physics2DCallback.pool = callback;

			callback.thisObject = null;
			callback.callback = null;
			callback.arbiter = null;
		};
		Physics2DCallback.pool = null;
		return Physics2DCallback;
})

define(
	'spell/physics/2D/Island',
	[
	],
	function() {
		var Physics2DIsland = function() {
			this.components = [];
			this.sleeping = false;
			this.wakeTime = 0;
			this.next = null;
		}
		Physics2DIsland.allocate = function () {
			if (Physics2DIsland.pool) {
				var ret = Physics2DIsland.pool;
				Physics2DIsland.pool = ret.next;
				ret.next = null;
				return ret;
			} else {
				return (new Physics2DIsland());
			}
		};

		Physics2DIsland.deallocate = function (island) {
			island.next = Physics2DIsland.pool;
			Physics2DIsland.pool = island;
			island.wakeTime = 0;
		};
		Physics2DIsland.pool = null;

		return Physics2DIsland;
})



// =====================================================================
//
// Physics2D TOI Event
//
// TOI DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*TOI_AXIS*/0       - seperating/MTV axis (x, y)
///*TOI_WITNESS_A*/2  - witness on shape A (x, y)
///*TOI_WITNESS_B*/4  - witness on shape B (x, y)
///*TOI_TOI_ALPHA*/6  - time of impact.
//
///*TOI_DATA_SIZE*/7
define(
	'spell/physics/2D/TOIEvent',
	[
		'spell/shared/util/platform/Types'
	],
	function( Types ) {

		var Physics2DTOIEvent = function() {
			this.next = null;
			this.shapeA = null;
			this.shapeB = null;
			this.frozenA = this.frozenB = false;
			this.arbiter = null;
			this.failed = false;
			this.slipped = false;
			this._data = Types.createFloatArray((/*TOI_DATA_SIZE*/ 7));
		}

		Physics2DTOIEvent.allocate = function () {
			if (Physics2DTOIEvent.pool) {
				var ret = Physics2DTOIEvent.pool;
				Physics2DTOIEvent.pool = ret.next;
				ret.next = null;
				return ret;
			} else {
				return (new Physics2DTOIEvent());
			}
		};

		Physics2DTOIEvent.deallocate = function (toi) {
			toi.next = Physics2DTOIEvent.pool;
			Physics2DTOIEvent.pool = toi;

			toi.shapeA = toi.shapeB = null;
			toi.failed = false;
			toi.slipped = false;
			toi.arbiter = null;
		};
		Physics2DTOIEvent.pool = null;
		return Physics2DTOIEvent;
});


// =========================================================================
//
// Physics2D internal collision detection routines.
//
define(
	'spell/physics/2D/CollisionUtils',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/TOIEvent'
	],
	function( Physics2DConfig, Physics2DTOIEvent ) {

		var Physics2DCollisionUtils = function() {
		}
		Physics2DCollisionUtils.prototype.containsPoint = function (shape, point /*v2*/ ) {
			shape.body._update();
			return this._contains(shape, point[0], point[1]);
		};

		Physics2DCollisionUtils.prototype.signedDistance = function (shapeA, shapeB, witnessA /*v2*/ , witnessB /*v2*/ , axis /*v2*/ ) {
			shapeA.body._update();
			if (shapeB.body !== shapeA.body) {
				shapeB.body._update();
			}

			var data = this._toi._data;
			var ret = this._distance(shapeA, shapeB, data);
			witnessA[0] = data[(/*TOI_WITNESS_A*/ 2)];
			witnessA[1] = data[(/*TOI_WITNESS_A*/ 2) + 1];
			witnessB[0] = data[(/*TOI_WITNESS_B*/ 4)];
			witnessB[1] = data[(/*TOI_WITNESS_B*/ 4) + 1];
			axis[0] = data[(/*TOI_AXIS*/ 0)];
			axis[1] = data[(/*TOI_AXIS*/ 0) + 1];

			return ret;
		};

		Physics2DCollisionUtils.prototype.intersects = function (shapeA, shapeB) {
			shapeA.body._update();
			if (shapeB.body !== shapeA.body) {
				shapeB.body._update();
			}

			return this._test(shapeA, shapeB);
		};

		Physics2DCollisionUtils.prototype.rayTest = function (shape, ray, normal /*v2*/ , ignoreInnerSurfaces) {
			shape.body._update();
			return this._rayTest(shape, ray, normal, ignoreInnerSurfaces);
		};

		Physics2DCollisionUtils.prototype.sweepTest = function (shapeA, shapeB, deltaTime, point /*v2*/ , normal /*v2*/ ) {
			var toi = this._toi;
			toi.shapeA = shapeA;
			toi.shapeB = shapeB;

			var bodyA = shapeA.body;
			var bodyB = shapeB.body;
			var dataA = bodyA._data;
			var dataB = bodyB._data;
			dataA[(/*BODY_SWEEP_TIME*/ 18)] = 0;
			dataB[(/*BODY_SWEEP_TIME*/ 18)] = 0;
			dataA[(/*BODY_SWEEP_ANGVEL*/ 20)] = (dataA[(/*BODY_VEL*/ 7) + 2]);
			dataB[(/*BODY_SWEEP_ANGVEL*/ 20)] = (dataB[(/*BODY_VEL*/ 7) + 2]);
			var ret = this._dynamicSweep(toi, deltaTime, 0, true);
			bodyA._sweepIntegrate(0);
			bodyB._sweepIntegrate(0);
			shapeA._update(dataA[(/*BODY_POS*/ 2)], dataA[(/*BODY_POS*/ 2) + 1], dataA[(/*BODY_AXIS*/ 5)], dataA[(/*BODY_AXIS*/ 5) + 1]);
			shapeB._update(dataB[(/*BODY_POS*/ 2)], dataB[(/*BODY_POS*/ 2) + 1], dataB[(/*BODY_AXIS*/ 5)], dataB[(/*BODY_AXIS*/ 5) + 1]);

			if (ret < 0) {
				return undefined;
			}

			var data = toi._data;
			point[0] = (0.5 * (data[(/*TOI_WITNESS_A*/ 2)] + data[(/*TOI_WITNESS_B*/ 4)]));
			point[1] = (0.5 * (data[(/*TOI_WITNESS_A*/ 2) + 1] + data[(/*TOI_WITNESS_B*/ 4) + 1]));
			normal[0] = data[(/*TOI_AXIS*/ 0)];
			normal[1] = data[(/*TOI_AXIS*/ 0) + 1];
			return (ret * deltaTime);
		};

		//=======================================================================================
		//=======================================================================================
		// Private.
		// Test if (parametric) ray intersects
		// Shape between 0 and ray.maxFactor
		// Assume shape has been updated by a Body.
		// (need not be 'in' a body).
		Physics2DCollisionUtils.prototype._rayTest = function (shape, ray, normal, noInner) {
			if (shape._type === (/*TYPE_CIRCLE*/ 0)) {
				return this._rayTestCircle(shape, ray, normal, noInner);
			} else {
				return this._rayTestPolygon(shape, ray, normal, noInner);
			}
		};

		Physics2DCollisionUtils.prototype._rayTestPolygon = function (poly, ray, normal, noInner) {
			var origin = ray.origin;
			var direction = ray.direction;
			var data = poly._data;

			var ox = origin[0];
			var oy = origin[1];
			var dx = direction[0];
			var dy = direction[1];

			var min = ray.maxFactor;
			var edge, inner;

			var index = (/*POLY_VERTICES*/ 6);
			var limit = data.length;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var nx = data[index + (/*POLY_WNORMAL*/ 6)];
				var ny = data[index + (/*POLY_WNORMAL*/ 6) + 1];
				var den = (nx * dx) + (ny * dy);
				if ((den >= 0 && noInner) || (den * den) < Physics2DConfig.COLLINEAR_SQ_EPSILON) {
					continue;
				}

				var t = (data[index + (/*POLY_WPROJ*/ 9)] - ((ox * nx) + (oy * ny))) / den;
				if (t < 0 || t >= min) {
					continue;
				}

				var hitX = ox + (dx * t);
				var hitY = oy + (dy * t);
				var dproj = (nx * hitY) - (ny * hitX);
				if (dproj < data[index + (/*POLY_CROSS1*/ 10)] || dproj > data[index + (/*POLY_CROSS2*/ 11)]) {
					continue;
				}

				min = t;
				edge = index;
				inner = (den >= 0);
			}

			if (edge === undefined) {
				return undefined;
			} else {
				var scale = (inner ? -1 : 1);
				normal[0] = (data[edge + (/*POLY_WNORMAL*/ 6)] * scale);
				normal[1] = (data[edge + (/*POLY_WNORMAL*/ 6) + 1] * scale);
				return min;
			}
		};

		Physics2DCollisionUtils.prototype._rayTestCircle = function (circle, ray, normal, noInner) {
			var origin = ray.origin;
			var direction = ray.direction;
			var data = circle._data;

			var ox = origin[0];
			var oy = origin[1];
			var dx = direction[0];
			var dy = direction[1];
			var cx = data[(/*CIRCLE_WORLD*/ 9)];
			var cy = data[(/*CIRCLE_WORLD*/ 9) + 1];
			var radius = data[(/*CIRCLE_RADIUS*/ 6)];

			var ocX = (ox - cx);
			var ocY = (oy - cy);

			// Quadratic equation at^2 + bt + c = 0
			var a = ((dx * dx) + (dy * dy));
			var b = 2 * ((ocX * dx) + (ocY * dy));
			var c = (ocX * ocX) + (ocY * ocY) - (radius * radius);

			var determinant = ((b * b) - (4 * a * c));
			if (determinant < 0) {
				return undefined;
			}

			var normalScale = 1.0;
			var rec = (1 / (2 * a));
			var rootD = Math.sqrt(determinant);
			var distance = ((-b - rootD) * rec);
			if (distance < 0) {
				if (noInner) {
					return undefined;
				}
				distance += (rootD * 2 * rec);
				normalScale = -1.0;
			}

			if (0 <= distance && distance < ray.maxFactor) {
				var hitX = (ox + (dx * distance) - cx);
				var hitY = (oy + (dy * distance) - cy);
				var scale = (normalScale / radius);
				normal[0] = (hitX * scale);
				normal[1] = (hitY * scale);
				return distance;
			} else {
				return undefined;
			}
		};

		// =====================================================================
		// Test point containment in shape.
		// no AABB check is performed.
		// Assume shape has been updated by a Body.
		// (need not be 'in' a body).
		Physics2DCollisionUtils.prototype._contains = function (shape, x, y) {
			if (shape._type === (/*TYPE_CIRCLE*/ 0)) {
				return this._containsCircle(shape, x, y);
			} else {
				return this._containsPolygon(shape, x, y);
			}
		};

		Physics2DCollisionUtils.prototype._containsCircle = function (circle, x, y) {
			var data = circle._data;
			var dx = (data[(/*CIRCLE_WORLD*/ 9)] - x);
			var dy = (data[(/*CIRCLE_WORLD*/ 9) + 1] - y);
			var rad = data[(/*CIRCLE_RADIUS*/ 6)];
			return ((dx * dx) + (dy * dy) - (rad * rad)) <= Physics2DConfig.CONTAINS_SQ_EPSILON;
		};

		Physics2DCollisionUtils.prototype._containsPolygon = function (poly, x, y) {
			var data = poly._data;
			var index = (/*POLY_VERTICES*/ 6);
			var limit = data.length;
			var EPS = Physics2DConfig.CONTAINS_EPSILON;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var proj = ((data[index + (/*POLY_WNORMAL*/ 6)] * x) + (data[index + (/*POLY_WNORMAL*/ 6) + 1] * y)) - data[index + (/*POLY_WPROJ*/ 9)];
				if (proj > EPS) {
					return false;
				}
			}
			return true;
		};

		// =====================================================================
		// slowSweep is true when method is invoked from public API.
		// Or in convexSweep to be more accurate and fail less easily.
		// This is also to disable slipping TOI's and terminate as soon
		// as objects intersect.
		Physics2DCollisionUtils.prototype._dynamicSweep = function (toi, timeStep, negRadius, slowSweep) {
			var s1 = toi.shapeA;
			var s2 = toi.shapeB;
			var b1 = s1.body;
			var b2 = s2.body;
			var data1 = b1._data;
			var data2 = b2._data;

			// relative linear velocity and angular bias for distance calculation.
			var deltaX = (data2[(/*BODY_VEL*/ 7)] - data1[(/*BODY_VEL*/ 7)]);
			var deltaY = (data2[(/*BODY_VEL*/ 7) + 1] - data1[(/*BODY_VEL*/ 7) + 1]);
			var ang1 = data1[(/*BODY_SWEEP_ANGVEL*/ 20)];
			var ang2 = data2[(/*BODY_SWEEP_ANGVEL*/ 20)];
			var angBias = ((s1._data[(/*SHAPE_SWEEP_FACTOR*/ 5)] * (ang1 < 0 ? -ang1 : ang1)) + (s2._data[(/*SHAPE_SWEEP_FACTOR*/ 5)] * (ang2 < 0 ? -ang2 : ang2)));

			// If relative linear velocity is near zero
			// and angular bias is near zero, ignore continuous pair.
			if (!slowSweep) {
				if (((deltaX * deltaX) + (deltaY * deltaY)) < Physics2DConfig.EQUAL_SQ_VEL && angBias < Physics2DConfig.ZERO_ANG_BIAS) {
					toi._data[(/*TOI_TOI_ALPHA*/ 6)] = undefined;
					toi.failed = true;
					return;
				}
			}

			var curTOIAlpha = 0;
			var curIter = 0;
			var toiData = toi._data;

			var LIMIT = Physics2DConfig.SWEEP_LIMIT;
			var HALF_LIMIT = (LIMIT * 0.5);
			var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
			var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;

			while (true) {
				b1._sweepIntegrate(curTOIAlpha * timeStep);
				b2._sweepIntegrate(curTOIAlpha * timeStep);
				var posX = data1[(/*BODY_POS*/ 2)];
				var posY = data1[(/*BODY_POS*/ 2) + 1];
				s1._update(posX, posY, data1[(/*BODY_AXIS*/ 5)], data1[(/*BODY_AXIS*/ 5) + 1], true);
				posX = data2[(/*BODY_POS*/ 2)];
				posY = data2[(/*BODY_POS*/ 2) + 1];
				s2._update(posX, posY, data2[(/*BODY_AXIS*/ 5)], data2[(/*BODY_AXIS*/ 5) + 1], true);

				var sep = this._distance(s1, s2, toiData) + negRadius;
				var axisX = toiData[(/*TOI_AXIS*/ 0)];
				var axisY = toiData[(/*TOI_AXIS*/ 0) + 1];
				var dot = ((axisX * deltaX) + (axisY * deltaY));

				// Objects intersecting!
				if (sep < LIMIT) {
					if (slowSweep) {
						break;
					} else {
						var d1X = (toiData[(/*TOI_WITNESS_A*/ 2)] - posX);
						var d1Y = (toiData[(/*TOI_WITNESS_A*/ 2) + 1] - posY);
						var proj = (dot - (ang1 * ((d1X * axisY) - (d1Y * axisX))));

						// Terminate if velocity at witness indicates a non-seperating contact
						// Or if the penetration is too deep.
						//
						// Otherwise we continue and try to get a better collision time
						// To permit fast-rotation of a box about a vertex in collision.
						// (#)
						if (proj > 0) {
							toi.slipped = true;
						}
						if (proj <= 0 || sep < HALF_LIMIT) {
							break;
						}
					}
				}

				// Lower bound on TOI advancement
				var denom = (angBias - dot) * timeStep;
				if (denom <= 0) {
					// fail.
					curTOIAlpha = -1;
					break;
				}

				var delta = (sep / denom);

				// Permit small advancement when objects are already intersecting (#)
				// As well as to avoid failing when a box is rotating with its face
				// parallel to the other collider so that delta is roughly 0.
				//
				// This also helps with performance.
				if (delta < MIN_ADVANCE) {
					delta = MIN_ADVANCE;
				}

				curTOIAlpha += delta;
				if (curTOIAlpha >= 1) {
					// fail
					curTOIAlpha = -1;
					break;
				}

				curIter += 1;
				if (curIter >= MAX_ITER) {
					// If presently intersecting (ignoring slop)
					// Then we mark objects to have their angular
					// velocity set to 0 and permit tunnelling even
					// though we failed to reach tolerance.
					if (sep > negRadius) {
						toi.failed = true;
					} else if (slowSweep) {
						// fail
						curTOIAlpha = -1;
					}
					break;
				}
			}

			toiData[(/*TOI_TOI_ALPHA*/ 6)] = curTOIAlpha;
			return curTOIAlpha;
		};

		Physics2DCollisionUtils.prototype._staticSweep = function (toi, timeStep, negRadius) {
			var s1 = toi.shapeA;
			var s2 = toi.shapeB;
			var b1 = s1.body;
			var data1 = b1._data;

			// relative linear velocity and angular bias for distance calculation.
			var deltaX = -data1[(/*BODY_VEL*/ 7)];
			var deltaY = -data1[(/*BODY_VEL*/ 7) + 1];
			var ang1 = data1[(/*BODY_SWEEP_ANGVEL*/ 20)];
			var angBias = (s1._data[(/*SHAPE_SWEEP_FACTOR*/ 5)] * (ang1 < 0 ? -ang1 : ang1));

			var curTOIAlpha = 0;
			var curIter = 0;
			var toiData = toi._data;

			var LIMIT = Physics2DConfig.SWEEP_LIMIT;
			var HALF_LIMIT = (LIMIT * 0.5);
			var MIN_ADVANCE = Physics2DConfig.MINIMUM_SWEEP_ADVANCE;
			var MAX_ITER = Physics2DConfig.MAX_SWEEP_ITER;

			while (true) {
				b1._sweepIntegrate(curTOIAlpha * timeStep);
				var posX = data1[(/*BODY_POS*/ 2)];
				var posY = data1[(/*BODY_POS*/ 2) + 1];
				s1._update(posX, posY, data1[(/*BODY_AXIS*/ 5)], data1[(/*BODY_AXIS*/ 5) + 1], true);

				var sep = this._distance(s1, s2, toiData) + negRadius;
				var axisX = toiData[(/*TOI_AXIS*/ 0)];
				var axisY = toiData[(/*TOI_AXIS*/ 0) + 1];
				var dot = ((axisX * deltaX) + (axisY * deltaY));

				// Objects intersecting!
				if (sep < LIMIT) {
					var d1X = (toiData[(/*TOI_WITNESS_A*/ 2)] - posX);
					var d1Y = (toiData[(/*TOI_WITNESS_A*/ 2) + 1] - posY);
					var proj = (dot - (ang1 * ((d1X * axisY) - (d1Y * axisX))));

					// Terminate if velocity at witness indicates a non-seperating contact
					// Or if the penetration is too deep.
					//
					// Otherwise we continue and try to get a better collision time
					// To permit fast-rotation of a box about a vertex in collision.
					// (#)
					if (proj > 0) {
						toi.slipped = true;
					}
					if (proj <= 0 || sep < HALF_LIMIT) {
						break;
					}
				}

				// Lower bound on TOI advancement
				var denom = (angBias - dot) * timeStep;
				if (denom <= 0) {
					// fail.
					curTOIAlpha = -1;
					break;
				}

				var delta = (sep / denom);

				// Permit small advancement when objects are already intersecting (#)
				// As well as to avoid failing when a box is rotating with its face
				// parallel to the other collider so that delta is roughly 0.
				//
				// This also helps with performance.
				if (delta < MIN_ADVANCE) {
					delta = MIN_ADVANCE;
				}

				curTOIAlpha += delta;
				if (curTOIAlpha >= 1) {
					// fail
					curTOIAlpha = -1;
					break;
				}

				curIter += 1;
				if (curIter >= MAX_ITER) {
					// If presently intersecting (ignoring slop)
					// Then we mark objects to have their angular
					// velocity set to 0 and permit tunnelling even
					// though we failed to reach tolerance.
					if (sep > negRadius) {
						toi.failed = true;
					}
					break;
				}
			}

			toiData[(/*TOI_TOI_ALPHA*/ 6)] = curTOIAlpha;
			return curTOIAlpha;
		};

		// =====================================================================
		// Assumption, shapes have been updated by body.
		// need not be IN a body.
		Physics2DCollisionUtils.prototype._distance = function (shapeA, shapeB, toiData) {
			if (shapeA._type === (/*TYPE_CIRCLE*/ 0)) {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					return this._distanceCircle2Circle(shapeA, shapeB, toiData);
				} else {
					return this._distanceCircle2Polygon(shapeA, shapeB, toiData);
				}
			} else {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					var ret = this._distanceCircle2Polygon(shapeB, shapeA, toiData);

					// Reverse axis.
					toiData[(/*TOI_AXIS*/ 0)] = -toiData[(/*TOI_AXIS*/ 0)];
					toiData[(/*TOI_AXIS*/ 0) + 1] = -toiData[(/*TOI_AXIS*/ 0) + 1];

					// Swap witness points.
					var tmp = toiData[(/*TOI_WITNESS_A*/ 2)];
					toiData[(/*TOI_WITNESS_A*/ 2)] = toiData[(/*TOI_WITNESS_B*/ 4)];
					toiData[(/*TOI_WITNESS_B*/ 4)] = tmp;

					tmp = toiData[(/*TOI_WITNESS_A*/ 2) + 1];
					toiData[(/*TOI_WITNESS_A*/ 2) + 1] = toiData[(/*TOI_WITNESS_B*/ 4) + 1];
					toiData[(/*TOI_WITNESS_B*/ 4) + 1] = tmp;
					return ret;
				} else {
					return this._distancePolygon2Polygon(shapeA, shapeB, toiData);
				}
			}
		};

		Physics2DCollisionUtils.prototype._distanceCircle2Circle = function (circleA, circleB, toiData) {
			var dataA = circleA._data;
			var dataB = circleB._data;

			var cAX = dataA[(/*CIRCLE_WORLD*/ 9)];
			var cAY = dataA[(/*CIRCLE_WORLD*/ 9) + 1];
			var cBX = dataB[(/*CIRCLE_WORLD*/ 9)];
			var cBY = dataB[(/*CIRCLE_WORLD*/ 9) + 1];
			var radA = dataA[(/*CIRCLE_RADIUS*/ 6)];
			var radB = dataB[(/*CIRCLE_RADIUS*/ 6)];

			var dx = (cBX - cAX);
			var dy = (cBY - cAY);
			var rSum = (radA + radB);

			var len = Math.sqrt((dx * dx) + (dy * dy));
			if (len === 0) {
				toiData[(/*TOI_AXIS*/ 0)] = dx = 1;
				toiData[(/*TOI_AXIS*/ 0) + 1] = dy = 0;
			} else {
				var rec = (1 / len);
				toiData[(/*TOI_AXIS*/ 0)] = (dx *= rec);
				toiData[(/*TOI_AXIS*/ 0) + 1] = (dy *= rec);
			}
			toiData[(/*TOI_WITNESS_A*/ 2)] = cAX + (dx * radA);
			toiData[(/*TOI_WITNESS_A*/ 2) + 1] = cAY + (dy * radA);
			toiData[(/*TOI_WITNESS_B*/ 4)] = cBX - (dx * radB);
			toiData[(/*TOI_WITNESS_B*/ 4) + 1] = cBY - (dy * radB);

			return (len - rSum);
		};

		Physics2DCollisionUtils.prototype._distanceCircle2Polygon = function (circle, polygon, toiData) {
			var dataC = circle._data;
			var dataP = polygon._data;

			var cx = dataC[(/*CIRCLE_WORLD*/ 9)];
			var cy = dataC[(/*CIRCLE_WORLD*/ 9) + 1];
			var radius = dataC[(/*CIRCLE_RADIUS*/ 6)];

			var max = Number.NEGATIVE_INFINITY;
			var edge, proj;

			var index = (/*POLY_VERTICES*/ 6);
			var limit = dataP.length;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				// proj = world-normal dot position
				proj = ((dataP[index + (/*POLY_WNORMAL*/ 6)] * cx) + (dataP[index + (/*POLY_WNORMAL*/ 6) + 1] * cy));
				var dist = proj - (radius + dataP[index + (/*POLY_WPROJ*/ 9)]);
				if (dist > max) {
					max = dist;
					edge = index;
				}
			}

			var nx = dataP[edge + (/*POLY_WNORMAL*/ 6)];
			var ny = dataP[edge + (/*POLY_WNORMAL*/ 6) + 1];
			proj = ((nx * cy) - (ny * cx));
			if (proj >= dataP[edge + (/*POLY_CROSS1*/ 10)]) {
				if (proj <= dataP[edge + (/*POLY_CROSS2*/ 11)]) {
					// circle center is within voronoi region of edge.
					toiData[(/*TOI_AXIS*/ 0)] = -nx;
					toiData[(/*TOI_AXIS*/ 0) + 1] = -ny;
					toiData[(/*TOI_WITNESS_A*/ 2)] = (cx -= (nx * radius));
					toiData[(/*TOI_WITNESS_A*/ 2) + 1] = (cy -= (ny * radius));
					toiData[(/*TOI_WITNESS_B*/ 4)] = (cx - (nx * max));
					toiData[(/*TOI_WITNESS_B*/ 4) + 1] = (cy - (ny * max));
					return max;
				} else {
					// skip to next edge.
					edge += (/*POLY_STRIDE*/ 13);
					if (edge === limit) {
						edge = (/*POLY_VERTICES*/ 6);
					}
				}
			}

			// Perform circle-vertex check.
			var vX = dataP[edge + (/*POLY_WORLD*/ 2)];
			var vY = dataP[edge + (/*POLY_WORLD*/ 2) + 1];
			var dx = (vX - cx);
			var dy = (vY - cy);

			var len = Math.sqrt((dx * dx) + (dy * dy));
			if (len === 0) {
				toiData[(/*TOI_AXIS*/ 0)] = dx = -nx;
				toiData[(/*TOI_AXIS*/ 0) + 1] = dy = -ny;
			} else {
				var rec = (1 / len);
				toiData[(/*TOI_AXIS*/ 0)] = (dx *= rec);
				toiData[(/*TOI_AXIS*/ 0) + 1] = (dy *= rec);
			}
			toiData[(/*TOI_WITNESS_A*/ 2)] = (cx + (dx * radius));
			toiData[(/*TOI_WITNESS_A*/ 2) + 1] = (cy + (dy * radius));
			toiData[(/*TOI_WITNESS_B*/ 4)] = vX;
			toiData[(/*TOI_WITNESS_B*/ 4) + 1] = vY;
			return (len - radius);
		};

		Physics2DCollisionUtils.prototype._distancePolygon2Polygon = function (polyA, polyB, toiData) {
			var inf = Number.POSITIVE_INFINITY;
			var dataA = polyA._data;
			var dataB = polyB._data;

			var limitA = dataA.length;
			var limitB = dataB.length;

			var i, j;
			var min, k, nx, ny;

			var max = -inf;
			var first, edge;

			for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataA[i + (/*POLY_WNORMAL*/ 6)];
				ny = dataA[i + (/*POLY_WNORMAL*/ 6) + 1];
				for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
					k = (nx * dataB[j + (/*POLY_WORLD*/ 2)]) + (ny * dataB[j + (/*POLY_WORLD*/ 2) + 1]);
					if (k < min) {
						min = k;
					}
				}
				min -= dataA[i + (/*POLY_WPROJ*/ 9)];

				if (min > max) {
					max = min;
					edge = i;
					first = true;
				}
			}

			for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataB[j + (/*POLY_WNORMAL*/ 6)];
				ny = dataB[j + (/*POLY_WNORMAL*/ 6) + 1];
				for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
					k = (nx * dataA[i + (/*POLY_WORLD*/ 2)]) + (ny * dataA[i + (/*POLY_WORLD*/ 2) + 1]);
					if (k < min) {
						min = k;
					}
				}
				min -= dataB[j + (/*POLY_WPROJ*/ 9)];

				if (min > max) {
					max = min;
					edge = j;
					first = false;
				}
			}

			// swap data so first polygon owns seperating axis.
			var flip = (first ? 1 : -1);
			var indA, indB;
			if (!first) {
				dataA = polyB._data;
				dataB = polyA._data;
				limitA = dataA.length;
				limitB = dataB.length;
				indA = (/*TOI_WITNESS_B*/ 4);
				indB = (/*TOI_WITNESS_A*/ 2);
			} else {
				indA = (/*TOI_WITNESS_A*/ 2);
				indB = (/*TOI_WITNESS_B*/ 4);
			}

			nx = dataA[edge + (/*POLY_WNORMAL*/ 6)];
			ny = dataA[edge + (/*POLY_WNORMAL*/ 6) + 1];

			// Find witness edge on dataB (not necessarigly polyB)
			min = inf;
			var witness;
			for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
				k = (nx * dataB[j + (/*POLY_WNORMAL*/ 6)]) + (ny * dataB[j + (/*POLY_WNORMAL*/ 6) + 1]);
				if (k < min) {
					min = k;
					witness = j;
				}
			}

			var next = witness + (/*POLY_STRIDE*/ 13);
			if (next === limitB) {
				next = (/*POLY_VERTICES*/ 6);
			}

			var kX, kY;
			var k1, k2;
			var x3, y3;
			var x4, y4;
			var dL;

			var x1 = dataB[witness + (/*POLY_WORLD*/ 2)];
			var y1 = dataB[witness + (/*POLY_WORLD*/ 2) + 1];
			var x2 = dataB[next + (/*POLY_WORLD*/ 2)];
			var y2 = dataB[next + (/*POLY_WORLD*/ 2) + 1];

			// Special case for parallel, intersecting edges.
			var parallel = (min < (Physics2DConfig.COLLINEAR_EPSILON - 1));
			if (max < 0 && parallel) {
				toiData[(/*TOI_AXIS*/ 0)] = (nx * flip);
				toiData[(/*TOI_AXIS*/ 0) + 1] = (ny * flip);

				// Clip (x1,y1), (x2,y2) to edge.
				// Projections relative to edge start.
				kX = dataA[edge + (/*POLY_WORLD*/ 2)];
				kY = dataA[edge + (/*POLY_WORLD*/ 2) + 1];
				dL = dataA[edge + (/*POLY_LENGTH*/ 12)];

				k1 = (nx * (y1 - kY)) - (ny * (x1 - kX));
				if (k1 >= 0 && k1 <= dL) {
					toiData[indB] = kX = x1;
					toiData[indB + 1] = kY = y1;
				} else {
					k2 = (nx * (y2 - kY)) - (ny * (x1 - kX));
					if (k2 >= 0 && k2 <= dL) {
						toiData[indB] = kX = x2;
						toiData[indB + 1] = kY = y2;
					} else {
						//clip one of the vertices (x1,y1) to the edge.
						if (k1 < 0) {
							k1 = -k1;
						} else if (k1 > dL) {
							k1 = (dL - k1);
						}

						toiData[indB] = kX = x1 - (ny * k1);
						toiData[indB + 1] = kY = y1 + (nx * k1);
					}
				}

				// Witness on toiDataA is the projection.
				toiData[indA] = kX - (nx * max);
				toiData[indA + 1] = kY - (ny * max);

				return max;
			} else {
				// Special case for intersection.
				if (max <= 0) {
					toiData[(/*TOI_AXIS*/ 0)] = (nx * flip);
					toiData[(/*TOI_AXIS*/ 0) + 1] = (ny * flip);

					// Find vertex on toiDataB that is 'deepest' This is a vertex of witness edge.
					k1 = (nx * x1) + (ny * y1);
					k2 = (nx * x2) + (ny * y2);
					if (k2 < k1) {
						witness = next;
					}

					// Witness on toiDataB is the deep vertex.
					toiData[indB] = kX = dataB[witness + (/*POLY_WORLD*/ 2)];
					toiData[indB + 1] = kY = dataB[witness + (/*POLY_WORLD*/ 2) + 1];

					// Witness on toiDataA is the projection.
					toiData[indA] = kX - (nx * max);
					toiData[indA + 1] = kY - (ny * max);
					return max;
				} else {
					// Find closest point on dataA edge to witness edge.
					// Witness on dataB is one of the witness vertices.
					// Witness on dataA is the closest point (projection of witness on dataB)
					dL = dataA[edge + (/*POLY_LENGTH*/ 12)];

					// !! Special case parallel edges.
					if (parallel) {
						// Need to swap if dataB is 'longer' edge than on dataA.
						var dL2 = dataB[witness + (/*POLY_LENGTH*/ 12)];
						if (dL2 > dL) {
							dL = dL2;

							// swap edge/witness
							next = edge;
							edge = witness;
							witness = next;

							next = (witness + (/*POLY_STRIDE*/ 13));
							if (next === limitA) {
								next = (/*POLY_VERTICES*/ 6);
							}

							x1 = dataA[witness + (/*POLY_WORLD*/ 2)];
							y1 = dataA[witness + (/*POLY_WORLD*/ 2) + 1];
							x2 = dataA[next + (/*POLY_WORLD*/ 2)];
							y2 = dataA[next + (/*POLY_WORLD*/ 2) + 1];

							// Change to dataB for (kX, kY) below.
							dataA = dataB;

							// flip everyyyyything.
							nx *= -1;
							ny *= -1;
							flip *= -1;

							var tmp = indA;
							indA = indB;
							indB = tmp;
						}
					}

					kX = dataA[edge + (/*POLY_WORLD*/ 2)];
					kY = dataA[edge + (/*POLY_WORLD*/ 2) + 1];

					// 'time' of point w1 along edge.
					k1 = -((nx * (kY - y1)) - (ny * (kX - x1)));
					var in1 = true;
					if (k1 < 0) {
						k1 = 0;
						in1 = false;
					} else if (k1 > dL) {
						k1 = dL;
						in1 = false;
					}

					// 'time' of point w2 along edge.
					k2 = -((nx * (kY - y2)) - (ny * (kX - x2)));
					var in2 = true;
					if (k2 < 0) {
						k2 = 0;
						in2 = false;
					} else if (k2 > dL) {
						k2 = dL;
						in2 = false;
					}

					// point on edge closest to w1/w2, relative to closest points for axis.
					x3 = x1 - (kX - (ny * k1));
					y3 = y1 - (kY + (nx * k1));
					x4 = x2 - (kX - (ny * k2));
					y4 = y2 - (kY + (nx * k2));

					k1 = ((x3 * x3) + (y3 * y3));
					k2 = ((x4 * x4) + (y4 * y4));
					var rec;
					if (k1 < k2) {
						// point closest to w1 is shorter distance.
						toiData[indB] = kX = x1;
						toiData[indB + 1] = kY = y1;
						max = Math.sqrt(k1);
						if (in1 || max < Physics2DConfig.NORMALIZE_EPSILON) {
							toiData[(/*TOI_AXIS*/ 0)] = (nx *= flip);
							toiData[(/*TOI_AXIS*/ 0) + 1] = (ny *= flip);
						} else {
							rec = flip / max;
							toiData[(/*TOI_AXIS*/ 0)] = nx = (x3 * rec);
							toiData[(/*TOI_AXIS*/ 0) + 1] = ny = (y3 * rec);
						}
					} else {
						// point closest to w2 is shorter distance.
						toiData[indB] = kX = x2;
						toiData[indB + 1] = kY = y2;
						max = Math.sqrt(k2);
						if (in2 || max < Physics2DConfig.NORMALIZE_EPSILON) {
							toiData[(/*TOI_AXIS*/ 0)] = (nx *= flip);
							toiData[(/*TOI_AXIS*/ 0) + 1] = (ny *= flip);
						} else {
							rec = flip / max;
							toiData[(/*TOI_AXIS*/ 0)] = nx = (x4 * rec);
							toiData[(/*TOI_AXIS*/ 0) + 1] = ny = (y4 * rec);
						}
					}

					toiData[indA] = kX - (nx * max * flip);
					toiData[indA + 1] = kY - (ny * max * flip);
					return max;
				}
			}
		};

		// =====================================================================
		// Assumption, shapes have been updated by body.
		//   shapes must also be 'in' a Body for special contact data.
		// This method is not quite modular as test/distance
		// due to the complicated values required for contacts etc.
		// no AABB test performed here.
		Physics2DCollisionUtils.prototype._collide = function (shapeA, shapeB, arb) {
			if (shapeA._type === (/*TYPE_CIRCLE*/ 0)) {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					return this._collideCircle2Circle(shapeA, shapeB, arb);
				} else {
					return this._collideCircle2Polygon(shapeA, shapeB, arb, false);
				}
			} else {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					return this._collideCircle2Polygon(shapeB, shapeA, arb, true);
				} else {
					return this._collidePolygon2Polygon(shapeA, shapeB, arb);
				}
			}
		};

		Physics2DCollisionUtils.prototype._collideCircle2Polygon = function (circle, polygon, arb, reverse) {
			var dataC = circle._data;
			var dataP = polygon._data;

			var cx = dataC[(/*CIRCLE_WORLD*/ 9)];
			var cy = dataC[(/*CIRCLE_WORLD*/ 9) + 1];
			var radius = dataC[(/*CIRCLE_RADIUS*/ 6)];

			var max = Number.NEGATIVE_INFINITY;

			var edge, proj;
			var index = (/*POLY_VERTICES*/ 6);
			var limit = dataP.length;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				proj = ((dataP[index + (/*POLY_WNORMAL*/ 6)] * cx) + (dataP[index + (/*POLY_WNORMAL*/ 6) + 1] * cy)) - (dataP[index + (/*POLY_WPROJ*/ 9)] + radius);
				if (proj > 0) {
					return false;
				}
				if (proj > max) {
					max = proj;
					edge = index;
				}
			}

			var adata = arb._data;
			var con, cdata;

			var nx = dataP[edge + (/*POLY_WNORMAL*/ 6)];
			var ny = dataP[edge + (/*POLY_WNORMAL*/ 6) + 1];
			var vX, vY, lvX, lvY;
			var dx, dy;
			proj = ((nx * cy) - (ny * cx));
			if (proj >= dataP[edge + (/*POLY_CROSS1*/ 10)]) {
				if (proj <= dataP[edge + (/*POLY_CROSS2*/ 11)]) {
					// circle center within voronoi region of edge.
					// Take contact point to be consistently halfway into the overlap.
					proj = (radius + (max * 0.5));
					dx = (nx * proj);
					dy = (ny * proj);

					con = arb._injectContact(cx - dx, cy - dy, (reverse ? nx : -nx), (reverse ? ny : -ny), max, (/*HASH_CIRCLE*/ 0));

					arb._faceType = (reverse ? (/*FACE_1*/ 1) : (/*FACE_2*/ 2));
					arb._reverse = !reverse;
					adata[(/*ARB_LNORM*/ 11)] = dataP[edge + (/*POLY_LNORMAL*/ 4)];
					adata[(/*ARB_LNORM*/ 11) + 1] = dataP[edge + (/*POLY_LNORMAL*/ 4) + 1];
					adata[(/*ARB_LPROJ*/ 13)] = dataP[edge + (/*POLY_LPROJ*/ 8)];
					adata[(/*ARB_RADIUS*/ 14)] = radius;

					cdata = con._data;
					cdata[(/*CON_LREL1*/ 13)] = dataC[(/*CIRCLE_LOCAL*/ 7)];
					cdata[(/*CON_LREL1*/ 13) + 1] = dataC[(/*CIRCLE_LOCAL*/ 7) + 1];
					return true;
				} else {
					var next = edge + (/*POLY_STRIDE*/ 13);
					if (next === limit) {
						next = (/*POLY_VERTICES*/ 6);
					}
					vX = dataP[next + (/*POLY_WORLD*/ 2)];
					vY = dataP[next + (/*POLY_WORLD*/ 2) + 1];
					lvX = dataP[next + (/*POLY_LOCAL*/ 0)];
					lvY = dataP[next + (/*POLY_LOCAL*/ 0) + 1];
				}
			} else {
				vX = dataP[edge + (/*POLY_WORLD*/ 2)];
				vY = dataP[edge + (/*POLY_WORLD*/ 2) + 1];
				lvX = dataP[edge + (/*POLY_LOCAL*/ 0)];
				lvY = dataP[edge + (/*POLY_LOCAL*/ 0) + 1];
			}

			// Circle - Vertex
			dx = (cx - vX);
			dy = (cy - vY);
			var dsq = ((dx * dx) + (dy * dy));
			if (dsq > (radius * radius)) {
				return false;
			}

			if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
				// Take contact point to be consistently halfway into the overlap.
				con = arb._injectContact(cx, cy, (reverse ? nx : -nx), (reverse ? ny : -ny), 0, (/*HASH_CIRCLE*/ 0));
			} else {
				var dist = Math.sqrt(dsq);
				var invDist = (1 / dist);
				var df = 0.5 + (radius * invDist * 0.5);
				if (!reverse) {
					invDist = -invDist;
				}

				// Take contact point to be consistently halfway into the overlap.
				con = arb._injectContact(cx - (dx * df), cy - (dy * df), dx * invDist, dy * invDist, dist - radius, (/*HASH_CIRCLE*/ 0));
			}

			cdata = con._data;
			if (reverse) {
				cdata[(/*CON_LREL1*/ 13)] = lvX;
				cdata[(/*CON_LREL1*/ 13) + 1] = lvY;
				cdata[(/*CON_LREL2*/ 15)] = dataC[(/*CIRCLE_LOCAL*/ 7)];
				cdata[(/*CON_LREL2*/ 15) + 1] = dataC[(/*CIRCLE_LOCAL*/ 7) + 1];
			} else {
				cdata[(/*CON_LREL1*/ 13)] = dataC[(/*CIRCLE_LOCAL*/ 7)];
				cdata[(/*CON_LREL1*/ 13) + 1] = dataC[(/*CIRCLE_LOCAL*/ 7) + 1];
				cdata[(/*CON_LREL2*/ 15)] = lvX;
				cdata[(/*CON_LREL2*/ 15) + 1] = lvY;
			}

			adata[(/*ARB_RADIUS*/ 14)] = radius;
			arb._faceType = (/*FACE_CIRCLE*/ 0);
			arb._reverse = false;

			return true;
		};

		Physics2DCollisionUtils.prototype._collidePolygon2Polygon = function (polyA, polyB, arb) {
			var inf = Number.POSITIVE_INFINITY;
			var dataA = polyA._data;
			var dataB = polyB._data;

			var limitA = dataA.length;
			var limitB = dataB.length;

			var i, j;
			var min, k, nx, ny;

			var max = -inf;
			var first, edge, proj;

			for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataA[i + (/*POLY_WNORMAL*/ 6)];
				ny = dataA[i + (/*POLY_WNORMAL*/ 6) + 1];
				proj = dataA[i + (/*POLY_WPROJ*/ 9)];
				for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
					k = (nx * dataB[j + (/*POLY_WORLD*/ 2)]) + (ny * dataB[j + (/*POLY_WORLD*/ 2) + 1]);
					if (k < min) {
						min = k;
					}
					if ((min - proj) <= max) {
						break;
					}
				}
				min -= proj;
				if (min >= 0) {
					return false;
				}
				if (min > max) {
					max = min;
					edge = i;
					first = true;
				}
			}

			for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataB[j + (/*POLY_WNORMAL*/ 6)];
				ny = dataB[j + (/*POLY_WNORMAL*/ 6) + 1];
				proj = dataB[j + (/*POLY_WPROJ*/ 9)];
				for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
					k = (nx * dataA[i + (/*POLY_WORLD*/ 2)]) + (ny * dataA[i + (/*POLY_WORLD*/ 2) + 1]);
					if (k < min) {
						min = k;
					}
					if ((min - proj) <= max) {
						break;
					}
				}
				min -= proj;
				if (min >= 0) {
					return false;
				}
				if (min > max) {
					max = min;
					edge = j;
					first = false;
				}
			}

			// swap data so first polygon owns seperating axis.
			var flip = (first ? 1 : -1);
			var bdata;
			if (!first) {
				dataA = polyB._data;
				dataB = polyA._data;
				limitA = dataA.length;
				limitB = dataB.length;
				bdata = polyA.body._data;
			} else {
				bdata = polyB.body._data;
			}

			nx = dataA[edge + (/*POLY_WNORMAL*/ 6)];
			ny = dataA[edge + (/*POLY_WNORMAL*/ 6) + 1];

			// Find witness edge on dataB (not necessarigly polyB)
			min = inf;
			var witness;
			for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
				k = (nx * dataB[j + (/*POLY_WNORMAL*/ 6)]) + (ny * dataB[j + (/*POLY_WNORMAL*/ 6) + 1]);
				if (k < min) {
					min = k;
					witness = j;
				}
			}

			var next = witness + (/*POLY_STRIDE*/ 13);
			if (next === limitB) {
				next = (/*POLY_VERTICES*/ 6);
			}

			var c1X = dataB[witness + (/*POLY_WORLD*/ 2)];
			var c1Y = dataB[witness + (/*POLY_WORLD*/ 2) + 1];
			var c2X = dataB[next + (/*POLY_WORLD*/ 2)];
			var c2Y = dataB[next + (/*POLY_WORLD*/ 2) + 1];

			var dvX = (c2X - c1X);
			var dvY = (c2Y - c1Y);
			var d1 = (c1X * ny) - (c1Y * nx);
			var d2 = (c2X * ny) - (c2Y * nx);
			var den = (1 / (d2 - d1));

			// clip c1
			var t = (-dataA[edge + (/*POLY_CROSS2*/ 11)] - d1) * den;
			if (t > Physics2DConfig.CLIP_EPSILON) {
				c1X += (dvX * t);
				c1Y += (dvY * t);
			}

			// clip c2
			t = (-dataA[edge + (/*POLY_CROSS1*/ 10)] - d2) * den;
			if (t < -Physics2DConfig.CLIP_EPSILON) {
				c2X += (dvX * t);
				c2Y += (dvY * t);
			}

			var adata = arb._data;
			adata[(/*ARB_LNORM*/ 11)] = dataA[edge + (/*POLY_LNORMAL*/ 4)];
			adata[(/*ARB_LNORM*/ 11) + 1] = dataA[edge + (/*POLY_LNORMAL*/ 4) + 1];
			adata[(/*ARB_LPROJ*/ 13)] = dataA[edge + (/*POLY_LPROJ*/ 8)];
			adata[(/*ARB_RADIUS*/ 14)] = 0.0;
			arb._faceType = (first ? (/*FACE_1*/ 1) : (/*FACE_2*/ 2));

			// Per contact distance
			proj = dataA[edge + (/*POLY_WPROJ*/ 9)];
			var c1d = ((c1X * nx) + (c1Y * ny)) - proj;
			var c2d = ((c2X * nx) + (c2Y * ny)) - proj;

			var p1x = bdata[(/*BODY_POS*/ 2)];
			var p1y = bdata[(/*BODY_POS*/ 2) + 1];
			var cos = bdata[(/*BODY_AXIS*/ 5)];
			var sin = bdata[(/*BODY_AXIS*/ 5) + 1];

			if (c1d > 0 && c2d > 0) {
				return false;
			}

			var rx = (c1X - p1x);
			var ry = (c1Y - p1y);
			c1X -= (nx * c1d * 0.5);
			c1Y -= (ny * c1d * 0.5);
			var con = arb._injectContact(c1X, c1Y, nx * flip, ny * flip, c1d, (first ? (/*HASH_LEFT*/ 1) : (/*HASH_RIGHT*/ 2)), c1d > 0)._data;
			con[(/*CON_LREL1*/ 13)] = ((cos * rx) + (sin * ry));
			con[(/*CON_LREL1*/ 13) + 1] = ((cos * ry) - (sin * rx));

			rx = (c2X - p1x);
			ry = (c2Y - p1y);
			c2X -= (nx * c2d * 0.5);
			c2Y -= (ny * c2d * 0.5);
			con = arb._injectContact(c2X, c2Y, nx * flip, ny * flip, c2d, (first ? (/*HASH_RIGHT*/ 2) : (/*HASH_LEFT*/ 1)), c2d > 0)._data;
			con[(/*CON_LREL1*/ 13)] = ((cos * rx) + (sin * ry));
			con[(/*CON_LREL1*/ 13) + 1] = ((cos * ry) - (sin * rx));

			arb._reverse = (!first);

			return true;
		};

		Physics2DCollisionUtils.prototype._collideCircle2Circle = function (circleA, circleB, arb) {
			var dataA = circleA._data;
			var dataB = circleB._data;

			var x1 = dataA[(/*CIRCLE_WORLD*/ 9)];
			var y1 = dataA[(/*CIRCLE_WORLD*/ 9) + 1];
			var r1 = dataA[(/*CIRCLE_RADIUS*/ 6)];

			var dx = (dataB[(/*CIRCLE_WORLD*/ 9)] - x1);
			var dy = (dataB[(/*CIRCLE_WORLD*/ 9) + 1] - y1);
			var rSum = r1 + dataB[(/*CIRCLE_RADIUS*/ 6)];

			var dsq = ((dx * dx) + (dy * dy));
			if (dsq > (rSum * rSum)) {
				return false;
			}

			var con;
			if (dsq < Physics2DConfig.NORMALIZE_SQ_EPSILON) {
				// Take contact point to be consistently halfway into the overlap.
				con = arb._injectContact(x1 + (dx * 0.5), y1 + (dy * 0.5), 1, 0, -rSum, (/*HASH_CIRCLE*/ 0));
			} else {
				var dist = Math.sqrt(dsq);
				var invDist = (1 / dist);
				var df = (0.5 + ((r1 - (0.5 * rSum)) * invDist));

				// Take contact point to be consistently halfway into the overlap.
				con = arb._injectContact(x1 + (dx * df), y1 + (dy * df), dx * invDist, dy * invDist, dist - rSum, (/*HASH_CIRCLE*/ 0));
			}

			var data = con._data;
			data[(/*CON_LREL1*/ 13)] = dataA[(/*CIRCLE_LOCAL*/ 7)];
			data[(/*CON_LREL1*/ 13) + 1] = dataA[(/*CIRCLE_LOCAL*/ 7) + 1];
			data[(/*CON_LREL2*/ 15)] = dataB[(/*CIRCLE_LOCAL*/ 7)];
			data[(/*CON_LREL2*/ 15) + 1] = dataB[(/*CIRCLE_LOCAL*/ 7) + 1];

			data = arb._data;
			data[(/*ARB_RADIUS*/ 14)] = rSum;
			arb._faceType = (/*FACE_CIRCLE*/ 0);

			return true;
		};

		// =====================================================================
		// Assumption, shapes have been updated by body.
		// need not be 'in' a body.
		// No AABB test performed here.
		Physics2DCollisionUtils.prototype._test = function (shapeA, shapeB) {
			if (shapeA._type === (/*TYPE_CIRCLE*/ 0)) {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					return this._testCircle2Circle(shapeA, shapeB);
				} else {
					return this._testCircle2Polygon(shapeA, shapeB);
				}
			} else {
				if (shapeB._type === (/*TYPE_CIRCLE*/ 0)) {
					return this._testCircle2Polygon(shapeB, shapeA);
				} else {
					return this._testPolygon2Polygon(shapeA, shapeB);
				}
			}
		};

		Physics2DCollisionUtils.prototype._testCircle2Circle = function (circleA, circleB) {
			var dataA = circleA._data;
			var dataB = circleB._data;

			var dx = (dataA[(/*CIRCLE_WORLD*/ 9)] - dataB[(/*CIRCLE_WORLD*/ 9)]);
			var dy = (dataA[(/*CIRCLE_WORLD*/ 9) + 1] - dataB[(/*CIRCLE_WORLD*/ 9) + 1]);
			var rSum = dataA[(/*CIRCLE_RADIUS*/ 6)] + dataB[(/*CIRCLE_RADIUS*/ 6)];

			return (((dx * dx) + (dy * dy)) <= (rSum * rSum));
		};

		Physics2DCollisionUtils.prototype._testCircle2Polygon = function (circle, polygon) {
			var dataC = circle._data;
			var dataP = polygon._data;

			var cx = dataC[(/*CIRCLE_WORLD*/ 9)];
			var cy = dataC[(/*CIRCLE_WORLD*/ 9) + 1];
			var radius = dataC[(/*CIRCLE_RADIUS*/ 6)];

			var max = Number.NEGATIVE_INFINITY;
			var edge, proj;

			var index = (/*POLY_VERTICES*/ 6);
			var limit = dataP.length;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				// proj = world-normal dot position
				proj = ((dataP[index + (/*POLY_WNORMAL*/ 6)] * cx) + (dataP[index + (/*POLY_WNORMAL*/ 6) + 1] * cy));
				var dist = proj - (radius + dataP[index + (/*POLY_WPROJ*/ 9)]);
				if (dist > 0) {
					return false;
				}

				if (dist > max) {
					max = dist;
					edge = index;
				}
			}

			// proj = world-normal perpdot position
			proj = ((dataP[edge + (/*POLY_WNORMAL*/ 6)] * cy) - (dataP[edge + (/*POLY_WNORMAL*/ 6) + 1] * cx));
			if (proj >= dataP[edge + (/*POLY_CROSS1*/ 10)]) {
				if (proj <= dataP[edge + (/*POLY_CROSS2*/ 11)]) {
					// circle center is within voronoi region of edge.
					return true;
				} else {
					// skip to next edge.
					edge += (/*POLY_STRIDE*/ 13);
					if (edge === limit) {
						edge = (/*POLY_VERTICES*/ 6);
					}
				}
			}

			// Perform circle-vertex check.
			// delta = position - vertex
			var dx = (cx - dataP[edge + (/*POLY_WORLD*/ 2)]);
			var dy = (cy - dataP[edge + (/*POLY_WORLD*/ 2) + 1]);
			return (((dx * dx) + (dy * dy)) <= (radius * radius));
		};

		Physics2DCollisionUtils.prototype._testPolygon2Polygon = function (polyA, polyB) {
			var inf = Number.POSITIVE_INFINITY;
			var dataA = polyA._data;
			var dataB = polyB._data;

			var limitA = dataA.length;
			var limitB = dataB.length;

			var i, j;
			var min, proj, nx, ny;

			for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataA[i + (/*POLY_WNORMAL*/ 6)];
				ny = dataA[i + (/*POLY_WNORMAL*/ 6) + 1];
				for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
					proj = (nx * dataB[j + (/*POLY_WORLD*/ 2)]) + (ny * dataB[j + (/*POLY_WORLD*/ 2) + 1]);
					if (proj < min) {
						min = proj;
					}
				}
				if (min > dataA[i + (/*POLY_WPROJ*/ 9)]) {
					return false;
				}
			}

			for (j = (/*POLY_VERTICES*/ 6); j < limitB; j += (/*POLY_STRIDE*/ 13)) {
				min = inf;
				nx = dataB[j + (/*POLY_WNORMAL*/ 6)];
				ny = dataB[j + (/*POLY_WNORMAL*/ 6) + 1];
				for (i = (/*POLY_VERTICES*/ 6); i < limitA; i += (/*POLY_STRIDE*/ 13)) {
					proj = (nx * dataA[i + (/*POLY_WORLD*/ 2)]) + (ny * dataA[i + (/*POLY_WORLD*/ 2) + 1]);
					if (proj < min) {
						min = proj;
					}
				}
				if (min > dataB[j + (/*POLY_WPROJ*/ 9)]) {
					return false;
				}
			}

			return true;
		};

		Physics2DCollisionUtils.create = function () {
			var c = new Physics2DCollisionUtils();
			c._toi = Physics2DTOIEvent.allocate();
			return c;
		};

		return Physics2DCollisionUtils;
})
define(
	'spell/physics/2D/BoxTreeBroadphaseHandle',
	[
	],
	function() {
		var Physics2DBoxTreeBroadphaseHandle = function() {
			this.boxTreeIndex = -1;

			this.data = null;
			this.isStatic = false;
		}

		Physics2DBoxTreeBroadphaseHandle.allocate = function () {
			if (0 < this.pool.length) {
				return this.pool.pop();
			} else {
				return new Physics2DBoxTreeBroadphaseHandle();
			}
		};

		Physics2DBoxTreeBroadphaseHandle.deallocate = function (handle) {
			this.pool.push(handle);

			handle.data = null;
		};

		Physics2DBoxTreeBroadphaseHandle.pool = [];
		return Physics2DBoxTreeBroadphaseHandle;
})

define(
	'spell/physics/2D/BoxTreeBroadphase',
	[
		'spell/data/spatial/BoxTree',
		'spell/physics/2D/BoxTreeBroadphaseHandle'
	],
	function( BoxTree, Physics2DBoxTreeBroadphaseHandle ) {

		var Physics2DBoxTreeBroadphase = function() {
			this.staticTree = BoxTree.create(true);
			this.dynamicTree = BoxTree.create(false);
			this.overlappingNodes = [];
		}
		Physics2DBoxTreeBroadphase.prototype.sample = function (box /*v4*/ , lambda, thisObject) {
			var overlappingNodes = this.overlappingNodes;

			var numOverlappingNodes = this.staticTree.getOverlappingNodes(box, overlappingNodes, 0);
			numOverlappingNodes += this.dynamicTree.getOverlappingNodes(box, overlappingNodes, numOverlappingNodes);

			var n;
			for (n = 0; n < numOverlappingNodes; n += 1) {
				lambda.call(thisObject, overlappingNodes[n], box);
			}
		};

		Physics2DBoxTreeBroadphase.prototype.insert = function (data, box /*v4*/ , isStatic) {
			var handle = Physics2DBoxTreeBroadphaseHandle.allocate();
			handle.data = data;
			handle.isStatic = isStatic;

			if (isStatic) {
				this.staticTree.add(handle, box);
			} else {
				this.dynamicTree.add(handle, box);
			}

			return handle;
		};

		Physics2DBoxTreeBroadphase.prototype.update = function (handle, box /*v4*/ , isStatic) {
			if (isStatic !== undefined && handle.isStatic !== isStatic) {
				if (handle.isStatic) {
					this.staticTree.remove(handle);
					this.dynamicTree.add(handle, box);
				} else {
					this.dynamicTree.remove(handle);
					this.staticTree.add(handle, box);
				}
				handle.isStatic = isStatic;
			} else {
				if (isStatic) {
					this.staticTree.update(handle, box);
				} else {
					this.dynamicTree.update(handle, box);
				}
			}
		};

		Physics2DBoxTreeBroadphase.prototype.remove = function (handle) {
			if (handle.isStatic) {
				this.staticTree.remove(handle);
			} else {
				this.dynamicTree.remove(handle);
			}

			Physics2DBoxTreeBroadphaseHandle.deallocate(handle);
		};

		Physics2DBoxTreeBroadphase.prototype.clear = function (callback, thisObject) {
			this._clearTree(this.staticTree, callback, thisObject);
			this._clearTree(this.dynamicTree, callback, thisObject);
		};

		Physics2DBoxTreeBroadphase.prototype._clearTree = function (tree, callback, thisObject) {
			var nodes = tree.getNodes();
			var numNodes = nodes.length;
			var n;
			for (n = 0; n < numNodes; n += 1) {
				var handle = nodes[n].externalNode;
				if (handle) {
					if (callback) {
						callback.call(thisObject, handle);
					}
					Physics2DBoxTreeBroadphaseHandle.deallocate(handle);
				}
			}
			tree.clear();
		};

		Physics2DBoxTreeBroadphase.prototype._validate = function () {
			this.staticTree.finalize();
			this.dynamicTree.finalize();
		};

		Physics2DBoxTreeBroadphase.prototype.perform = function (lambda, thisObject) {
			this._validate();

			var overlappingNodes = this.overlappingNodes;

			var staticTree = this.staticTree;
			var dynamicTree = this.dynamicTree;

			var dynamicNodes = dynamicTree.getNodes();
			var numDynamicNodes = dynamicNodes.length;
			var n;
			for (n = 0; n < numDynamicNodes; n += 1) {
				var dynamicNode = dynamicNodes[n];
				var handle = dynamicNode.externalNode;
				if (handle) {
					var numOverlappingNodes = staticTree.getOverlappingNodes(dynamicNode.extents, overlappingNodes, 0);
					var i;
					for (i = 0; i < numOverlappingNodes; i += 1) {
						lambda.call(thisObject, handle, overlappingNodes[i]);
					}
				}
			}

			var numPairs = dynamicTree.getOverlappingPairs(overlappingNodes, 0);
			for (n = 0; n < numPairs; n += 2) {
				lambda.call(thisObject, overlappingNodes[n], overlappingNodes[n + 1]);
			}
		};

		Physics2DBoxTreeBroadphase.create = function () {
			return new Physics2DBoxTreeBroadphase();
		};

		Physics2DBoxTreeBroadphase.version = 1;

		return Physics2DBoxTreeBroadphase;
})

// =====================================================================
//
// Physics2D Contact
//
//
// CONTACT DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CON_POS*/0         // World position of contact (x, y)
///*CON_DIST*/2        // Penetration distance of contact
///*CON_BOUNCE*/3      // Per-contact bounce error.
///*CON_FRICTION*/4    // Per-contact friction (based on arbiter and rel. velocity)
///*CON_NMASS*/5       // Normal effective mass
///*CON_TMASS*/6       // Tangent effective mass
///*CON_REL1*/7        // Contact relative to object 1 (x, y)
///*CON_REL2*/9        // Contact relative to object 2 (x, y)
///*CON_JNACC*/11      // Normal accumulated impulse
///*CON_JTACC*/12      // Tangent accumulated impulse
///*CON_LREL1*/13      // Local contact point on object 1 (position iteration) (x, y)
///*CON_LREL2*/15      // Local contact point on object 2 (position iteration) (x, y)
//
///*CON_DATA_SIZE*/17
define(
	'spell/physics/2D/Contact',
	[
		'spell/shared/util/platform/Types'
	],
	function(Types) {
		var Physics2DContact = function() {
			this._data = Types.createFloatArray((/*CON_DATA_SIZE*/ 17));
			this.fresh = false;
			this._hash = 0;
			this._timeStamp = 0;
			this._next = null;
			this.active = false;
			this.virtual = false;
		}
		Physics2DContact.allocate = function () {
			if (!this.pool) {
				return new Physics2DContact();
			} else {
				var ret = this.pool;
				this.pool = ret._next;
				ret._next = null;
				return ret;
			}
		};
		Physics2DContact.deallocate = function (contact) {
			contact._next = this.pool;
			this.pool = contact;
		};

		Physics2DContact.prototype.getPosition = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}
			var data = this._data;
			dst[0] = data[(/*CON_POS*/ 0)];
			dst[1] = data[(/*CON_POS*/ 0) + 1];
			return dst;
		};

		Physics2DContact.prototype.getPenetration = function () {
			return (-this._data[(/*CON_DIST*/ 2)]);
		};

		Physics2DContact.prototype.getNormalImpulse = function () {
			return (this.virtual ? 0 : this._data[(/*CON_JNACC*/ 11)]);
		};

		Physics2DContact.prototype.getTangentImpulse = function () {
			return (this.virtual ? 0 : this._data[(/*CON_JTACC*/ 12)]);
		};
		Physics2DContact.version = 1;

		Physics2DContact.pool = null;
		return Physics2DContact;
})


// =====================================================================
//
// Physics2D Arbiter
//
//
// ARBITER DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
// Velocity iterations.
// these values must remain below (31) as used as bit accessors
// on userdef flag.
///*ARB_DYN_FRIC*/0      // Coef. dynamic friction
///*ARB_STATIC_FRIC*/1   // Coef. static friction
///*ARB_ELASTICITY*/2    // Coef. elasticity
///*ARB_ROLLING_FRIC*/3  // Coef. rolling friction
//
///*ARB_NORMAL*/4        // World space normal (velocity iterations) (x, y)
///*ARB_PREDT*/6         // Previous time-step on computation for scaling.
//
// Jacobian (first contact)
///*ARB_RN1A*/7          // (contact1.ra cross normal)
///*ARB_RN1B*/8          // (contact1.rb cross normal)
///*ARB_RT1A*/9          // (contact1.ra dot normal)
///*ARB_RT1B*/10          // (contact1.rb dot normal)
//
// Position iterations.
///*ARB_LNORM*/11         // Local normal of reference edge (x, y)
///*ARB_LPROJ*/13         // Local projection onto reference edge.
///*ARB_RADIUS*/14        // Sum radius of shapes (0 poly, radius circle)
///*ARB_BIAS*/15          // Bias coeffecient
//
// 2-contact arbiter only.
// Jacobian second contact
///*ARB_RN2A*/16          // (contact2.ra cross normal)
///*ARB_RN2B*/17          // (contact2.rb cross normal)
///*ARB_RT2A*/18          // (contact2.ra dot normal)
///*ARB_RT2B*/19          // (contact2.rb dot normal)
////**/
///*ARB_K*/20             // Block solver non-inverted effectivemass [a b; b c] (sym. matrix)
///*ARB_KMASS*/23         // (1 / det) of ARB_K for on the fly inversion.
//
// 1-contact arbiter only. (when one is a circle)
///*ARB_JRACC*/16         // Accumulated rolling friction impulse
///*ARB_RMASS*/17         // Rolling friction effectivemass.
//
//
//
///*ARB_DATA_SIZE*/24
//
//
// Flags for when user has explicitly set values on arbiter.
///*USERDEF_DYN*/1
///*USERDEF_STAT*/2
///*USERDEF_ROLLING*/4
///*USERDEF_ELASTICITY*/8
//
// Face flags
///*FACE_CIRCLE*/0
///*FACE_1*/1
///*FACE_2*/2
//
// Hash flags
///*HASH_CIRCLE*/0
///*HASH_LEFT*/1
///*HASH_RIGHT*/2
//
// State flags
///*STATE_ACCEPT*/1
///*STATE_ALWAYS*/2
define(
	'spell/physics/2D/Arbiter',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Contact',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DContact,
		Types
	) {
		var Physics2DArbiter = function() {
			this.shapeA = null;
			this.shapeB = null;
			this.bodyA = null;
			this.bodyB = null;
			this._next = null;

			this._retired = false; // set to true when arbiter is lazily retired to be removed in step()
			this._lazyRetired = false;
			this._static = false;
			this._state = 0;
			this.sensor = false;

			this._createStamp = 0; // time stamp at which arbiter was created.
			this._updateStamp = 0; // time stamp at which arbiter was updated.
			this._sleepStamp = 0; // time stamp at which arbiter was put to sleep
			this._timeStamp = 0; // time stamp set before collision detection so that

			// injected contacts have correct time set without later
			// iteration.
			this._createContinuous = false; // Marks createStamp as having been set during

			// continuous collisions for callbacks.
			this._endGenerated = 0; // time stamp at which end event was generated.

			// This deals with another corner case where
			// object seperates (end event), then continuously collide
			// needing to generate a begin even for the same pair of
			// objects (same arbiter) in the same step!.
			this._midStep = false; // Set to true before preSolve events are called to avoid waking bodies.

			this.sleeping = false;
			this.active = false;
			this._invalidated = false;

			this._data = Types.createFloatArray((/*ARB_DATA_SIZE*/ 24));
			this.contacts = [];

			this._userdef = 0; // bit-flags for if user has set an elasticity/friction value.
			this._velocity2Contact = false;
			this._position2Contact = false;
			this._contact1 = this._contact2 = null;
			this._faceType = 0; // FACE_CIRCLE/FACE_1/FACE_2
		}
		Physics2DArbiter.prototype.getNormal = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}
			if (this.sensor) {
				dst[0] = dst[1] = 0;
			} else {
				var data = this._data;
				dst[0] = data[(/*ARB_NORMAL*/ 4)];
				dst[1] = data[(/*ARB_NORMAL*/ 4) + 1];
			}
			return dst;
		};

		Physics2DArbiter.prototype.getRollingImpulse = function () {
			if (this.sensor || this._velocity2Contact || this._contact1._hash !== (/*HASH_CIRCLE*/ 0)) {
				return 0;
			} else {
				return this._data[(/*ARB_JRACC*/ 16)];
			}
		};

		// =========================================================
		Physics2DArbiter.prototype.getElasticity = function () {
			if (this.sensor) {
				return undefined;
			}

			this._validate();
			return this._data[(/*ARB_ELASTICITY*/ 2)];
		};

		Physics2DArbiter.prototype.getDynamicFriction = function () {
			if (this.sensor) {
				return undefined;
			}

			this._validate();
			return this._data[(/*ARB_DYN_FRIC*/ 0)];
		};

		Physics2DArbiter.prototype.getStaticFriction = function () {
			if (this.sensor) {
				return undefined;
			}

			this._validate();
			return this._data[(/*ARB_STATIC_FRIC*/ 1)];
		};

		Physics2DArbiter.prototype.getRollingFriction = function () {
			if (this.sensor) {
				return undefined;
			}

			this._validate();
			return this._data[(/*ARB_ROLLING_FRIC*/ 3)];
		};

		/*jshint bitwise: false*/
		Physics2DArbiter.prototype.setElasticity = function (elasticity) {
			if (this.sensor) {
				return;
			}

			this._data[(/*ARB_ELASTICITY*/ 2)] = elasticity;
			this._userdef |= (1 << (/*ARB_ELASTICITY*/ 2));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setDynamicFriction = function (dynamicFriction) {
			if (this.sensor) {
				return;
			}

			this._data[(/*ARB_DYN_FRIC*/ 0)] = dynamicFriction;
			this._userdef |= (1 << (/*ARB_DYN_FRIC*/ 0));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setStaticFriction = function (staticFriction) {
			if (this.sensor) {
				return;
			}

			this._data[(/*ARB_STAT_FRIC*/ 1)] = staticFriction;
			this._userdef |= (1 << (/*ARB_STAT_FRIC*/ 1));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setRollingFriction = function (rollingFriction) {
			if (this.sensor) {
				return;
			}

			this._data[(/*ARB_ROLLING_FRIC*/ 3)] = rollingFriction;
			this._userdef |= (1 << (/*ARB_ROLLING_FRIC*/ 3));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setElasticityFromShapes = function () {
			if (this.sensor) {
				return;
			}

			this._userdef &= ~(1 << (/*ARB_ELASTICITY*/ 2));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setDynamicFrictionFromShapes = function () {
			if (this.sensor) {
				return;
			}

			this._userdef &= ~(1 << (/*ARB_DYN_FRIC*/ 0));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setStaticFrictionFromShapes = function () {
			if (this.sensor) {
				return;
			}

			this._userdef &= ~(1 << (/*ARB_STAT_FRIC*/ 1));
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setRollingFrictionFromShapes = function () {
			if (this.sensor) {
				return;
			}

			this._userdef &= ~(1 << (/*ARB_ROLLING_FRIC*/ 3));
			this._invalidate(true);
		};

		/*jshint bitwise: true*/
		// =========================================================
		/*jshint bitwise: false*/
		Physics2DArbiter.prototype.isStateAccepted = function () {
			if (this.sensor) {
				return false;
			} else {
				return ((this._state & (/*STATE_ACCEPT*/ 1)) !== 0);
			}
		};

		Physics2DArbiter.prototype.isStatePersistent = function () {
			if (this.sensor) {
				return false;
			} else {
				return ((this._state & (/*STATE_ALWAYS*/ 2)) !== 0);
			}
		};

		Physics2DArbiter.prototype.setAcceptedState = function (accepted) {
			if (this.sensor) {
				return;
			}

			if (accepted) {
				this._state |= (/*STATE_ACCEPT*/ 1);
			} else {
				this._state &= ~(/*STATE_ACCEPT*/ 1);
			}
			this._invalidate(true);
		};

		Physics2DArbiter.prototype.setPersistentState = function (persistent) {
			if (this.sensor) {
				return;
			}

			if (persistent) {
				this._state |= (/*STATE_ALWAYS*/ 2);
			} else {
				this._state &= ~(/*STATE_ALWAYS*/ 2);
			}
			this._invalidate(true);
		};

		/*jshint bitwise: true*/
		// =========================================================
		// Called when arbiter is destroyed by removal of a shape
		// Or change in body type signialling end of an interaction.
		// In either case, arbiter was woken and sleeping is false.
		//
		// Effect is that in following step, arbiter is permitted
		// to persist one additional frame (for any end events)
		// and then in the next step retired fully and reused.
		Physics2DArbiter.prototype._lazyRetire = function (ignoreShape) {
			this._lazyRetired = true;
			this._retired = true;
			this.active = false;

			var arbiters;
			var index;
			if (this.shapeA !== ignoreShape) {
				arbiters = this.shapeA.arbiters;
				index = arbiters.indexOf(this);
				arbiters[index] = arbiters[arbiters.length - 1];
				arbiters.pop();
			}
			if (this.shapeB !== ignoreShape) {
				arbiters = this.shapeB.arbiters;
				index = arbiters.indexOf(this);
				arbiters[index] = arbiters[arbiters.length - 1];
				arbiters.pop();
			}
		};

		Physics2DArbiter.prototype._assign = function (s1, s2) {
			this.bodyA = s1.body;
			this.bodyB = s2.body;
			this.shapeA = s1;
			this.shapeB = s2;

			s1.arbiters.push(this);
			s2.arbiters.push(this);

			this._retired = false;
			this.sleeping = false;

			this._invalidate();
		};

		Physics2DArbiter.prototype._retire = function () {
			this.shapeA = this.shapeB = null;
			this.bodyA = this.bodyB = null;
			this._retired = true;
			this._lazyRetired = false;
			this.active = false;
			this._data[(/*ARB_PREDT*/ 6)] = 0;

			var contacts = this.contacts;
			while (contacts.length > 0) {
				var contact = contacts.pop();
				Physics2DContact.deallocate(contact);
			}
			this._contact1 = this._contact2 = null;
		};

		// =====================================================================
		Physics2DArbiter.prototype._invalidate = function (dontSkip) {
			this._invalidated = true;
			if (dontSkip && !this._midStep) {
				this.shapeA.body.wake();
				this.shapeB.body.wake();
			}
		};

		Physics2DArbiter.prototype._validate = function () {
			this._invalidated = false;

			var data = this._data;
			var mA = this.shapeA._material._data;
			var mB = this.shapeB._material._data;
			var userdef = this._userdef;

			/*jshint bitwise: false*/
			if ((userdef & (1 << (/*ARB_ELASTICITY*/ 2))) === 0) {
				var elasticity;
				var elasticA = mA[(/*MAT_ELASTICITY*/ 0)];
				var elasticB = mB[(/*MAT_ELASTICITY*/ 0)];
				if (elasticA <= Number.NEGATIVE_INFINITY || elasticB <= Number.NEGATIVE_INFINITY) {
					elasticity = 0;
				} else if (elasticA >= Number.POSITIVE_INFINITY || elasticB >= Number.POSITIVE_INFINITY) {
					elasticity = 1;
				} else {
					elasticity = (elasticA + elasticB) * 0.5;
					if (elasticity < 0) {
						elasticity = 0;
					} else if (elasticity > 1) {
						elasticity = 1;
					}
				}
				data[(/*ARB_ELASTICITY*/ 2)] = elasticity;
			}

			var sqrt = Math.sqrt;
			if ((userdef & (1 << (/*ARB_DYN_FRIC*/ 0))) === 0) {
				data[(/*ARB_DYN_FRIC*/ 0)] = sqrt(mA[(/*MAT_DYNAMIC*/ 2)] * mB[(/*MAT_DYNAMIC*/ 2)]);
			}
			if ((userdef & (1 << (/*ARB_STATIC_FRIC*/ 1))) === 0) {
				data[(/*ARB_STATIC_FRIC*/ 1)] = sqrt(mA[(/*MAT_STATIC*/ 1)] * mB[(/*MAT_STATIC*/ 1)]);
			}
			if ((userdef & (1 << (/*ARB_ROLLING_FRIC*/ 3))) === 0) {
				data[(/*ARB_ROLLING_FRIC*/ 3)] = sqrt(mA[(/*MAT_ROLLING*/ 3)] * mB[(/*MAT_ROLLING*/ 3)]);
			}
			/*jshint bitwise: true*/
		};

		// =====================================================================
		Physics2DArbiter.prototype._injectContact = function (px, py, nx, ny, dist, hash, virtual) {
			var contact;
			var contacts = this.contacts;
			var limit = contacts.length;
			if (limit !== 0) {
				contact = contacts[0];
				if (contact._hash !== hash) {
					if (limit !== 1) {
						contact = contacts[1];
						if (contact._hash !== hash) {
							contact = null;
						}
					} else {
						contact = null;
					}
				}
			}

			if (virtual === undefined) {
				virtual = false;
			}

			var data;
			if (!contact) {
				contact = Physics2DContact.allocate();
				data = contact._data;
				data[(/*CON_JNACC*/ 11)] = data[(/*CON_JTACC*/ 12)] = 0;
				contact._hash = hash;
				contact.fresh = (!virtual);
				contacts.push(contact);

				if (hash === (/*HASH_CIRCLE*/ 0)) {
					this._data[(/*ARB_JRACC*/ 16)] = 0;
				}
			} else {
				contact.fresh = (!virtual && contact.virtual);
				data = contact._data;
			}

			data[(/*CON_POS*/ 0)] = px;
			data[(/*CON_POS*/ 0) + 1] = py;
			data[(/*CON_DIST*/ 2)] = dist;
			contact._timeStamp = this._timeStamp;
			contact.virtual = virtual;

			data = this._data;
			data[(/*ARB_NORMAL*/ 4)] = nx;
			data[(/*ARB_NORMAL*/ 4) + 1] = ny;

			return contact;
		};

		Physics2DArbiter.prototype._cleanContacts = function (timeStamp) {
			var fst = true;
			this._position2Contact = false;
			this._contact2 = null;
			var contacts = this.contacts;
			var limit = contacts.length;
			var i;
			for (i = 0; i < limit;) {
				var c = contacts[i];
				if (c._timeStamp + Physics2DConfig.DELAYED_DEATH < timeStamp) {
					limit -= 1;
					contacts[i] = contacts[limit];
					contacts.pop();
					Physics2DContact.deallocate(c);
					continue;
				}

				c.active = (c._timeStamp === timeStamp);
				if (c.active) {
					if (fst) {
						this._contact1 = c;
						fst = false;
					} else {
						this._contact2 = c;
						this._position2Contact = true;
					}
				}

				i += 1;
			}

			if (this._position2Contact) {
				if (this._contact1.virtual) {
					var tmp = this._contact1;
					this._contact1 = this._contact2;
					this._contact2 = tmp;
				}
				this._velocity2Contact = !(this._contact2.virtual);
			} else {
				this._velocity2Contact = false;
			}

			return !fst;
		};

		// =====================================================================
		Physics2DArbiter.prototype._preStep = function (deltaTime, timeStamp, continuous) {
			if (!this._cleanContacts(timeStamp)) {
				return false;
			}

			if (this._invalidated) {
				this._validate();
			}

			var adata = this._data;
			var predt = adata[(/*ARB_PREDT*/ 6)];
			var dtRatio = (predt === 0) ? 1 : (deltaTime / predt);
			adata[(/*ARB_PREDT*/ 6)] = deltaTime;

			var data1 = this.bodyA._data;
			var data2 = this.bodyB._data;

			var px1 = data1[(/*BODY_POS*/ 2)];
			var py1 = data1[(/*BODY_POS*/ 2) + 1];
			var px2 = data2[(/*BODY_POS*/ 2)];
			var py2 = data2[(/*BODY_POS*/ 2) + 1];

			var vx1 = data1[(/*BODY_VEL*/ 7)];
			var vy1 = data1[(/*BODY_VEL*/ 7) + 1];
			var vw1 = data1[(/*BODY_VEL*/ 7) + 2];
			var vx2 = data2[(/*BODY_VEL*/ 7)];
			var vy2 = data2[(/*BODY_VEL*/ 7) + 1];
			var vw2 = data2[(/*BODY_VEL*/ 7) + 2];

			var nx = adata[(/*ARB_NORMAL*/ 4)];
			var ny = adata[(/*ARB_NORMAL*/ 4) + 1];

			var massSum = data1[(/*BODY_IMASS*/ 0)] + data2[(/*BODY_IMASS*/ 0)];

			var ii1 = data1[(/*BODY_IINERTIA*/ 1)];
			var ii2 = data2[(/*BODY_IINERTIA*/ 1)];

			var EPS = Physics2DConfig.EFF_MASS_EPSILON;
			var BIAS = (continuous ? (this._static ? Physics2DConfig.CONT_STATIC_BIAS_COEF : Physics2DConfig.CONT_BIAS_COEF) : this._static ? Physics2DConfig.STATIC_BIAS_COEF : Physics2DConfig.BIAS_COEF);
			adata[(/*ARB_BIAS*/ 15)] = BIAS;

			var c = this._contact1;
			var data;
			var rx1, ry1, rx2, ry2;
			while (true) {
				data = c._data;

				var px = data[(/*CON_POS*/ 0)];
				var py = data[(/*CON_POS*/ 0) + 1];

				// Contact point relative vectors.
				rx1 = data[(/*CON_REL1*/ 7)] = (px - px1);
				ry1 = data[(/*CON_REL1*/ 7) + 1] = (py - py1);
				rx2 = data[(/*CON_REL2*/ 9)] = (px - px2);
				ry2 = data[(/*CON_REL2*/ 9) + 1] = (py - py2);

				// Tangent effective mass.
				var v1 = (rx1 * nx) + (ry1 * ny);
				var v2 = (rx2 * nx) + (ry2 * ny);
				var kt = massSum + (ii2 * v2 * v2) + (ii1 * v1 * v1);
				data[(/*CON_TMASS*/ 6)] = (kt < EPS) ? 0 : (1 / kt);

				// Normal effective mass.
				v1 = (rx1 * ny) - (ry1 * nx);
				v2 = (rx2 * ny) - (ry2 * nx);
				var kn = massSum + (ii2 * v2 * v2) + (ii1 * v1 * v1);
				data[(/*CON_NMASS*/ 5)] = (kn < EPS) ? 0 : (1 / kn);

				// Relative velocity at contact point.
				var vrx = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
				var vry = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

				// Compute bounce error
				var vdot = (nx * vrx) + (ny * vry);
				var bounce = (vdot * adata[(/*ARB_ELASTICITY*/ 2)]);
				if (bounce > -Physics2DConfig.BOUNCE_VELOCITY_THRESHOLD) {
					bounce = 0;
				}
				data[(/*CON_BOUNCE*/ 3)] = bounce;

				// Compute friction coef.
				vdot = (nx * vry) - (ny * vrx);
				if ((vdot * vdot) > Physics2DConfig.STATIC_FRIC_SQ_EPSILON) {
					data[(/*CON_FRICTION*/ 4)] = adata[(/*ARB_DYN_FRIC*/ 0)];
				} else {
					data[(/*CON_FRICTION*/ 4)] = adata[(/*ARB_STATIC_FRIC*/ 1)];
				}

				// Scale impulses from change in time step
				data[(/*CON_JNACC*/ 11)] *= dtRatio;
				data[(/*CON_JTACC*/ 12)] *= dtRatio;

				// Advance to next contact.
				if (this._velocity2Contact) {
					if (c === this._contact2) {
						break;
					}
					c = this._contact2;
				} else {
					break;
				}
			}

			data = this._contact1._data;
			rx1 = data[(/*CON_REL1*/ 7)];
			ry1 = data[(/*CON_REL1*/ 7) + 1];
			rx2 = data[(/*CON_REL2*/ 9)];
			ry2 = data[(/*CON_REL2*/ 9) + 1];
			var rn1a = adata[(/*ARB_RN1A*/ 7)] = (rx1 * ny) - (ry1 * nx);
			var rn1b = adata[(/*ARB_RN1B*/ 8)] = (rx2 * ny) - (ry2 * nx);
			adata[(/*ARB_RT1A*/ 9)] = (rx1 * nx) + (ry1 * ny);
			adata[(/*ARB_RT1B*/ 10)] = (rx2 * nx) + (ry2 * ny);

			if (!this._velocity2Contact && this._contact1._hash === (/*HASH_CIRCLE*/ 0)) {
				adata[(/*ARB_JRACC*/ 16)] *= dtRatio;
				var sum = ii1 + ii2;
				adata[(/*ARB_RMASS*/ 17)] = (sum < EPS) ? 0 : (1 / sum);
			} else if (this._velocity2Contact) {
				data = this._contact2._data;
				var r2x1 = data[(/*CON_REL1*/ 7)];
				var r2y1 = data[(/*CON_REL1*/ 7) + 1];
				var r2x2 = data[(/*CON_REL2*/ 9)];
				var r2y2 = data[(/*CON_REL2*/ 9) + 1];
				var rn2a = adata[(/*ARB_RN2A*/ 16)] = (r2x1 * ny) - (r2y1 * nx);
				var rn2b = adata[(/*ARB_RN2B*/ 17)] = (r2x2 * ny) - (r2y2 * nx);
				adata[(/*ARB_RT2A*/ 18)] = (r2x1 * nx) + (r2y1 * ny);
				adata[(/*ARB_RT2B*/ 19)] = (r2x2 * nx) + (r2y2 * ny);

				var Ka = adata[(/*ARB_K*/ 20)] = massSum + (ii1 * rn1a * rn1a) + (ii2 * rn1b * rn1b);
				var Kb = adata[(/*ARB_K*/ 20) + 1] = massSum + (ii1 * rn1a * rn2a) + (ii2 * rn1b * rn2b);
				var Kc = adata[(/*ARB_K*/ 20) + 2] = massSum + (ii1 * rn2a * rn2a) + (ii2 * rn2b * rn2b);

				// Degenerate case! eek.
				var det = ((Ka * Kc) - (Kb * Kb));
				if ((Ka * Ka) > (Physics2DConfig.ILL_THRESHOLD * det)) {
					if (this._contact2._data[(/*CON_DIST*/ 2)] < this._contact1._data[(/*CON_DIST*/ 2)]) {
						this._contact1 = this._contact2;
						adata[(/*ARB_RN1A*/ 7)] = rn2a;
						adata[(/*ARB_RN1B*/ 8)] = rn2b;
						adata[(/*ARB_RT1A*/ 9)] = adata[(/*ARB_RT2A*/ 18)];
						adata[(/*ARB_RT1B*/ 10)] = adata[(/*ARB_RT2B*/ 19)];
					}
					this._velocity2Contact = false;
					this._position2Contact = false;
					this._contact2 = null;
				} else {
					adata[(/*ARB_KMASS*/ 23)] = (1 / det);
				}
			}

			return true;
		};

		// =====================================================================
		Physics2DArbiter.prototype._iterateVelocity = function () {
			var data1 = this.bodyA._data;
			var data2 = this.bodyB._data;
			var im1 = data1[(/*BODY_IMASS*/ 0)];
			var ii1 = data1[(/*BODY_IINERTIA*/ 1)];
			var im2 = data2[(/*BODY_IMASS*/ 0)];
			var ii2 = data2[(/*BODY_IINERTIA*/ 1)];
			var vx1 = data1[(/*BODY_VEL*/ 7)];
			var vy1 = data1[(/*BODY_VEL*/ 7) + 1];
			var vw1 = data1[(/*BODY_VEL*/ 7) + 2];
			var vx2 = data2[(/*BODY_VEL*/ 7)];
			var vy2 = data2[(/*BODY_VEL*/ 7) + 1];
			var vw2 = data2[(/*BODY_VEL*/ 7) + 2];

			var adata = this._data;
			var nx = adata[(/*ARB_NORMAL*/ 4)];
			var ny = adata[(/*ARB_NORMAL*/ 4) + 1];
			var rn1a = adata[(/*ARB_RN1A*/ 7)];
			var rn1b = adata[(/*ARB_RN1B*/ 8)];
			var rt1a = adata[(/*ARB_RT1A*/ 9)];
			var rt1b = adata[(/*ARB_RT1B*/ 10)];

			var cdata1 = this._contact1._data;
			var rx1 = cdata1[(/*CON_REL1*/ 7)];
			var ry1 = cdata1[(/*CON_REL1*/ 7) + 1];
			var rx2 = cdata1[(/*CON_REL2*/ 9)];
			var ry2 = cdata1[(/*CON_REL2*/ 9) + 1];

			var surfaceX = (data2[(/*BODY_SURFACE_VEL*/ 13)] - data1[(/*BODY_SURFACE_VEL*/ 13)]);
			var surfaceY = (data2[(/*BODY_SURFACE_VEL*/ 13) + 1] - data1[(/*BODY_SURFACE_VEL*/ 13) + 1]);

			// Relative velocity first contact
			var vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
			var vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

			var j, jOld, cjAcc, jx, jy, jMax;

			// First contact friction
			j = (((nx * vry1) - (ny * vrx1)) + surfaceX) * cdata1[(/*CON_TMASS*/ 6)];
			jMax = (cdata1[(/*CON_FRICTION*/ 4)] * cdata1[(/*CON_JNACC*/ 11)]);
			jOld = cdata1[(/*CON_JTACC*/ 12)];
			cjAcc = (jOld - j);
			if (cjAcc > jMax) {
				cjAcc = jMax;
			} else if (cjAcc < -jMax) {
				cjAcc = -jMax;
			}
			j = (cjAcc - jOld);
			cdata1[(/*CON_JTACC*/ 12)] = cjAcc;

			jx = (-ny * j);
			jy = (nx * j);
			vx1 -= (jx * im1);
			vy1 -= (jy * im1);
			vw1 -= (rt1a * j * ii1);
			vx2 += (jx * im2);
			vy2 += (jy * im2);
			vw2 += (rt1b * j * ii2);

			if (this._velocity2Contact) {
				var cdata2 = this._contact2._data;
				var r2x1 = cdata2[(/*CON_REL1*/ 7)];
				var r2y1 = cdata2[(/*CON_REL1*/ 7) + 1];
				var r2x2 = cdata2[(/*CON_REL2*/ 9)];
				var r2y2 = cdata2[(/*CON_REL2*/ 9) + 1];

				var Ka = adata[(/*ARB_K*/ 20)];
				var Kb = adata[(/*ARB_K*/ 20) + 1];
				var Kc = adata[(/*ARB_K*/ 20) + 2];
				var idet = adata[(/*ARB_KMASS*/ 23)];

				var rn2a = adata[(/*ARB_RN2A*/ 16)];
				var rn2b = adata[(/*ARB_RN2B*/ 17)];
				var rt2a = adata[(/*ARB_RT2A*/ 18)];
				var rt2b = adata[(/*ARB_RT2B*/ 19)];

				// Second contact friction
				var vrx2 = (vx2 - (r2y2 * vw2)) - (vx1 - (r2y1 * vw1));
				var vry2 = (vy2 + (r2x2 * vw2)) - (vy1 + (r2x1 * vw1));

				j = (((nx * vry2) - (ny * vrx2)) + surfaceX) * cdata2[(/*CON_TMASS*/ 6)];
				jMax = (cdata2[(/*CON_FRICTION*/ 4)] * cdata2[(/*CON_JNACC*/ 11)]);
				jOld = cdata2[(/*CON_JTACC*/ 12)];
				cjAcc = (jOld - j);
				if (cjAcc > jMax) {
					cjAcc = jMax;
				} else if (cjAcc < -jMax) {
					cjAcc = -jMax;
				}
				j = (cjAcc - jOld);
				cdata2[(/*CON_JTACC*/ 12)] = cjAcc;

				jx = (-ny * j);
				jy = (nx * j);
				vx1 -= (jx * im1);
				vy1 -= (jy * im1);
				vw1 -= (rt2a * j * ii1);
				vx2 += (jx * im2);
				vy2 += (jy * im2);
				vw2 += (rt2b * j * ii2);

				// Normal impulses.
				vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
				vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));
				vrx2 = (vx2 - (r2y2 * vw2)) - (vx1 - (r2y1 * vw1));
				vry2 = (vy2 + (r2x2 * vw2)) - (vy1 + (r2x1 * vw1));

				var ax = cdata1[(/*CON_JNACC*/ 11)];
				var ay = cdata2[(/*CON_JNACC*/ 11)];

				// Block solver for both normal impulses together.
				var jnx = ((vrx1 * nx) + (vry1 * ny)) + surfaceY + cdata1[(/*CON_BOUNCE*/ 3)] - ((Ka * ax) + (Kb * ay));
				var jny = ((vrx2 * nx) + (vry2 * ny)) + surfaceY + cdata2[(/*CON_BOUNCE*/ 3)] - ((Kb * ax) + (Kc * ay));

				var xx = idet * ((Kb * jny) - (Kc * jnx));
				var xy = idet * ((Kb * jnx) - (Ka * jny));

				if (xx >= 0 && xy >= 0) {
					jnx = (xx - ax);
					jny = (xy - ay);
					cdata1[(/*CON_JNACC*/ 11)] = xx;
					cdata2[(/*CON_JNACC*/ 11)] = xy;
				} else {
					xx = -(cdata1[(/*CON_NMASS*/ 5)] * jnx);
					if (xx >= 0 && ((Kb * xx) + jny) >= 0) {
						jnx = (xx - ax);
						jny = -ay;
						cdata1[(/*CON_JNACC*/ 11)] = xx;
						cdata2[(/*CON_JNACC*/ 11)] = 0;
					} else {
						xy = -(cdata2[(/*CON_NMASS*/ 5)] * jny);
						if (xy >= 0 && ((Kb * xy) + jnx) >= 0) {
							jnx = -ax;
							jny = (xy - ay);
							cdata1[(/*CON_JNACC*/ 11)] = 0;
							cdata2[(/*CON_JNACC*/ 11)] = xy;
						} else if (jnx >= 0 && jny >= 0) {
							jnx = -ax;
							jny = -ay;
							cdata1[(/*CON_JNACC*/ 11)] = cdata2[(/*CON_JNACC*/ 11)] = 0;
						} else {
							jnx = 0;
							jny = 0;
						}
					}
				}

				// Apply impulses
				j = (jnx + jny);
				jx = (nx * j);
				jy = (ny * j);

				vx1 -= (jx * im1);
				vy1 -= (jy * im1);
				vw1 -= ((rn1a * jnx) + (rn2a * jny)) * ii1;
				vx2 += (jx * im2);
				vy2 += (jy * im2);
				vw2 += ((rn1b * jnx) + (rn2b * jny)) * ii2;
			} else {
				if (this._contact1._hash === (/*HASH_CIRCLE*/ 0)) {
					// rolling impulse.
					var dw = (vw2 - vw1);
					j = (dw * adata[(/*ARB_RMASS*/ 17)]);
					jMax = (adata[(/*ARB_ROLLING_FRIC*/ 3)] * cdata1[(/*CON_JNACC*/ 11)]);
					jOld = adata[(/*ARB_JRACC*/ 16)];
					cjAcc = (jOld - j);
					if (cjAcc > jMax) {
						cjAcc = jMax;
					} else if (cjAcc < -jMax) {
						cjAcc = -jMax;
					}
					j = (cjAcc - jOld);
					adata[(/*ARB_JRACC*/ 16)] = cjAcc;

					vw1 -= (j * ii1);
					vw2 += (j * ii2);
				}

				// normal impulse.
				vrx1 = (vx2 - (ry2 * vw2)) - (vx1 - (ry1 * vw1));
				vry1 = (vy2 + (rx2 * vw2)) - (vy1 + (rx1 * vw1));

				j = (cdata1[(/*CON_BOUNCE*/ 3)] + surfaceY + ((nx * vrx1) + (ny * vry1))) * cdata1[(/*CON_NMASS*/ 5)];
				jOld = cdata1[(/*CON_JNACC*/ 11)];
				cjAcc = (jOld - j);
				if (cjAcc < 0) {
					cjAcc = 0;
				}
				j = (cjAcc - jOld);
				cdata1[(/*CON_JNACC*/ 11)] = cjAcc;

				jx = (nx * j);
				jy = (ny * j);
				vx1 -= (jx * im1);
				vy1 -= (jy * im1);
				vw1 -= (rn1a * j * ii1);
				vx2 += (jx * im2);
				vy2 += (jy * im2);
				vw2 += (rn1b * j * ii2);
			}

			data1[(/*BODY_VEL*/ 7)] = vx1;
			data1[(/*BODY_VEL*/ 7) + 1] = vy1;
			data1[(/*BODY_VEL*/ 7) + 2] = vw1;
			data2[(/*BODY_VEL*/ 7)] = vx2;
			data2[(/*BODY_VEL*/ 7) + 1] = vy2;
			data2[(/*BODY_VEL*/ 7) + 2] = vw2;
		};

		// =====================================================================
		Physics2DArbiter.prototype._refreshContactData = function () {
			var data1 = this.bodyA._data;
			var data2 = this.bodyB._data;
			var cos1 = data1[(/*BODY_AXIS*/ 5)];
			var sin1 = data1[(/*BODY_AXIS*/ 5) + 1];
			var cos2 = data2[(/*BODY_AXIS*/ 5)];
			var sin2 = data2[(/*BODY_AXIS*/ 5) + 1];
			var px1 = data1[(/*BODY_POS*/ 2)];
			var py1 = data1[(/*BODY_POS*/ 2) + 1];
			var px2 = data2[(/*BODY_POS*/ 2)];
			var py2 = data2[(/*BODY_POS*/ 2) + 1];

			var err, nx, ny;
			var adata = this._data;
			var rad = adata[(/*ARB_RADIUS*/ 14)];
			var cdata1 = this._contact1._data;
			if (this._faceType === (/*FACE_CIRCLE*/ 0)) {
				var x = cdata1[(/*CON_LREL1*/ 13)];
				var y = cdata1[(/*CON_LREL1*/ 13) + 1];
				var rx1 = ((cos1 * x) - (sin1 * y) + px1);
				var ry1 = ((sin1 * x) + (cos1 * y) + py1);

				x = cdata1[(/*CON_LREL2*/ 15)];
				y = cdata1[(/*CON_LREL2*/ 15) + 1];
				var rx2 = ((cos2 * x) - (sin2 * y) + px2);
				var ry2 = ((sin2 * x) + (cos2 * y) + py2);

				var dx = (rx2 - rx1);
				var dy = (ry2 - ry1);
				var dl = Math.sqrt((dx * dx) + (dy * dy));

				nx = adata[(/*ARB_NORMAL*/ 4)];
				ny = adata[(/*ARB_NORMAL*/ 4) + 1];
				if (dl < Physics2DConfig.NORMALIZE_EPSILON) {
					dx = nx;
					dy = ny;
				} else {
					var rec = (1 / dl);
					dx *= rec;
					dy *= rec;
				}

				err = (dl - rad);
				if (((dx * nx) + (dy * ny)) < 0) {
					err -= rad;
					dx = -dx;
					dy = -dy;
				}

				adata[(/*ARB_NORMAL*/ 4)] = dx;
				adata[(/*ARB_NORMAL*/ 4) + 1] = dy;
				var px, py, r1;
				if (this.shapeA._type === (/*TYPE_CIRCLE*/ 0)) {
					r1 = this.shapeA._data[(/*CIRCLE_RADIUS*/ 6)] + (err * 0.5);
					px = cdata1[(/*CON_POS*/ 0)] = (rx1 + (dx * r1));
					py = cdata1[(/*CON_POS*/ 0) + 1] = (ry1 + (dy * r1));
				} else {
					r1 = this.shapeB._data[(/*CIRCLE_RADIUS*/ 6)] + (err * 0.5);
					px = cdata1[(/*CON_POS*/ 0)] = (rx2 - (dx * r1));
					py = cdata1[(/*CON_POS*/ 0) + 1] = (ry2 - (dy * r1));
				}
				cdata1[(/*CON_DIST*/ 2)] = err;
			} else {
				var cdata2 = (this._position2Contact ? this._contact2._data : null);
				var proj;
				var cx1, cx2, cy1, cy2;

				var lx = adata[(/*ARB_LNORM*/ 11)];
				var ly = adata[(/*ARB_LNORM*/ 11) + 1];
				var rx = cdata1[(/*CON_LREL1*/ 13)];
				var ry = cdata1[(/*CON_LREL1*/ 13) + 1];
				if (this._faceType === (/*FACE_1*/ 1)) {
					nx = (lx * cos1) - (ly * sin1);
					ny = (lx * sin1) + (ly * cos1);
					proj = adata[(/*ARB_LPROJ*/ 13)] + ((nx * px1) + (ny * py1));
					cx1 = (px2 + (rx * cos2) - (ry * sin2));
					cy1 = (py2 + (rx * sin2) + (ry * cos2));
					if (cdata2) {
						rx = cdata2[(/*CON_LREL1*/ 13)];
						ry = cdata2[(/*CON_LREL1*/ 13) + 1];
						cx2 = (px2 + (rx * cos2) - (ry * sin2));
						cy2 = (py2 + (rx * sin2) + (ry * cos2));
					}
				} else {
					nx = (lx * cos2) - (ly * sin2);
					ny = (lx * sin2) + (ly * cos2);
					proj = adata[(/*ARB_LPROJ*/ 13)] + ((nx * px2) + (ny * py2));
					cx1 = (px1 + (rx * cos1) - (ry * sin1));
					cy1 = (py1 + (rx * sin1) + (ry * cos1));
					if (cdata2) {
						rx = cdata2[(/*CON_LREL1*/ 13)];
						ry = cdata2[(/*CON_LREL1*/ 13) + 1];
						cx2 = (px1 + (rx * cos1) - (ry * sin1));
						cy2 = (py1 + (rx * sin1) + (ry * cos1));
					}
				}

				var flip = (this._reverse ? -1 : 1);
				adata[(/*ARB_NORMAL*/ 4)] = (flip * nx);
				adata[(/*ARB_NORMAL*/ 4) + 1] = (flip * ny);

				var bias = -proj - rad;

				err = ((cx1 * nx) + (cy1 * ny)) + bias;
				var df = ((err * 0.5) + rad);
				cdata1[(/*CON_POS*/ 0)] = (cx1 - (nx * df));
				cdata1[(/*CON_POS*/ 0) + 1] = (cy1 - (ny * df));
				cdata1[(/*CON_DIST*/ 2)] = err;

				if (cdata2) {
					err = ((cx2 * nx) + (cy2 * ny)) + bias;
					df = ((err * 0.5) + rad);
					cdata2[(/*CON_POS*/ 0)] = (cx2 - (nx * df));
					cdata2[(/*CON_POS*/ 0) + 1] = (cy2 - (ny * df));
					cdata2[(/*CON_DIST*/ 2)] = err;
				}
			}
		};

		Physics2DArbiter.prototype._iteratePosition = function () {
			this._refreshContactData();

			var b1 = this.bodyA;
			var b2 = this.bodyB;
			var data1 = b1._data;
			var data2 = b2._data;
			var im1 = data1[(/*BODY_IMASS*/ 0)];
			var ii1 = data1[(/*BODY_IINERTIA*/ 1)];
			var im2 = data2[(/*BODY_IMASS*/ 0)];
			var ii2 = data2[(/*BODY_IINERTIA*/ 1)];
			var px1 = data1[(/*BODY_POS*/ 2)];
			var py1 = data1[(/*BODY_POS*/ 2) + 1];
			var px2 = data2[(/*BODY_POS*/ 2)];
			var py2 = data2[(/*BODY_POS*/ 2) + 1];

			var px, py, nx, ny, Jx, Jy, jn, dr, Ka, bc;
			var c1r1x, c1r1y, c1r2x, c1r2y, rn1a, rn1b;

			var adata = this._data;
			var cdata1 = this._contact1._data;
			var err1 = cdata1[(/*CON_DIST*/ 2)] + Physics2DConfig.CONTACT_SLOP;
			if (this._position2Contact) {
				var cdata2 = this._contact2._data;
				var err2 = cdata2[(/*CON_DIST*/ 2)] + Physics2DConfig.CONTACT_SLOP;
				if (err1 < 0 || err2 < 0) {
					px = cdata1[(/*CON_POS*/ 0)];
					py = cdata1[(/*CON_POS*/ 0) + 1];
					c1r1x = (px - px1);
					c1r1y = (py - py1);
					c1r2x = (px - px2);
					c1r2y = (py - py2);

					px = cdata2[(/*CON_POS*/ 0)];
					py = cdata2[(/*CON_POS*/ 0) + 1];
					var c2r1x = (px - px1);
					var c2r1y = (py - py1);
					var c2r2x = (px - px2);
					var c2r2y = (py - py2);

					nx = adata[(/*ARB_NORMAL*/ 4)];
					ny = adata[(/*ARB_NORMAL*/ 4) + 1];

					rn1a = (c1r1x * ny) - (c1r1y * nx);
					rn1b = (c1r2x * ny) - (c1r2y * nx);
					var rn2a = (c2r1x * ny) - (c2r1y * nx);
					var rn2b = (c2r2x * ny) - (c2r2y * nx);

					// Non-inverted block effective-mass.
					var massSum = (im1 + im2);
					Ka = massSum + (ii1 * rn1a * rn1a) + (ii2 * rn1b * rn1b);
					var Kb = massSum + (ii1 * rn1a * rn2a) + (ii2 * rn1b * rn2b);
					var Kc = massSum + (ii1 * rn2a * rn2a) + (ii2 * rn2b * rn2b);

					bc = adata[(/*ARB_BIAS*/ 15)];
					var bx = (err1 * bc);
					var by = (err2 * bc);

					// Block solver.
					var det = ((Ka * Kc) - (Kb * Kb));
					var xx, xy;
					if (det === 0) {
						xx = (Ka === 0) ? 0 : (-bx / Ka);
						xy = (Kc === 0) ? 0 : (-by / Kc);
					} else {
						det = (1 / det);
						xx = (det * (Kb * by - Kc * bx));
						xy = (det * (Kb * bx - Ka * by));
					}

					if (xx < 0 || xy < 0) {
						xx = (-bx / Ka);
						xy = 0;
						if (xx < 0 || ((Kb * xx) + by) < 0) {
							xx = 0;
							xy = (-by / Kc);
							if (xy < 0 || ((Kb * xy) + bx) < 0) {
								xx = xy = 0;
							}
						}
					}

					// Apply impulses.
					jn = xx + xy;
					Jx = (nx * jn);
					Jy = (ny * jn);

					px1 -= (Jx * im1);
					py1 -= (Jy * im1);
					dr = -((rn1a * xx) + (rn2a * xy)) * ii1;
					if (dr !== 0) {
						b1._deltaRotation(dr);
					}
					px2 += (Jx * im2);
					py2 += (Jy * im2);
					dr = ((rn1b * xx) + (rn2b * xy)) * ii2;
					if (dr !== 0) {
						b2._deltaRotation(dr);
					}
				}
			} else {
				if (err1 < 0) {
					px = cdata1[(/*CON_POS*/ 0)];
					py = cdata1[(/*CON_POS*/ 0) + 1];

					c1r1x = (px - px1);
					c1r1y = (py - py1);
					c1r2x = (px - px2);
					c1r2y = (py - py2);

					nx = adata[(/*ARB_NORMAL*/ 4)];
					ny = adata[(/*ARB_NORMAL*/ 4) + 1];

					// jac
					rn1a = (c1r1x * ny) - (c1r1y * nx);
					rn1b = (c1r2x * ny) - (c1r2y * nx);

					// eff-mass
					Ka = im2 + (rn1b * rn1b * ii2) + im1 + (rn1a * rn1a * ii1);
					if (Ka !== 0) {
						bc = adata[(/*ARB_BIAS*/ 15)];
						jn = -(bc * err1 / Ka);
						Jx = (nx * jn);
						Jy = (ny * jn);

						px1 -= (Jx * im1);
						py1 -= (Jy * im1);
						dr = -(rn1a * ii1 * jn);
						if (dr !== 0) {
							b1._deltaRotation(dr);
						}
						px2 += (Jx * im2);
						py2 += (Jy * im2);
						dr = (rn1b * ii2 * jn);
						if (dr !== 0) {
							b2._deltaRotation(dr);
						}
					}
				}
			}

			data1[(/*BODY_POS*/ 2)] = px1;
			data1[(/*BODY_POS*/ 2) + 1] = py1;
			data2[(/*BODY_POS*/ 2)] = px2;
			data2[(/*BODY_POS*/ 2) + 1] = py2;
		};

		// =====================================================================
		Physics2DArbiter.prototype._warmStart = function () {
			var data1 = this.bodyA._data;
			var data2 = this.bodyB._data;
			var im1 = data1[(/*BODY_IMASS*/ 0)];
			var ii1 = data1[(/*BODY_IINERTIA*/ 1)];
			var im2 = data2[(/*BODY_IMASS*/ 0)];
			var ii2 = data2[(/*BODY_IINERTIA*/ 1)];

			var adata = this._data;
			var nx = adata[(/*ARB_NORMAL*/ 4)];
			var ny = adata[(/*ARB_NORMAL*/ 4) + 1];

			var cdata = this._contact1._data;
			var jn = cdata[(/*CON_JNACC*/ 11)];
			var jt = cdata[(/*CON_JTACC*/ 12)];

			var jx = (nx * jn) - (ny * jt);
			var jy = (ny * jn) + (nx * jt);
			data1[(/*BODY_VEL*/ 7)] -= (jx * im1);
			data1[(/*BODY_VEL*/ 7) + 1] -= (jy * im1);
			data1[(/*BODY_VEL*/ 7) + 2] -= ((cdata[(/*CON_REL1*/ 7)] * jy) - (cdata[(/*CON_REL1*/ 7) + 1] * jx)) * ii1;
			data2[(/*BODY_VEL*/ 7)] += (jx * im2);
			data2[(/*BODY_VEL*/ 7) + 1] += (jy * im2);
			data2[(/*BODY_VEL*/ 7) + 2] += ((cdata[(/*CON_REL2*/ 9)] * jy) - (cdata[(/*CON_REL2*/ 9) + 1] * jx)) * ii2;

			if (this._velocity2Contact) {
				cdata = this._contact2._data;
				jn = cdata[(/*CON_JNACC*/ 11)];
				jt = cdata[(/*CON_JTACC*/ 12)];

				jx = (nx * jn) - (ny * jt);
				jy = (ny * jn) + (nx * jt);
				data1[(/*BODY_VEL*/ 7)] -= (jx * im1);
				data1[(/*BODY_VEL*/ 7) + 1] -= (jy * im1);
				data1[(/*BODY_VEL*/ 7) + 2] -= ((cdata[(/*CON_REL1*/ 7)] * jy) - (cdata[(/*CON_REL1*/ 7) + 1] * jx)) * ii1;
				data2[(/*BODY_VEL*/ 7)] += (jx * im2);
				data2[(/*BODY_VEL*/ 7) + 1] += (jy * im2);
				data2[(/*BODY_VEL*/ 7) + 2] += ((cdata[(/*CON_REL2*/ 9)] * jy) - (cdata[(/*CON_REL2*/ 9) + 1] * jx)) * ii2;
			} else if (this._contact1._hash === (/*HASH_CIRCLE*/ 0)) {
				jn = adata[(/*ARB_JRACC*/ 16)];

				data1[(/*BODY_VEL*/ 7) + 2] -= (jn * ii1);
				data2[(/*BODY_VEL*/ 7) + 2] += (jn * ii2);
			}
		};

		Physics2DArbiter.prototype.getImpulseForBody = function (body, dst /*v3*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(3);
			}

			var adata = this._data;
			var nx = adata[(/*ARB_NORMAL*/ 4)];
			var ny = adata[(/*ARB_NORMAL*/ 4) + 1];

			var cdata = this._contact1._data;
			var jn = cdata[(/*CON_JNACC*/ 11)];
			var jt = cdata[(/*CON_JTACC*/ 12)];

			var jx = (nx * jn) - (ny * jt);
			var jy = (ny * jn) + (nx * jt);

			var sumX = 0;
			var sumY = 0;
			var sumW = 0;
			if (body === this.bodyA) {
				sumX -= jx;
				sumY -= jy;
				sumW -= ((cdata[(/*CON_REL1*/ 7)] * jy) - (cdata[(/*CON_REL1*/ 7) + 1] * jx));
			} else if (body === this.bodyB) {
				sumX += jx;
				sumY += jy;
				sumW += ((cdata[(/*CON_REL2*/ 9)] * jy) - (cdata[(/*CON_REL2*/ 9) + 1] * jx));
			}

			if (this._velocity2Contact) {
				cdata = this._contact2._data;
				jn = cdata[(/*CON_JNACC*/ 11)];
				jt = cdata[(/*CON_JTACC*/ 12)];

				jx = (nx * jn) - (ny * jt);
				jy = (ny * jn) + (nx * jt);
				if (body === this.bodyA) {
					sumX -= jx;
					sumY -= jy;
					sumW -= ((cdata[(/*CON_REL1*/ 7)] * jy) - (cdata[(/*CON_REL1*/ 7) + 1] * jx));
				} else if (body === this.bodyB) {
					sumX += jx;
					sumY += jy;
					sumW += ((cdata[(/*CON_REL2*/ 9)] * jy) - (cdata[(/*CON_REL2*/ 9) + 1] * jx));
				}
			} else if (this._contact1._hash === (/*HASH_CIRCLE*/ 0)) {
				jn = adata[(/*ARB_JRACC*/ 16)];
				sumW += (body === this.bodyA ? -1 : (body === this.bodyB ? 1 : 0)) * jn;
			}

			dst[0] = sumX;
			dst[1] = sumY;
			dst[2] = sumW;
			return dst;
		};

		Physics2DArbiter.allocate = function () {
			if (!this.pool) {
				return new Physics2DArbiter();
			} else {
				var arb = this.pool;
				this.pool = arb._next;
				arb._next = null;
				return arb;
			}
		};
		Physics2DArbiter.deallocate = function (arb) {
			arb._next = this.pool;
			this.pool = arb;

			arb._userdef = 0;
		};
		Physics2DArbiter.version = 1;

		Physics2DArbiter.pool = null;
		return Physics2DArbiter;
})
define(
	'spell/physics/2D/World',
	[
		'spell/physics/2D/Config',
		'spell/physics/2D/Arbiter',
		'spell/physics/2D/BoxTreeBroadphase',
		'spell/physics/2D/CollisionUtils',
		'spell/physics/2D/Polygon',
		'spell/physics/2D/Circle',
		'spell/physics/2D/Island',
		'spell/physics/2D/Callback',
		'spell/physics/2D/TOIEvent',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Physics2DArbiter,
		Physics2DBoxTreeBroadphase,
		Physics2DCollisionUtils,
		Physics2DPolygon,
		Physics2DCircle,
		Physics2DIsland,
		Physics2DCallback,
		Physics2DTOIEvent,
		Types
		) {
		var Physics2DWorld = function() {
		}

		Physics2DWorld.prototype.getGravity = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}

			dst[0] = this._gravityX;
			dst[1] = this._gravityY;
			return dst;
		};

		Physics2DWorld.prototype.setGravity = function (gravity /*v2*/ ) {
			var newX = gravity[0];
			var newY = gravity[1];
			if (newX !== this._gravityX || newY !== this._gravityY) {
				this._gravityX = newX;
				this._gravityY = newY;

				var bodies = this.rigidBodies;
				var limit = bodies.length;
				var i;
				for (i = 0; i < limit; i += 1) {
					this._wakeBody(bodies[i]);
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._addShape = function (shape) {
			var body = shape.body;
			body._update();

			var isStaticHandle = ((body._type === (/*TYPE_STATIC*/ 2)) || body.sleeping);
			shape._bphaseHandle = this.broadphase.insert(shape, shape._data, isStaticHandle);
		};

		// precon: body was woken before calling this method.
		//         therefore all arbiters are in the world as
		//         non-sleeping.
		Physics2DWorld.prototype._removeShape = function (shape, noCallbacks) {
			var body = shape.body;
			this.broadphase.remove(shape._bphaseHandle);
			shape._bphaseHandle = null;

			var arbiters = shape.arbiters;
			while (arbiters.length !== 0) {
				var arb = arbiters.pop();
				if (arb._retired) {
					continue;
				}

				if (arb.bodyA !== body && arb.bodyA._type === (/*TYPE_DYNAMIC*/ 0)) {
					this._wakeBody(arb.bodyA);
				}
				if (arb.bodyB !== body && arb.bodyB._type === (/*TYPE_DYNAMIC*/ 0)) {
					this._wakeBody(arb.bodyB);
				}

				arb._lazyRetire(shape);
				if (!noCallbacks) {
					this._pushInteractionEvents((/*EVENT_END*/ 3), arb);
				}
			}
		};

		// Call on constraint when:
		//  A)  active (outside world), and then added to world
		//  B)  in world (inactive), and then enabled
		Physics2DWorld.prototype._enabledConstraint = function (constraint) {
			// prepare constraint for disjoint set forest.
			constraint._islandRoot = constraint;
			constraint._islandRank = 0;

			if (!constraint.sleeping) {
				constraint.sleeping = true; // force wake.
				this._wakeConstraint(constraint, true);
			}
		};

		// Call on constraint when:
		//  A)  active (in world), and then removed from world
		//  B)  in world (active), and then disabled.
		Physics2DWorld.prototype._disabledConstraint = function (constraint) {
			this._wakeConstraint(constraint);

			var constraints = this.liveConstraints;
			var index = constraints.indexOf(constraint);
			constraints[index] = constraints[constraints.length - 1];
			constraints.pop();
		};

		Physics2DWorld.prototype.addConstraint = function (constraint) {
			if (constraint.world) {
				return false;
			}

			constraint.world = this;
			this.constraints.push(constraint);

			constraint._inWorld();

			if (constraint._active) {
				this._enabledConstraint(constraint);
			}

			return true;
		};

		Physics2DWorld.prototype.removeConstraint = function (constraint) {
			if (constraint.world !== this) {
				return false;
			}

			var constraints = this.constraints;
			var index = constraints.indexOf(constraint);
			constraints[index] = constraints[constraints.length - 1];
			constraints.pop();

			if (constraint._active) {
				this._disabledConstraint(constraint);
			}

			constraint.world = null;
			constraint._outWorld();

			return true;
		};

		Physics2DWorld.prototype.addRigidBody = function (body) {
			if (body.world) {
				return false;
			}

			body.world = this;
			this.rigidBodies.push(body);

			body._update();

			var i;
			var shapes = body.shapes;
			var limit = shapes.length;
			for (i = 0; i < limit; i += 1) {
				this._addShape(shapes[i]);
			}

			if (body._type === (/*TYPE_STATIC*/ 2)) {
				body.sleeping = true;
				return true;
			}

			// prepare body for disjoint set forest.
			body._islandRoot = body;
			body._islandRank = 0;

			if (!body.sleeping) {
				body.sleeping = true; //force wake.
				this._wakeBody(body, true);
			}

			return true;
		};

		Physics2DWorld.prototype.removeRigidBody = function (body, noCallbacks) {
			if (body.world !== this) {
				return false;
			}

			this._wakeBody(body);

			body.world = null;
			var rigidBodies = this.rigidBodies;
			var index = rigidBodies.indexOf(body);
			rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
			rigidBodies.pop();

			if (!body.sleeping && (body._type !== (/*TYPE_STATIC*/ 2))) {
				if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
					rigidBodies = this.liveDynamics;
				} else {
					rigidBodies = this.liveKinematics;
				}

				index = rigidBodies.indexOf(body);
				rigidBodies[index] = rigidBodies[rigidBodies.length - 1];
				rigidBodies.pop();
			}

			var i;
			var shapes = body.shapes;
			var limit = shapes.length;
			for (i = 0; i < limit; i += 1) {
				this._removeShape(shapes[i], noCallbacks);
			}

			// Remove constraints!
			var constraints = body.constraints;
			while (constraints.length > 0) {
				this.removeConstraint(constraints[0]);
			}

			return true;
		};

		// =====================================================================
		Physics2DWorld.prototype.clear = function () {
			// Clean up rigidBodies, liveDynamics, liveKinematics
			var bodies = this.rigidBodies;
			var limit = bodies.length;
			while (limit > 0) {
				limit -= 1;
				this.removeRigidBody(bodies[limit], true);
			}

			// Clean up constraints, liveConstraints
			var constraints = this.constraints;
			limit = constraints.length;
			while (limit > 0) {
				limit -= 1;
				this.removeConstraint(constraints[limit]);
			}

			// Clean up dynamicArbiters, staticArbiters
			this._clearArbiters(this.staticArbiters);
			this._clearArbiters(this.dynamicArbiters);

			// Clean up any deferred callbacks generated
			// outside of world::step()
			// (Waking a constraint/body indirectly)
			// (Removing a shape)
			var callbacks = this._callbacks;
			limit = callbacks.length;
			while (limit > 0) {
				limit -= 1;
				Physics2DCallback.deallocate(callbacks.pop());
			}
			// _island, _toiEvents already empty
			// broadphase already clear by removal of shapes.
		};

		Physics2DWorld.prototype._clearArbiters = function (arbiters) {
			var limit = arbiters.length;
			while (limit > 0) {
				var arb = arbiters.pop();
				limit -= 1;

				arb._retire();
				Physics2DArbiter.deallocate(arb);
			}
		};

		// =====================================================================
		Physics2DWorld.prototype.shapePointQuery = function (point /*v2*/ , store) {
			return this._pointQuery(this._shapePointCallback, point, store);
		};

		Physics2DWorld.prototype.bodyPointQuery = function (point /*v2*/ , store) {
			return this._pointQuery(this._bodyPointCallback, point, store);
		};

		Physics2DWorld.prototype._pointQuery = function (callback, point, store) {
			var rect = this._sampleRectangle;
			rect[0] = rect[2] = point[0];
			rect[1] = rect[3] = point[1];

			callback.store = store;
			callback.count = 0;
			this.broadphase.sample(rect, callback.sample, callback);
			return callback.count;
		};

		// -------------------------------------
		Physics2DWorld.prototype.shapeCircleQuery = function (center /*v2*/ , radius, store) {
			return this._circleQuery(this._shapeCircleCallback, center, radius, store);
		};

		Physics2DWorld.prototype.bodyCircleQuery = function (center /*v2*/ , radius, store) {
			return this._circleQuery(this._bodyCircleCallback, center, radius, store);
		};

		Physics2DWorld.prototype._circleQuery = function (callback, center, radius, store) {
			var circle = this._circleQueryShape;
			circle.setRadius(radius);

			var posX = center[0];
			var posY = center[1];
			circle._update(posX, posY, 1, 0);

			var rect = this._sampleRectangle;
			rect[0] = (posX - radius);
			rect[1] = (posY - radius);
			rect[2] = (posX + radius);
			rect[3] = (posY + radius);

			callback.store = store;
			callback.count = 0;
			this.broadphase.sample(rect, callback.sample, callback);
			return callback.count;
		};

		// -------------------------------------
		Physics2DWorld.prototype.shapeRectangleQuery = function (aabb /*v4*/ , store) {
			return this._rectangleQuery(this._shapeRectangleCallback, aabb, store);
		};

		Physics2DWorld.prototype.bodyRectangleQuery = function (aabb /*v4*/ , store) {
			return this._rectangleQuery(this._bodyRectangleCallback, aabb, store);
		};

		Physics2DWorld.prototype._rectangleQuery = function (callback, aabb, store) {
			var vertices = this._rectangleQueryVertices;

			var x1 = aabb[0];
			var y1 = aabb[1];
			var x2 = aabb[2];
			var y2 = aabb[3];
			vertices[0][0] = vertices[3][0] = (x1 < x2 ? x1 : x2);
			vertices[0][1] = vertices[1][1] = (y1 < y2 ? y1 : y2);
			vertices[1][0] = vertices[2][0] = (x1 < x2 ? x2 : x1);
			vertices[2][1] = vertices[3][1] = (y1 < y2 ? y2 : y1);

			var poly = this._rectangleQueryShape;
			poly.setVertices(vertices);
			poly._update(0, 0, 1, 0);

			callback.store = store;
			callback.count = 0;
			this.broadphase.sample(aabb, callback.sample, callback);
			return callback.count;
		};

		// =====================================================================
		Physics2DWorld.prototype.rayCast = function (ray, noInnerSurfaces, customCallback, thisObject) {
			var origin = ray.origin;
			var direction = ray.direction;
			var maxFactor = ray.maxFactor;
			var x1 = origin[0];
			var y1 = origin[1];
			var x2 = x1 + (direction[0] * maxFactor);
			var y2 = y1 + (direction[1] * maxFactor);

			var rect = this._sampleRectangle;
			rect[0] = (x1 < x2 ? x1 : x2);
			rect[1] = (y1 < y2 ? y1 : y2);
			rect[2] = (x1 < x2 ? x2 : x1);
			rect[3] = (y1 < y2 ? y2 : y1);

			var callback = this._rayCast;
			callback.ray = ray;
			callback.noInner = (noInnerSurfaces || false);
			callback.minFactor = ray.maxFactor;
			callback.userCallback = customCallback;
			callback.userThis = thisObject;
			callback.minShape = null;
			this.broadphase.sample(rect, callback.sample, callback);

			if (callback.minShape) {
				var data = callback.minNormal;
				var hitNormal = Types.createFloatArray(2);
				var hitPoint = Types.createFloatArray(2);
				hitNormal[0] = data[0];
				hitNormal[1] = data[1];
				hitPoint[0] = (x1 + (direction[0] * callback.minFactor));
				hitPoint[1] = (y1 + (direction[1] * callback.minFactor));
				return {
					shape: callback.minShape,
					hitNormal: hitNormal,
					hitPoint: hitPoint,
					factor: callback.minFactor
				};
			} else {
				return null;
			}
		};

		Physics2DWorld.prototype.convexCast = function (shape, deltaTime, customCallback, thisObject) {
			var body = shape.body;
			var bdata = body._data;
			var preX = bdata[(/*BODY_POS*/ 2)];
			var preY = bdata[(/*BODY_POS*/ 2) + 1];
			body._sweepIntegrate(deltaTime);
			var curX = bdata[(/*BODY_POS*/ 2)];
			var curY = bdata[(/*BODY_POS*/ 2) + 1];

			var rect = this._sampleRectangle;
			var radius = shape._data[(/*SHAPE_SWEEP_RADIUS*/ 4)];
			rect[0] = ((preX < curX ? preX : curX) - radius);
			rect[1] = ((preY < curY ? preY : curY) - radius);
			rect[2] = ((preX < curX ? curX : preX) + radius);
			rect[3] = ((preY < curY ? curY : preY) + radius);

			body[(/*BODY_SWEEP_ANGVEL*/ 20)] = body[(/*BODY_VEL*/ 7) + 2];

			var callback = this._convexCast;
			callback.deltaTime = deltaTime;
			callback.minTOIAlpha = 1;
			callback.minShape = null;
			callback.toi.shapeA = shape;
			callback.userCallback = customCallback;
			callback.userThis = thisObject;
			this.broadphase.sample(rect, callback.sample, callback);

			// reset sweep body and shape.
			body._sweepIntegrate(0);
			shape._update(preX, preY, bdata[(/*BODY_AXIS*/ 5)], bdata[(/*BODY_AXIS*/ 5) + 1], true);

			if (callback.minShape) {
				var data = callback.minData;
				var hitNormal = Types.createFloatArray(2);
				var hitPoint = Types.createFloatArray(2);
				hitNormal[0] = -data[0];
				hitNormal[1] = -data[1];
				hitPoint[0] = data[2];
				hitPoint[1] = data[3];
				return {
					shape: callback.minShape,
					hitNormal: hitNormal,
					hitPoint: hitPoint,
					factor: (callback.minTOIAlpha * deltaTime)
				};
			} else {
				return null;
			}
		};

		// =====================================================================
		Physics2DWorld.prototype.step = function (deltaTime) {
			this._midStep = true;
			this._eventTime = (/*EVENT_TIME_STANDARD*/ 0);
			this.timeStamp += 1;
			this._deltaTime = deltaTime;
			this.simulatedTime += deltaTime;

			// Update objects for current position/rotation
			// As well as preparing delayed WAKE callbacks.
			this._validate();

			// Perform discrete collision detection
			this._discreteCollisions();

			// Perform sleeping
			this._sleepComputations(deltaTime);

			// Pre-step arbiters
			this._preStep(deltaTime);

			// Sort arbiters
			this._sortArbiters();

			// Integrate velocities
			this._integrateVelocity(deltaTime);

			// Warm start arbiters
			this._warmStart();

			// Velocity iterators.
			this._iterateVelocity(this.velocityIterations);

			// Integrate positions and prepare for continuous collision detection.
			this._integratePosition(deltaTime);

			// Perform continous collision detection
			this._eventTime = (/*EVENT_TIME_CONTINUOUS*/ 1);
			this._continuousCollisions(deltaTime);

			// Sort arbiters (continuous may have inserted more).
			this._sortArbiters();

			// Positional iterationrs
			this._iteratePosition(this.positionIterations);

			// Finalize bodies, invalidating if necessary
			// Put kinematics that have not moved to sleep
			// Finalize contact positions, generate interaction callbacks.
			this._finalize();

			// Issue callbacks
			this._midStep = false;
			this._eventTime = (/*EVENT_TIME_PRE*/ -1);
			this._doCallbacks();
		};

		// =========================================================================
		// =========================================================================
		Physics2DWorld.prototype._discreteCollisions = function () {
			this.broadphase.perform(this._discreteNarrowPhase, this);
			this._doDeferredWake(false);
		};

		Physics2DWorld.prototype._doDeferredWake = function (continuous) {
			// Waking of bodies by collision must be deferred,
			// Broadphase must not be modified during 'perform' call.
			var wakes = this._deferredWake;
			var limit = wakes.length;
			while (limit > 0) {
				var body = wakes.pop();
				body._deferred = false;

				// In the case of waking bodies after continuous collisions.
				// We must prestep the arbiters both for correct physics
				// and for callbacks to be properly generated (progress on sleeping arbiters).
				//
				// This is given by the continuous argument.
				this._wakeBody(body, false, continuous);
				limit -= 1;
			}
		};

		Physics2DWorld.prototype._collisionType = function (s1, s2, b1, b2) {
			if (b1 === b2) {
				return undefined;
			}

			var constraints = ((b1.constraints.length < b2.constraints.length) ? b1.constraints : b2.constraints);
			var limit = constraints.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var con = constraints[i];
				if (con._active && con._ignoreInteractions && con._pairExists(b1, b2)) {
					return undefined;
				}
			}

			/*jshint bitwise: false*/
			if ((s1._group & s2._mask) === 0 || (s2._group & s1._mask) === 0) {
				return undefined;
			}

			var collisionType = !(s1.sensor || s2.sensor);

			// Interaction between two static/kinematics cannot be
			// a collision type.
			if (b1._type !== (/*TYPE_DYNAMIC*/ 0) && b2._type !== (/*TYPE_DYNAMIC*/ 0) && collisionType) {
				return undefined;
			}

			return collisionType;
		};

		Physics2DWorld.prototype._discreteNarrowPhase = function (handleA, handleB, continuous) {
			var s1 = handleA.data;
			var s2 = handleB.data;

			var b1 = s1.body;
			var b2 = s2.body;

			var ctype = this._collisionType(s1, s2, b1, b2);
			if (ctype === undefined) {
				// No interaction wanted.
				return null;
			}

			var staticType = (b1._type !== (/*TYPE_DYNAMIC*/ 0) || b2._type !== (/*TYPE_DYNAMIC*/ 0));

			// Order shapes by id for consistent Arbiter lookup without two-way check.
			var sa, sb;
			if (s1.id < s2.id) {
				sa = s1;
				sb = s2;
			} else {
				sa = s2;
				sb = s1;
			}

			// Search for existing Arbiter using smallest of shapes' arbiters lists.
			var arbiters = (sa.arbiters.length < sb.arbiters.length ? sa : sb).arbiters;
			var limit = arbiters.length;
			var i;
			var arb;
			for (i = 0; i < limit; i += 1) {
				var sarb = arbiters[i];
				if (sarb.shapeA === sa && sarb.shapeB === sb) {
					arb = sarb;
					break;
				}
			}

			var first = (!arb);
			if (first) {
				arb = Physics2DArbiter.allocate();
			}

			// Ensure we do not check collisions again in the same time step
			// Unless we are performing continuous collisions.
			if (first || arb._timeStamp !== this.timeStamp || continuous) {
				arb._timeStamp = this.timeStamp;
				if ((ctype && this._collisions._collide(sa, sb, arb)) || (!ctype && this._collisions._test(sa, sb))) {
					if (first) {
						arb.sensor = (!ctype);
						arb._assign(sa, sb);
						arb._static = staticType;
						if (staticType) {
							this.staticArbiters.push(arb);
						} else {
							this.dynamicArbiters.push(arb);
						}
					}

					// Expressions check the two cases where an arbiter is re-used
					// without a retirement inbetween, and which correspond to a
					// 'fresh' collision.
					if (first || (arb._endGenerated === this.timeStamp && continuous) || (arb._updateStamp < (this.timeStamp - 1))) {
						arb._createContinuous = continuous;
						arb._createStamp = this.timeStamp;

						// Sensor type interaction takes no presolve events.
						// so we immediately set state to ACCEPT|ALWAYS
						/*jshint bitwise: false*/
						arb._state = (ctype ? 0 : ((/*STATE_ACCEPT*/ 1) | (/*STATE_ALWAYS*/ 2)));
						/*jshint bitwise: true*/
					}

					arb._updateStamp = this.timeStamp;

					var anyIndeterminate = false;

					// Check pre solve events in collision interactino type case.
					/*jshint bitwise: false*/
					if (ctype && (arb._state & (/*STATE_ALWAYS*/ 2)) === 0) {
						// Reset to default of ACCEPT, but not ALWAYS
						// so that if no events are yet added, and one is then added
						// it will be called.
						arb._state = (/*STATE_ACCEPT*/ 1);
						arb._midStep = true;

						var events = sa._onPreSolve;
						limit = events.length;
						var eventObject;
						for (i = 0; i < limit; i += 1) {
							eventObject = events[i];
							eventObject.callback.call(eventObject.thisObject, arb, sb);
							if (!eventObject.deterministic) {
								anyIndeterminate = true;
							}
						}

						events = sb._onPreSolve;
						limit = events.length;
						for (i = 0; i < limit; i += 1) {
							eventObject = events[i];
							eventObject.callback.call(eventObject.thisObject, arb, sa);
							if (!eventObject.deterministic) {
								anyIndeterminate = true;
							}
						}

						arb._midStep = false;
						arb._indeterminate = anyIndeterminate;

						// Imdeterministic, arbiter state must prevent objects
						// from being put to sleep!
						/*jshint bitwise: false*/
						if (anyIndeterminate && (arb._state & (/*STATE_ALWAYS*/ 2)) === 0) {
							// we do not check they are sleeping before waking
							// so that they may never sleep (wake time will be updated).
							// Otherwise they could sleep if both were to be put to sleep at same
							// time, or if it is a dynamic-static pair etc.
							if (b1._type === (/*TYPE_DYNAMIC*/ 0) && !b1._deferred) {
								b1._deferred = true;
								this._deferredWake.push(b1);
							}
							if (b2._type === (/*TYPE_DYNAMIC*/ 0) && !b1._deferred) {
								b2._deferred = true;
								this._deferredWake.push(b2);
							}
						}
					}

					/*jshint bitwise: false*/
					if (ctype && ((arb._state & (/*STATE_ACCEPT*/ 1)) !== 0)) {
						if (b1._type === (/*TYPE_DYNAMIC*/ 0) && b1.sleeping && !b1._deferred) {
							b1._deferred = true;
							this._deferredWake.push(b1);
						}
						if (b2._type === (/*TYPE_DYNAMIC*/ 0) && b2.sleeping && !b2._deferred) {
							b2._deferred = true;
							this._deferredWake.push(b2);
						}
					}

					if (arb.sleeping) {
						this._wakeArbiter(arb);
					}
				} else if (first) {
					Physics2DArbiter.deallocate(arb);
					arb = null;
				}
			}

			return arb;
		};

		// =====================================================================
		Physics2DWorld.prototype._continuousCollisions = function (deltaTime) {
			this.broadphase.perform(this._continuousNarrowPhase, this);

			var curTimeAlpha = 0.0;
			var toiEvents = this._toiEvents;
			var limit = toiEvents.length;
			var toi, i;
			while (curTimeAlpha < 1.0 && limit !== 0) {
				var minTOIAlpha = Number.POSITIVE_INFINITY;
				var minKinematic = false;
				var min = -1;

				var b1, b2;
				for (i = 0; i < limit;) {
					toi = toiEvents[i];
					b1 = toi.shapeA.body;
					b2 = toi.shapeB.body;

					// TOI invalid.
					if (b1._sweepFrozen && b2._sweepFrozen) {
						limit -= 1;
						toiEvents[i] = toiEvents[limit];
						toiEvents.pop();
						Physics2DTOIEvent.deallocate(toi);
						continue;
					}

					// TOI invalidated.
					if (toi.frozenA !== b1._sweepFrozen || toi.frozenB !== b2._sweepFrozen) {
						// Recompute TOI
						toi.frozenA = b1._sweepFrozen;
						toi.frozenB = b2._sweepFrozen;

						// Check if order of objects in event need swapped
						// (_staticSweep restrictions on order)
						if (toi.frozenA) {
							var tmp = toi.shapeA;
							toi.shapeA = toi.shapeB;
							toi.shapeB = tmp;
							toi.frozenA = false;
							toi.frozenB = true;
						}

						this._collisions._staticSweep(toi, deltaTime, Physics2DConfig.SWEEP_SLOP);
						if (toi._data[(/*TOI_TOI_ALPHA*/ 6)] < 0) {
							limit -= 1;
							toiEvents[i] = toiEvents[limit];
							toiEvents.pop();
							Physics2DTOIEvent.deallocate(toi);
							continue;
						}
					}

					var curTOIAlpha = toi._data[(/*TOI_TOI_ALPHA*/ 6)];
					if (curTOIAlpha >= 0 && (curTOIAlpha < minTOIAlpha || (!minKinematic && toi.kinematic))) {
						minTOIAlpha = curTOIAlpha;
						minKinematic = toi.kinematic;
						min = i;
					}

					i += 1;
				}

				if (min === -1) {
					break;
				}

				// Remove TOI event from list
				toi = toiEvents[min];
				limit -= 1;
				toiEvents[min] = toiEvents[limit];
				toiEvents.pop();

				// Advance time alpha
				curTimeAlpha = minTOIAlpha;

				var s1 = toi.shapeA;
				var s2 = toi.shapeB;
				b1 = s1.body;
				b2 = s2.body;
				var data1 = b1._data;
				var data2 = b2._data;

				// Update body (and collided shapes) to TOI.
				if (!b1._sweepFrozen || toi.kinematic) {
					b1._sweepIntegrate(curTimeAlpha * deltaTime);
					s1._update(data1[(/*BODY_POS*/ 2)], data1[(/*BODY_POS*/ 2) + 1], data1[(/*BODY_AXIS*/ 5)], data1[(/*BODY_AXIS*/ 5) + 1], true);
				}
				if (!b2._sweepFrozen || toi.kinematic) {
					b2._sweepIntegrate(curTimeAlpha * deltaTime);
					s2._update(data2[(/*BODY_POS*/ 2)], data2[(/*BODY_POS*/ 2) + 1], data2[(/*BODY_AXIS*/ 5)], data2[(/*BODY_AXIS*/ 5) + 1], true);
				}

				var arb = this._discreteNarrowPhase(s1._bphaseHandle, s2._bphaseHandle, true);
				if (arb) {
					// Discrete collision detected, pre-step for position iterations
					// (For sensors, issue begin callbacks if appropriate)
					this._continuousArbiterPrepare(arb, deltaTime);
				}

				/*jshint bitwise: false*/
				if (arb && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					// Freeze objects
					if (!b1._sweepFrozen && b1._type === (/*TYPE_DYNAMIC*/ 0)) {
						b1._sweepFrozen = true;
						if (toi.failed) {
							data1[(/*BODY_SWEEP_ANGVEL*/ 20)] = 0;
						} else if (toi.slipped) {
							data1[(/*BODY_SWEEP_ANGVEL*/ 20)] *= Physics2DConfig.TOI_SLIP_SCALE;
						}
						data1[(/*BODY_VEL*/ 7) + 2] = data1[(/*BODY_SWEEP_ANGVEL*/ 20)];
					}
					if (!b2._sweepFrozen && b2._type === (/*TYPE_DYNAMIC*/ 0)) {
						b2._sweepFrozen = true;
						if (toi.failed) {
							data2[(/*BODY_SWEEP_ANGVEL*/ 20)] = 0;
						} else if (toi.slipped) {
							data2[(/*BODY_SWEEP_ANGVEL*/ 20)] *= Physics2DConfig.TOI_SLIP_SCALE;
						}
						data2[(/*BODY_VEL*/ 7) + 2] = data2[(/*BODY_SWEEP_ANGVEL*/ 20)];
					}
				}

				Physics2DTOIEvent.deallocate(toi);
			}

			while (limit > 0) {
				toi = toiEvents.pop();
				Physics2DTOIEvent.deallocate(toi);
				limit -= 1;
			}

			// Advance remaining, unfrozen objects to end of time step.
			var bodies = this.liveDynamics;
			limit = bodies.length;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];
				if (!body._sweepFrozen) {
					body._sweepIntegrate(deltaTime);
				}
			}

			// Advance all kinematics to end of time step.
			bodies = this.liveKinematics;
			limit = bodies.length;
			for (i = 0; i < limit; i += 1) {
				bodies[i]._sweepIntegrate(deltaTime);
			}

			// We do not need to do any more work with sleeping arbiters
			// here like pre-stepping before position iterations
			//
			// Arbiters were sleeping -> objects were sleeping -> data
			// is the same.
			this._doDeferredWake(true);
		};

		Physics2DWorld.prototype._continuousNarrowPhase = function (handleA, handleB) {
			var s1 = handleA.data;
			var s2 = handleB.data;
			var b1 = s1.body;
			var b2 = s2.body;
			if (b1._sweepFrozen && b2._sweepFrozen) {
				return;
			}

			var staticType = (b1._type !== (/*TYPE_DYNAMIC*/ 0) || b2._type !== (/*TYPE_DYNAMIC*/ 0));
			if (staticType || (b1._bullet || b2._bullet)) {
				var toi = Physics2DTOIEvent.allocate();
				var kin = (b1._type === (/*TYPE_KINEMATIC*/ 1) || b2._type === (/*TYPE_KINEMATIC*/ 1));
				if (staticType && !kin) {
					if (b1._type !== (/*TYPE_DYNAMIC*/ 0)) {
						toi.shapeB = s1;
						toi.shapeA = s2;
					} else {
						toi.shapeA = s1;
						toi.shapeB = s2;
					}
					this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
				} else {
					if (s1.body._sweepFrozen) {
						toi.shapeB = s1;
						toi.shapeA = s2;
						this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
					} else if (s2.body._sweepFrozen) {
						toi.shapeA = s1;
						toi.shapeB = s2;
						this._collisions._staticSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
					} else {
						toi.shapeA = s1;
						toi.shapeB = s2;
						this._collisions._dynamicSweep(toi, this._deltaTime, Physics2DConfig.SWEEP_SLOP);
					}
				}

				// Permit dynamic-dynamic events that represent missed collisions
				// to persist as freezing of one of the two objects may cause
				// event to change and we miss too many dynamic-dynamic collisions
				// by not allowing the event to persist.
				if ((staticType && toi._data[(/*TOI_TOI_ALPHA*/ 6)] < 0) || toi.failed) {
					Physics2DTOIEvent.deallocate(toi);
				} else {
					this._toiEvents.push(toi);
					toi.frozenA = toi.shapeA.body._sweepFrozen;
					toi.frozenB = toi.shapeB.body._sweepFrozen;
					toi.staticType = staticType;
					toi.kinematic = kin;
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype.__union = function (x, y) {
			var stack, next;

			while (x !== x._islandRoot) {
				next = x._islandRoot;
				x._islandRoot = stack;
				stack = x;
				x = next;
			}
			while (stack) {
				next = stack._islandRoot;
				stack._islandRoot = x;
				stack = next;
			}

			while (y !== y._islandRoot) {
				next = y._islandRoot;
				y._islandRoot = stack;
				stack = y;
				y = next;
			}
			while (stack) {
				next = stack._islandRoot;
				stack._islandRoot = y;
				stack = next;
			}

			if (x !== y) {
				if (x._islandRank < y._islandRank) {
					x._islandRoot = y;
				} else if (y._islandRank < x._islandRank) {
					y._islandRoot = x;
				} else {
					y._islandRoot = x;
					x._islandRank += 1;
				}
			}
		};

		Physics2DWorld.prototype.__find = function (x) {
			if (x === x._islandRoot) {
				return x;
			}

			var stack = null;
			var next;
			while (x !== x._islandRoot) {
				next = x._islandRoot;
				x._islandRoot = stack;
				stack = x;
				x = next;
			}
			while (stack) {
				next = stack._islandRoot;
				stack._islandRoot = x;
				stack = next;
			}
			return x;
		};

		// =====================================================================
		Physics2DWorld.prototype._sleepComputations = function (deltaTime) {
			// Build disjoint set forest.
			//
			// arb.active not yet computed, so base it on currently available info.
			var arbiters = this.dynamicArbiters;
			var arb;
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				arb = arbiters[i];

				/*jshint bitwise: false*/
				if (!arb.sensor && !arb._retired && arb._updateStamp === this.timeStamp && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					/*jshint bitwise: true*/
					var b1 = arb.bodyA;
					var b2 = arb.bodyB;
					if (b1._type === (/*TYPE_DYNAMIC*/ 0) && b2._type === (/*TYPE_DYNAMIC*/ 0)) {
						this.__union(b1, b2);
					}
				}
			}

			var constraints = this.liveConstraints;
			limit = constraints.length;
			for (i = 0; i < limit; i += 1) {
				constraints[i]._sleepComputation(this.__union);
			}

			// Build islands.
			var islands = this._islands;
			var island, root;
			var bodies = this.liveDynamics;
			limit = bodies.length;
			while (limit > 0) {
				limit -= 1;
				var body = bodies.pop();

				root = this.__find(body);
				island = root._island;
				if (island === null) {
					root._island = island = Physics2DIsland.allocate();
					islands.push(island);
					island.sleeping = true;
					island.wakeTime = 0;
				}
				body._island = island;
				island.components.push(body);

				var atRest = body._atRest(deltaTime, this.timeStamp);
				island.sleeping = (island.sleeping && atRest);
				if (body._wakeTime > island.wakeTime) {
					island.wakeTime = body._wakeTime;
				}
			}

			limit = constraints.length;
			while (limit > 0) {
				limit -= 1;
				var con = constraints.pop();

				root = this.__find(con);
				island = root._island;
				if (island === null) {
					root._island = island = Physics2DIsland.allocate();
					islands.push(island);
					island.sleeping = true;
					island.wakeTime = 0;
				}

				con._island = island;
				island.components.push(con);
				if (con._wakeTime > island.wakeTime) {
					island.wakeTime = con._wakeTime;
				}
			}

			// Build new live lists of bodies and constraints.
			// live lists of arbiters is deferred to preStep.
			// And destroy waking islands.
			limit = islands.length;
			var limit2;
			var bphase = this.broadphase;
			while (limit > 0) {
				limit -= 1;
				island = islands[limit];
				islands.pop();

				var comp, comps;
				if (island.sleeping) {
					comps = island.components;
					limit2 = comps.length;
					var j;
					for (j = 0; j < limit2; j += 1) {
						comp = comps[j];
						comp.sleeping = true;

						if (comp._isBody) {
							var shapes = comp.shapes;
							var limit3 = shapes.length;
							var k;
							for (k = 0; k < limit3; k += 1) {
								var shape = shapes[k];
								bphase.update(shape._bphaseHandle, shape._data, true);
							}
							var data = comp._data;
							data[(/*BODY_VEL*/ 7)] = 0;
							data[(/*BODY_VEL*/ 7) + 1] = 0;
							data[(/*BODY_VEL*/ 7) + 2] = 0;
						}

						// Body + Constraint
						if (comp._onSleep.length > 0) {
							this._pushCallbacks(comp, comp._onSleep);
						}
					}
				} else {
					comps = island.components;
					limit2 = comps.length;
					while (limit2 > 0) {
						limit2 -= 1;
						comp = comps.pop();

						comp._wakeTime = island.wakeTime;
						if (comp._isBody) {
							bodies.push(comp);
						} else {
							constraints.push(comp);
						}

						// Reset island properties
						comp._island = null;
						comp._islandRoot = comp;
						comp._islandRank = 0;
					}

					Physics2DIsland.deallocate(island);
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._sortArbiters = function () {
			this._subSortArbiters(this.dynamicArbiters);
			this._subSortArbiters(this.staticArbiters);
		};

		Physics2DWorld.prototype._subSortArbiters = function (arbiters) {
			// Insertion sort of arbiters list using shape id's as
			// lexicographical keys.
			//
			// Insertion sort is suitable here, as arbiter list will be
			// SUBSTANTIALLY sorted already.
			//
			// We perform this sort so that broadphase has no effect
			// on physics behaviour.
			var i;
			var limit = arbiters.length - 1;
			for (i = 1; i < limit; i += 1) {
				var item = arbiters[i];
				var idA = item.shapeA.id;
				var idB = item.shapeB.id;

				var hole = i;
				while (hole > 0) {
					var cur = arbiters[hole - 1];
					var curIDA = cur.shapeA.id;
					if (curIDA < idA || (curIDA === idA && cur.shapeB.id < idB)) {
						break;
					}

					arbiters[hole] = cur;
					hole -= 1;
				}

				arbiters[hole] = item;
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._onWakeCallbacks = function (component) {
			if (this._midStep) {
				if (component._onWake.length > 0) {
					this._pushCallbacks(component, component._onWake);
				}
			} else {
				component._woken = true;
			}
		};

		Physics2DWorld.prototype._pushCallbacks = function (thisObject, callbacks) {
			var cbs = this._callbacks;
			var limit = callbacks.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var cb = Physics2DCallback.allocate();
				cb.thisObject = thisObject;
				cb.callback = callbacks[i];
				cb.time = this._eventTime;
				cb.index = i;
				cbs.push(cb);
			}
		};

		Physics2DWorld.prototype._pushInteractionEvents = function (eventType, arb) {
			var cbs = this._callbacks;

			var shapeA = arb.shapeA;
			var shapeB = arb.shapeB;

			var groupA = shapeA._group;
			var groupB = shapeB._group;

			// Event listeners on shapeA
			var events = shapeA._events;
			var limit = events.length;
			var i, eventObject, cb;
			for (i = 0; i < limit; i += 1) {
				eventObject = events[i];

				/*jshint bitwise: false*/
				if (eventObject.type === eventType && (eventObject.mask === undefined || ((eventObject.mask & groupB) !== 0))) {
					cb = Physics2DCallback.allocate();
					cb.thisObject = shapeB;
					cb.callback = eventObject.callback;
					cb.time = this._eventTime;
					cb.index = i;
					cb.arbiter = arb;
					cbs.push(cb);
				}
			}

			// Event listeners on shapeB
			events = shapeB._events;
			limit = events.length;
			for (i = 0; i < limit; i += 1) {
				eventObject = events[i];

				/*jshint bitwise: false*/
				if (eventObject.type === eventType && (eventObject.mask === undefined || ((eventObject.mask & groupA) !== 0))) {
					cb = Physics2DCallback.allocate();
					cb.thisObject = shapeA;
					cb.callback = eventObject.callback;
					cb.time = this._eventTime;
					cb.index = i;
					cb.arbiter = arb;
					cbs.push(cb);
				}
			}
		};

		// =====================================================================
		// precon: constraint was removed from live list.
		Physics2DWorld.prototype._brokenConstraint = function (con) {
			if (con._onBreak.length > 0) {
				this._pushCallbacks(con, con._onBreak);
			}

			if (con._removeOnBreak) {
				con.world = null;

				var constraints = this.constraints;
				var index = constraints.indexOf(con);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();

				con._outWorld();
			} else {
				con._active = false;
			}

			con._clearCache();
		};

		Physics2DWorld.prototype._preStep = function (deltaTime) {
			var constraints = this.liveConstraints;
			var limit = constraints.length;
			var i;
			for (i = 0; i < limit;) {
				var con = constraints[i];
				if (con._preStep(deltaTime)) {
					limit -= 1;
					constraints[i] = constraints[limit];
					constraints.pop();
					this._brokenConstraint(con);
					continue;
				}

				i += 1;
			}

			this._preStepArbiters(this.dynamicArbiters, deltaTime);
			this._preStepArbiters(this.staticArbiters, deltaTime);
		};

		// Used in continuous collisions, only want to pre-step a single arbiter.
		Physics2DWorld.prototype._preStepArbiter = function (arb, deltaTime, progressEvents) {
			var timeStamp = this.timeStamp;

			// Should never be the case that arbiter needs to be put to sleep
			// Or needs to be retired, or to issue an end.
			arb.active = (arb._updateStamp === timeStamp);

			// Will however, require a begin callback to be issued in certain
			// cases (Continuous collision). and a progress callback (continuous
			// collision causing objects to be woken).
			if (arb._createContinuous && arb._createStamp === timeStamp) {
				this._pushInteractionEvents((/*EVENT_BEGIN*/ 1), arb);
			} else if (progressEvents && arb.active) {
				this._pushInteractionEvents((/*EVENT_PROGRESS*/ 2), arb);
			}

			if (arb.active) {
				/*jshint bitwise: false*/
				if ((arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					if (!arb._preStep(deltaTime, timeStamp, true)) {
						arb.active = false;
					}
				} else if (!arb.sensor && !arb._cleanContacts(timeStamp)) {
					arb.active = false;
				}
			}
		};

		// Used in usual case, pre stepping whole list of arbiters.
		Physics2DWorld.prototype._preStepArbiters = function (arbiters, deltaTime) {
			var timeStamp = this.timeStamp;
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit;) {
				var arb = arbiters[i];
				if (!arb._retired && (arb.bodyA.sleeping && arb.bodyB.sleeping)) {
					arb._sleepStamp = timeStamp;
					arb.sleeping = true;
					arb.active = false;

					// Issue progress callback for first update that arbiter sleeps!
					this._pushInteractionEvents((/*EVENT_PROGRESS*/ 2), arb);

					limit -= 1;
					arbiters[i] = arbiters[limit];
					arbiters.pop();
					continue;
				}

				// Permit arbiter to exist for 1 further update.
				// So that we can issue end callbacks.
				if (!arb._lazyRetired) {
					if (arb._retired || arb._updateStamp + (arb.sensor ? 1 : Physics2DConfig.DELAYED_DEATH) < timeStamp) {
						arb._retire();
						limit -= 1;
						arbiters[i] = arbiters[limit];
						arbiters.pop();
						Physics2DArbiter.deallocate(arb);
						continue;
					}
				} else {
					arb._lazyRetired = false;
					i += 1;
					continue;
				}

				arb.active = (arb._updateStamp === timeStamp);

				// Set up callbacks.
				if (arb._createStamp === timeStamp) {
					this._pushInteractionEvents((/*EVENT_BEGIN*/ 1), arb);
				} else if (arb.active) {
					this._pushInteractionEvents((/*EVENT_PROGRESS*/ 2), arb);
				} else if (arb._updateStamp === (timeStamp - 1)) {
					this._pushInteractionEvents((/*EVENT_END*/ 3), arb);
					arb._endGenerated = this.timeStamp;
				}

				if (arb.active) {
					/*jshint bitwise: false*/
					if ((arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
						if (!arb._preStep(deltaTime, timeStamp)) {
							arb.active = false;
						}
					} else if (!arb.sensor && !arb._cleanContacts(timeStamp)) {
						arb.active = false;
					}
				}

				i += 1;
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._iterateVelocity = function (count) {
			var constraints = this.liveConstraints;
			while (count > 0) {
				var limit = constraints.length;
				var i;
				for (i = 0; i < limit;) {
					var con = constraints[i];
					if (con._iterateVel()) {
						limit -= 1;
						constraints[i] = constraints[limit];
						constraints.pop();
						this._brokenConstraint(con);
						continue;
					}

					i += 1;
				}

				this._iterateVelocityArbiters(this.dynamicArbiters);
				this._iterateVelocityArbiters(this.staticArbiters);
				count -= 1;
			}
		};

		Physics2DWorld.prototype._iterateVelocityArbiters = function (arbiters) {
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var arb = arbiters[i];

				/*jshint bitwise: false*/
				if (arb.active && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					arb._iterateVelocity();
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._iteratePosition = function (count) {
			var constraints = this.liveConstraints;
			while (count > 0) {
				var limit = constraints.length;
				var i;
				for (i = 0; i < limit;) {
					var con = constraints[i];
					if (con._stiff && con._iteratePos()) {
						limit -= 1;
						constraints[i] = constraints[limit];
						constraints.pop();
						this._brokenConstraint(con);
						continue;
					}

					i += 1;
				}

				this._iteratePositionArbiters(this.dynamicArbiters);
				this._iteratePositionArbiters(this.staticArbiters);
				count -= 1;
			}
		};

		Physics2DWorld.prototype._iteratePositionArbiters = function (arbiters) {
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var arb = arbiters[i];

				/*jshint bitwise: false*/
				if (arb.active && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					arb._iteratePosition();
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._integrateVelocity = function (deltaTime) {
			var gravityX = this._gravityX;
			var gravityY = this._gravityY;

			var bodies = this.liveDynamics;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];
				var data = body._data;

				var imass = data[(/*BODY_IMASS*/ 0)];
				var drag;
				if (imass !== 0) {
					data[(/*BODY_VEL*/ 7)] += ((data[(/*BODY_FORCE*/ 10)] * imass) + gravityX) * deltaTime;
					data[(/*BODY_VEL*/ 7) + 1] += ((data[(/*BODY_FORCE*/ 10) + 1] * imass) + gravityY) * deltaTime;

					drag = Math.exp(deltaTime * data[(/*BODY_LIN_DRAG*/ 21)]);
					data[(/*BODY_VEL*/ 7)] *= drag;
					data[(/*BODY_VEL*/ 7) + 1] *= drag;
				}

				var iinertia = data[(/*BODY_IINERTIA*/ 1)];
				if (iinertia !== 0) {
					data[(/*BODY_VEL*/ 7) + 2] += (data[(/*BODY_FORCE*/ 10) + 2] * iinertia) * deltaTime;
					data[(/*BODY_VEL*/ 7) + 2] *= Math.exp(deltaTime * data[(/*BODY_ANG_DRAG*/ 22)]);
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._integratePosition = function (deltaTime) {
			this._integratePositionBodies(this.liveDynamics, deltaTime);
			this._integratePositionBodies(this.liveKinematics, deltaTime);
		};

		Physics2DWorld.prototype._integratePositionBodies = function (bodies, deltaTime) {
			var MAX_VEL = (2 * Math.PI / deltaTime);
			var idt2 = (1 / (deltaTime * deltaTime));

			var linThreshold = Physics2DConfig.MIN_LINEAR_STATIC_SWEEP;
			var angThreshold = Physics2DConfig.MIN_ANGULAR_STATIC_SWEEP;
			linThreshold *= linThreshold * idt2;
			angThreshold *= angThreshold * idt2;

			var bulletLinThreshold = Physics2DConfig.MIN_LINEAR_BULLET_SWEEP;
			var bulletAngThreshold = Physics2DConfig.MIN_ANGULAR_BULLET_SWEEP;
			bulletLinThreshold *= bulletLinThreshold * idt2;
			bulletAngThreshold *= bulletAngThreshold * idt2;

			var bphase = this.broadphase;

			var limit = bodies.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];
				var data = body._data;
				var preX = data[(/*BODY_PRE_POS*/ 15)] = data[(/*BODY_POS*/ 2)];
				var preY = data[(/*BODY_PRE_POS*/ 15) + 1] = data[(/*BODY_POS*/ 2) + 1];
				data[(/*BODY_PRE_POS*/ 15) + 2] = data[(/*BODY_POS*/ 2) + 2];

				var curX = data[(/*BODY_POS*/ 2)] += (data[(/*BODY_VEL*/ 7)] * deltaTime);
				var curY = data[(/*BODY_POS*/ 2) + 1] += (data[(/*BODY_VEL*/ 7) + 1] * deltaTime);
				var angVel = data[(/*BODY_VEL*/ 7) + 2];
				body._deltaRotation(angVel * deltaTime);

				data[(/*BODY_SWEEP_TIME*/ 18)] = deltaTime;

				// If moving very slowly, treat as static freezing object at t = deltaTime
				var vx = data[(/*BODY_VEL*/ 7)];
				var vy = data[(/*BODY_VEL*/ 7) + 1];
				var vw = data[(/*BODY_SWEEP_ANGVEL*/ 20)] = (angVel % MAX_VEL);

				var rad = data[(/*BODY_RADIUS*/ 19)];
				var lin = (linThreshold * rad * rad);
				var vmag = ((vx * vx) + (vy * vy));
				if (vmag > lin || (vw * vw) > angThreshold) {
					// Compute swept AABB
					var minX = (preX < curX ? preX : curX);
					var minY = (preY < curY ? preY : curY);
					var maxX = (preX < curX ? curX : preX);
					var maxY = (preY < curY ? curY : preY);

					var shapes = body.shapes;
					var limit2 = shapes.length;
					var j;
					for (j = 0; j < limit2; j += 1) {
						var shape = shapes[j];
						var sdata = shape._data;
						rad = sdata[(/*SHAPE_SWEEP_RADIUS*/ 4)];
						sdata[(/*SHAPE_AABB*/ 0)] = (minX - rad);
						sdata[(/*SHAPE_AABB*/ 0) + 1] = (minY - rad);
						sdata[(/*SHAPE_AABB*/ 0) + 2] = (maxX + rad);
						sdata[(/*SHAPE_AABB*/ 0) + 3] = (maxY + rad);

						bphase.update(shape._bphaseHandle, sdata);
					}

					body._sweepFrozen = false;

					if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
						body._bullet = (body.bullet && (vmag > (bulletLinThreshold * rad * rad) || (vw * vw) > bulletAngThreshold));
					}
				} else {
					body._sweepFrozen = true;
					body._bullet = false;
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._finalize = function () {
			this._finalizeBodies(this.liveDynamics);
			this._finalizeBodies(this.liveKinematics);

			// Finalize contact positions for API to be correct at end of step() in queries
			this._finalizeArbiters(this.dynamicArbiters);
			this._finalizeArbiters(this.staticArbiters);
		};

		Physics2DWorld.prototype._finalizeArbiters = function (arbiters) {
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var arb = arbiters[i];
				if (arb.active && !arb.sensor) {
					arb._refreshContactData();
				}
			}
		};

		Physics2DWorld.prototype._finalizeBodies = function (bodies) {
			var bphase = this.broadphase;
			var limit = bodies.length;
			var i;
			for (i = 0; i < limit;) {
				var body = bodies[i];
				var data = body._data;

				var shapes = body.shapes;
				var limit2 = shapes.length;
				var j, shape;

				if (data[(/*BODY_PRE_POS*/ 15)] !== data[(/*BODY_POS*/ 2)] || data[(/*BODY_PRE_POS*/ 15) + 1] !== data[(/*BODY_POS*/ 2) + 1] || data[(/*BODY_PRE_POS*/ 15) + 2] !== data[(/*BODY_POS*/ 2) + 2]) {
					body._invalidated = true;
				} else if (body._type === (/*TYPE_KINEMATIC*/ 1)) {
					limit -= 1;
					bodies[i] = bodies[limit];
					bodies.pop();

					body.sleeping = true;

					for (j = 0; j < limit2; j += 1) {
						shape = shapes[j];
						bphase.update(shape._bphaseHandle, shape._data, true);
					}
					continue;
				}

				i += 1;
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._doCallbacks = function () {
			// Order by event index so as to guarantee that event listeners
			// added first, are processed first.
			//
			// Inlined quick sort, builtin JS.sort was too slow with function comparator.
			var callbacks = this._callbacks;
			var i;
			var stack = [callbacks.length - 1, 0];
			do {
				var left = stack.pop();
				var right = stack.pop();
				if (left > right) {
					continue;
				}

				/*jshint bitwise: false*/
				var pivot = (left + right) >> 1;

				/*jshint bitwise: true*/
				// Partition about center
				var pivotValue = callbacks[pivot];
				var index = left;
				var pIndex = pivotValue.index;
				var pTime = pivotValue.time;

				callbacks[pivot] = callbacks[right];
				callbacks[right] = pivotValue;
				for (i = left; i < right; i += 1) {
					var cur = callbacks[i];
					if (cur.time < pTime || (cur.time === pTime && cur.index < pIndex)) {
						callbacks[i] = callbacks[index];
						callbacks[index] = cur;
						index += 1;
					}
				}
				callbacks[right] = callbacks[index];
				callbacks[index] = pivotValue;

				// index + 1 <-> right
				if (index + 1 < right) {
					stack.push(right);
					stack.push(index + 1);
				}

				// left <-> index - 1
				if (left < index - 1) {
					stack.push(index - 1);
					stack.push(left);
				}
			} while(stack.length > 0);

			// Issue callbacks
			var limit = callbacks.length;
			for (i = 0; i < limit; i += 1) {
				var cb = callbacks[i];
				if (cb.arbiter) {
					// BEGIN/PROGRESS/END
					var arb = cb.arbiter;
					var sa = arb.shapeA;
					var sb = arb.shapeB;
					var thisShape = cb.thisObject;
					cb.callback.call(thisShape, arb, (thisShape === sa ? sb : sa));
				} else {
					// WAKE/SLEEP/BREAK
					cb.callback.call(cb.thisObject);
				}
				Physics2DCallback.deallocate(cb);
			}
			callbacks.length = 0;
		};

		// =====================================================================
		Physics2DWorld.prototype._warmStart = function () {
			var constraints = this.liveConstraints;
			var limit = constraints.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				constraints[i]._warmStart();
			}

			this._warmStartArbiters(this.dynamicArbiters);
			this._warmStartArbiters(this.staticArbiters);
		};

		Physics2DWorld.prototype._warmStartArbiters = function (arbiters) {
			var limit = arbiters.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var arb = arbiters[i];

				/*jshint bitwise: false*/
				if (arb.active && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
					arb._warmStart();
				}
			}
		};

		// =====================================================================
		Physics2DWorld.prototype._forceSleepBody = function (body) {
			if (body.sleeping || body._type !== (/*TYPE_DYNAMIC*/ 0)) {
				return;
			}

			body.sleeping = true;

			var bodies = this.liveDynamics;
			var index = bodies.indexOf(body);
			bodies[index] = bodies[bodies.length - 1];
			bodies.pop();

			var shapes = body.shapes;
			var limit = shapes.length;
			var i;
			var bphase = this.broadphase;
			for (i = 0; i < limit; i += 1) {
				var shape = shapes[i];
				bphase.update(shape._bphaseHandle, shape._data, true);

				// Force arbiters to go to sleep.
				var arbiters = shape.arbiters;
				var limit2 = arbiters.length;
				var j;
				for (j = 0; j < limit2; j += 1) {
					var arb = arbiters[j];
					if (arb._retired || arb.sleeping) {
						continue;
					}

					arb.sleeping = true;
					arb._sleepStamp = this.timeStamp;
					var arbs;
					if (arb._static) {
						arbs = this.staticArbiters;
					} else {
						arbs = this.dynamicArbiters;
					}

					index = arbs.indexOf(arb);
					arbs[index] = arbs[arbs.length - 1];
					arbs.pop();
				}
			}
		};

		Physics2DWorld.prototype._forceSleepConstraint = function (constraint) {
			if (constraint.sleeping) {
				return;
			}

			constraint.sleeping = true;

			if (constraint._active) {
				var constraints = this.liveConstraints;
				var index = constraints.indexOf(constraint);
				constraints[index] = constraints[constraints.length - 1];
				constraints.pop();
			}
		};

		Physics2DWorld.prototype._wakeConstraint = function (constraint, noCallback) {
			if (constraint.world !== this) {
				return;
			}

			if (constraint._active) {
				constraint._wakeTime = (this.timeStamp + (this._midStep ? 0 : 1));
				if (constraint.sleeping) {
					if (!constraint._island) {
						constraint.sleeping = false;
						this.liveConstraints.push(constraint);
						constraint._wakeConnected();

						if (!noCallback) {
							this._onWakeCallbacks(constraint);
						}
					} else {
						this._wakeIsland(constraint._island, (noCallback ? constraint : null));
					}
				}
			}
		};

		Physics2DWorld.prototype._wakeBody = function (body, noCallback, continuousCallbacks) {
			if (body.world !== this) {
				return;
			}

			body._wakeTime = (this.timeStamp + (this._midStep ? 0 : 1));
			if (body.sleeping) {
				if (!body._island) {
					var bphase = this.broadphase;

					// new body, or forced wake, or kinematic
					if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
						body.sleeping = false;
						this.liveDynamics.push(body);
					} else if (body._type === (/*TYPE_KINEMATIC*/ 1)) {
						body.sleeping = false;
						this.liveKinematics.push(body);
					}

					var constraints = body.constraints;
					var limit = constraints.length;
					var i;
					for (i = 0; i < limit; i += 1) {
						this._wakeConstraint(constraints[i]);
					}

					var isStatic = (body._type === (/*TYPE_STATIC*/ 2));

					var shapes = body.shapes;
					limit = shapes.length;
					for (i = 0; i < limit; i += 1) {
						var shape = shapes[i];
						this._wakeArbiters(shape.arbiters, false, continuousCallbacks);
						if (!isStatic) {
							bphase.update(shape._bphaseHandle, shape._data, false);
						}
					}

					if (!noCallback && (body._type === (/*TYPE_DYNAMIC*/ 0))) {
						this._onWakeCallbacks(body);
					}
				} else {
					this._wakeIsland(body._island, (noCallback ? body : null), continuousCallbacks);
				}
			}
		};

		Physics2DWorld.prototype._wakeArbiter = function (arb, continuousCallbacks) {
			arb.sleeping = false;

			var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
			var tDelta = (timeStamp - arb._sleepStamp);
			arb._updateStamp += tDelta;
			var contacts = arb.contacts;
			var limit2 = contacts.length;
			var j;
			for (j = 0; j < limit2; j += 1) {
				contacts[j]._timeStamp += tDelta;
			}

			if (arb._static) {
				this.staticArbiters.push(arb);
			} else {
				this.dynamicArbiters.push(arb);
			}

			// Arbiter was woken as the result of a continuous collisions
			// And we must pre-step and generate callbacks.
			if (continuousCallbacks) {
				this._continuousArbiterPrepare(arb, this._deltaTime, true);
			}
		};

		Physics2DWorld.prototype._continuousArbiterPrepare = function (arb, deltaTime, progressEvents) {
			this._preStepArbiter(arb, deltaTime, progressEvents);

			/*jshint bitwise: false*/
			if (arb.active && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
				// Single velocity iteration of just this arbiter.
				// Helps objects to bounce immediately, any errors will be resolved
				// in following step anyhow.
				arb._iterateVelocity();
			}
		};

		Physics2DWorld.prototype._wakeArbiters = function (arbiters, skip, continuousCallbacks) {
			var limit = arbiters.length;
			var i;
			var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
			for (i = 0; i < limit; i += 1) {
				var arb = arbiters[i];
				if (arb._retired) {
					continue;
				}

				if (arb.sleeping) {
					this._wakeArbiter(arb, continuousCallbacks);
				}

				if (!skip) {
					// arb.active is not yet computed.
					/*jshint bitwise: false*/
					if ((arb._updateStamp === timeStamp) && !arb.sensor && (arb._state & (/*STATE_ACCEPT*/ 1)) !== 0) {
						var b1 = arb.bodyA;
						var b2 = arb.bodyB;
						if (b1._type === (/*TYPE_DYNAMIC*/ 0) && b1.sleeping) {
							this._wakeBody(b1, false, continuousCallbacks);
						}
						if (b2._type === (/*TYPE_DYNAMIC*/ 0) && b2.sleeping) {
							this._wakeBody(b2, false, continuousCallbacks);
						}
					}
				}
			}
		};

		Physics2DWorld.prototype._wakeIsland = function (island, noCallbackObject, continuousCallbacks) {
			var bphase = this.broadphase;
			var bodies = this.liveDynamics;
			var constraints = this.liveConstraints;

			var timeStamp = (this.timeStamp + (this._midStep ? 0 : 1));
			var components = island.components;
			var limit = components.length;
			while (limit > 0) {
				limit -= 1;
				var c = components.pop();
				c._wakeTime = timeStamp;

				// Reset island properties.
				c._island = null;
				c._islandRoot = c;
				c._islandRank = 0;

				c.sleeping = false;

				if (c._isBody) {
					// TODO: fix <any> casts
					// only dynamic bodies are inserted to islands.
					bodies.push(c);

					var shapes = c.shapes;
					var limit2 = shapes.length;
					var i;
					for (i = 0; i < limit2; i += 1) {
						var shape = shapes[i];
						this._wakeArbiters(shape.arbiters, true, continuousCallbacks);
						bphase.update(shape._bphaseHandle, shape._data, false);
					}
				} else {
					constraints.push(c);
				}

				// Body + Constraint
				if (noCallbackObject !== c) {
					this._onWakeCallbacks(c);
				}
			}

			Physics2DIsland.deallocate(island);
		};

		// =====================================================================
		Physics2DWorld.prototype._transmitBodyType = function (body, newType) {
			// Wake as old type.
			// Interactions that are presently active may
			// become ignored.
			this._wakeBody(body);

			// Just woke the body, so it's not sleeping
			var bodies;
			if (body._type === (/*TYPE_DYNAMIC*/ 0)) {
				bodies = this.liveDynamics;
			} else if (body._type === (/*TYPE_KINEMATIC*/ 1)) {
				bodies = this.liveKinematics;
			}

			var index;
			if (bodies) {
				index = bodies.indexOf(body);
				bodies[index] = bodies[bodies.length - 1];
				bodies.pop();
			}

			body._type = newType;

			var staticBody = (newType === (/*TYPE_STATIC*/ 2));
			if (staticBody) {
				// Ensure body is updated as run time validation
				// Does not occur for static types.
				body._update();
			}

			if (newType === (/*TYPE_DYNAMIC*/ 0)) {
				// Set up ready for island computations
				body._islandRoot = body;
				body._islandRank = 0;
			}

			var bphase = this.broadphase;

			// Destroy redundant arbiters, and mutate arbiter static type.
			var shapes = body.shapes;
			var limit = shapes.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var shape = shapes[i];
				if (staticBody) {
					// Static bodies aren't synced by wakeBody
					bphase.update(shape._bphaseHandle, shape._data, true);
				}

				var arbiters = shape.arbiters;
				var limit2 = arbiters.length;
				var j;
				for (j = 0; j < limit2;) {
					var arb = arbiters[j];
					if (arb._retired) {
						continue;
					}

					var bothStaticType = (arb.bodyA._type !== (/*TYPE_DYNAMIC*/ 0) && arb.bodyB._type !== (/*TYPE_DYNAMIC*/ 0));
					var atleastOneKinematic = (arb.bodyA._type === (/*TYPE_KINEMATIC*/ 1) || arb.bodyB._type === (/*TYPE_KINEMATIC*/ 1));
					if (bothStaticType && !(atleastOneKinematic && arb.sensor)) {
						limit2 -= 1;
						arbiters[j] = arbiters[limit2];
						arbiters.pop();
						arb._lazyRetire(shape);
						this._pushInteractionEvents((/*EVENT_END*/ 3), arb);
						continue;
					}

					var staticType = (arb.bodyA._type !== (/*TYPE_DYNAMIC*/ 0) || arb.bodyB._type !== (/*TYPE_DYNAMIC*/ 0));
					if (staticType !== arb._static) {
						var arbs = (arb._static ? this.staticArbiters : this.dynamicArbiters);
						index = arbs.indexOf(arb);
						arbs[index] = arbs[arbs.length - 1];
						arbs.pop();

						arb._static = staticType;
						arbs = (staticType ? this.staticArbiters : this.dynamicArbiters);
						arbs.push(arb);
					}

					j += 1;
				}
			}

			// Force wake as new type.
			// Interactions that may have been previously ignored
			// may now become active.
			body.sleeping = true;
			this._wakeBody(body);
		};

		// =====================================================================
		Physics2DWorld.prototype._validate = function () {
			this._validateBodies(this.liveDynamics);
			this._validateBodies(this.liveKinematics);

			// Issue deferred wake callbacks to stack.
			var constraints = this.liveConstraints;
			var i;
			var limit = constraints.length;
			for (i = 0; i < limit; i += 1) {
				var con = constraints[i];
				if (con._woken && con._onWake.length > 0) {
					this._pushCallbacks(con, con._onWake);
				}
				con._woken = false;
			}
		};

		Physics2DWorld.prototype._validateBodies = function (bodies) {
			var bphase = this.broadphase;
			var i;
			var limit = bodies.length;
			for (i = 0; i < limit; i += 1) {
				var body = bodies[i];

				// Prevent errors accumulating.
				var data = body._data;
				var rot = data[(/*BODY_POS*/ 2) + 2];
				data[(/*BODY_AXIS*/ 5)] = Math.cos(rot);
				data[(/*BODY_AXIS*/ 5) + 1] = Math.sin(rot);

				// Update shape world-data.
				body._update();

				if (body._type === (/*TYPE_DYNAMIC*/ 0) && body._woken && body._onWake.length > 0) {
					this._pushCallbacks(body, body._onWake);
				}
				body._woken = false;

				var shapes = body.shapes;
				var limit2 = shapes.length;
				var j;
				for (j = 0; j < limit2; j += 1) {
					var shape = shapes[j];
					bphase.update(shape._bphaseHandle, shape._data);
				}
			}
		};

		Physics2DWorld.create = function (params) {
			var w = new Physics2DWorld();
			w.simulatedTime = 0;

			// ALL such objects.
			w.rigidBodies = [];
			w.constraints = [];

			// Non-sleeping such objects.
			w.liveDynamics = [];
			w.liveKinematics = [];
			w.liveConstraints = [];

			// Non-sleeping only.
			w.dynamicArbiters = [];
			w.staticArbiters = [];

			w._islands = [];
			w._toiEvents = [];
			w._deferredWake = [];

			w._eventTime = (/*EVENT_TIME_PRE*/ -1);
			w._callbacks = [];

			w.broadphase = (params.broadphase || Physics2DBoxTreeBroadphase.create());

			w.velocityIterations = (params.velocityIterations || 8);
			w.positionIterations = (params.positionIterations || 8);

			w._midStep = false;
			w.timeStamp = 0;

			var gravity = params.gravity;
			w._gravityX = (gravity ? gravity[0] : 0);
			w._gravityY = (gravity ? gravity[1] : 10);

			w._collisions = Physics2DCollisionUtils.create();

			// =====================================================================
			w._sampleRectangle = Types.createFloatArray(4);

			var shapeSampler = function shapeSamplerFn(lambda) {
				return {
					store: null,
					count: 0,
					collisions: w._collisions,
					sample: function (handle, bounds) {
						var shape = handle.data;
						if (lambda.call(this, shape, bounds)) {
							this.store[this.count] = shape;
							this.count += 1;
						}
					}
				};
			};

			var bodySampler = function bodySamplerFn(lambda) {
				return {
					store: null,
					count: 0,
					collisions: w._collisions,
					sample: function (handle, bounds) {
						var shape = handle.data;
						if (lambda.call(this, shape, bounds)) {
							var found = false;
							var body = shape.body;
							var i;
							var limit = this.count;
							var bodies = this.store;
							for (i = 0; i < limit; i += 1) {
								if (bodies[i] === body) {
									found = true;
									break;
								}
							}

							if (!found) {
								bodies[limit] = body;
								this.count += 1;
							}
						}
					}
				};
			};

			var pointSampler = function pointSamplerFn(shape, point) {
				return this.collisions._contains(shape, point[0], point[1]);
			};
			w._shapePointCallback = shapeSampler(pointSampler);
			w._bodyPointCallback = bodySampler(pointSampler);

			var rectangleSampler = function rectangleSamplerFn(shape, unusedSampleBox) {
				return this.collisions._test(shape, this.rectangleShape);
			};
			w._shapeRectangleCallback = shapeSampler(rectangleSampler);
			w._bodyRectangleCallback = bodySampler(rectangleSampler);

			w._rectangleQueryVertices = [
				Types.createFloatArray(2),
				Types.createFloatArray(2),
				Types.createFloatArray(2),
				Types.createFloatArray(2)
			];
			w._rectangleQueryShape = Physics2DPolygon.create({ vertices: w._rectangleQueryVertices });
			w._shapeRectangleCallback.rectangleShape = w._rectangleQueryShape;
			w._bodyRectangleCallback.rectangleShape = w._rectangleQueryShape;

			var circleSampler = function circleSamplerFn(shape, unusedSampleBox) {
				return this.collisions._test(shape, this.circleShape);
			};
			w._shapeCircleCallback = shapeSampler(circleSampler);
			w._bodyCircleCallback = bodySampler(circleSampler);

			w._circleQueryShape = Physics2DCircle.create({ radius: 1 });
			w._shapeCircleCallback.circleShape = w._circleQueryShape;
			w._bodyCircleCallback.circleShape = w._circleQueryShape;

			var tempCastResult = {
				shape: null,
				hitPoint: Types.createFloatArray(2),
				hitNormal: Types.createFloatArray(2),
				factor: 0
			};

			w._rayCast = {
				minNormal: Types.createFloatArray(2),
				minShape: null,
				minFactor: 0,
				userCallback: null,
				userThis: null,
				ray: null,
				noInner: false,
				normal: Types.createFloatArray(2),
				sample: function sampleFn(handle, _) {
					var shape = handle.data;

					var ray = this.ray;
					var normal = this.normal;

					var oldFactor = ray.maxFactor;
					ray.maxFactor = this.minFactor;
					var factor = w._collisions.rayTest(shape, ray, normal, this.noInner);
					ray.maxFactor = oldFactor;

					if (this.userCallback) {
						var result = tempCastResult;
						var vector = result.hitNormal;
						vector[0] = normal[0];
						vector[1] = normal[1];

						vector = result.hitPoint;
						var origin = ray.origin;
						var direction = ray.direction;
						vector[0] = (origin[0] + (direction[0] * factor));
						vector[1] = (origin[1] + (direction[1] * factor));
						result.factor = factor;
						result.shape = shape;

						if (!this.userCallback.call(this.userThis, ray, result)) {
							return;
						}
					}

					if (factor !== undefined) {
						this.minFactor = factor;
						this.minShape = shape;

						var minNormal = this.minNormal;
						minNormal[0] = normal[0];
						minNormal[1] = normal[1];
					}
				}
			};

			w._convexCast = {
				toi: w._collisions._toi,
				minData: Types.createFloatArray(4),
				minShape: null,
				minTOIAlpha: 0,
				userCallback: null,
				userThis: null,
				deltaTime: 0,
				sample: function sampleFn(handle, _) {
					var toi = this.toi;
					var shape = handle.data;

					// sweeping shape against itself!
					// can happen if input for sweep was a shape in the World.
					if (shape === toi.shapeA) {
						return;
					}

					toi.shapeB = shape;
					shape.body._update();

					var ret = w._collisions._staticSweep(toi, (this.minTOIAlpha * this.deltaTime), 0) * this.minTOIAlpha;

					if (ret <= 0) {
						return;
					}

					var tdata = toi._data;
					if (this.userCallback) {
						var result = tempCastResult;
						var vector = result.hitNormal;
						vector[0] = (-tdata[(/*TOI_AXIS*/ 0)]);
						vector[1] = (-tdata[(/*TOI_AXIS*/ 0) + 1]);
						vector = result.hitPoint;
						vector[0] = tdata[(/*TOI_WITNESS_B*/ 4)];
						vector[1] = tdata[(/*TOI_WITNESS_B*/ 4) + 1];
						result.factor = (ret * this.deltaTime);
						result.shape = shape;
						result.shape = shape;

						if (!this.userCallback.call(this.userThis, toi.shapeA, result)) {
							return;
						}
					}

					this.minTOIAlpha = ret;
					var data = this.minData;
					data[0] = tdata[(/*TOI_AXIS*/ 0)];
					data[1] = tdata[(/*TOI_AXIS*/ 0) + 1];
					data[2] = tdata[(/*TOI_WITNESS_B*/ 4)];
					data[3] = tdata[(/*TOI_WITNESS_B*/ 4) + 1];
					this.minShape = shape;
				}
			};

			return w;
		};

		Physics2DWorld.version = 1;
		return Physics2DWorld;
})
define(
	'spell/physics/2D/Config',
	[
	],
	function(
		) {
		var Physics2DConfig = {
			// (Contact Physics)
			// Amount of slop permitted in contact penetration
			CONTACT_SLOP: 0.01,
			EFF_MASS_EPSILON: 1e-10,
			ILL_THRESHOLD: 1e5,
			CLIP_EPSILON: 1.65e-10,
			// Configuration of bias coeffecient computation
			// for percentage of error to resolve per-frame.
			BIAS_COEF: 0.15,
			STATIC_BIAS_COEF: 0.75,
			CONT_BIAS_COEF: 0.5,
			CONT_STATIC_BIAS_COEF: 0.6,
			// Bounce-target-velocity at contact below this value
			// will cause bouncing to be ignored.
			BOUNCE_VELOCITY_THRESHOLD: 0.25,
			// Threshold at which static friction takes over from
			// dynamic.
			STATIC_FRIC_SQ_EPSILON: 1e-4,
			// ================================================
			// (Constraint physics)
			// Point
			// -----------
			// Percentage of error solved per-iteration
			POINT_BIAS_COEF: 0.5,
			// Maximum error to be resolved per-iteration
			POINT_MAX_ERROR: 0.2,
			POINT_MAX_ERROR_SQ: (0.2 * 0.2),
			POINT_SLOP_SQ: 1e-6,
			// Squared error to consider error too large
			// to solve properly.
			POINT_LARGE_ERROR_SQ: 0.01,
			// Percentage of error solved per-iteration in large error case
			POINT_LARGE_ERROR_BIAS: 0.75,
			// Maximum error to be resolve per-iteration in large error case
			POINT_LARGE_ERROR_MAX: 0.4,
			// Weld
			// ----
			// Percentage of error solved per-iteration
			WELD_BIAS_COEF: 0.5,
			// Maximum error to be resolved per-iteration
			WELD_MAX_LINEAR_ERROR: 0.2,
			WELD_MAX_ANGULAR_ERROR: 0.5,
			WELD_MAX_LINEAR_ERROR_SQ: (0.2 * 0.2),
			WELD_LINEAR_SLOP_SQ: 1e-6,
			WELD_ANGULAR_SLOP_SQ: 1e-6,
			// Squared error to consider error too large
			// to solve properly.
			WELD_LARGE_ERROR_SQ: 0.01,
			// Percentage of linear error solved per-iteration in large error case
			WELD_LARGE_ERROR_BIAS: 0.75,
			// Maximum linear error to be resolve per-iteration in large error case
			WELD_LARGE_ERROR_MAX: 0.4,
			// Angle
			// -----
			// Percentage of error solved per-iteration
			ANGLE_BIAS_COEF: 0.5,
			ANGLE_SLOP_SQ: 1e-6,
			// Distance
			// --------
			// Percentage of error solved per-iteration
			DIST_BIAS_COEF: 0.5,
			DIST_SLOP_SQ: 1e-6,
			// Squared error to consider error too large
			// to solve properly.
			DIST_LARGE_ERROR_SQ: 0.01,
			// Percentage of error to solve per-iteration in large error case
			DIST_LARGE_ERROR_BIAS: 0.75,
			// Line
			// ----
			// Percentage of error solved per-iteration
			LINE_BIAS_COEF: 0.8,
			LINE_SLOP_SQ: 1e-6,
			// Squared error to consider error too large
			// to solve properly.
			LINE_LARGE_ERROR_SQ: 0.01,
			// Percentage of error to solve per-iteration in large error case
			LINE_LARGE_ERROR_BIAS: 0.9,
			// Pulley
			// --------
			// Percentage of error solved per-iteration
			PULLEY_BIAS_COEF: 0.5,
			PULLEY_SLOP_SQ: 1e-6,
			// Squared error to consider error too large
			// to solve properly.
			PULLEY_LARGE_ERROR_SQ: 0.01,
			// Percentage of error to solve per-iteration in large error case
			PULLEY_LARGE_ERROR_BIAS: 0.75,
			// ================================================
			// (Continuous collisions)
			// Percentage of body radius body must move through.
			MIN_LINEAR_STATIC_SWEEP: 0.05,
			MIN_ANGULAR_STATIC_SWEEP: 0.005,
			MIN_LINEAR_BULLET_SWEEP: 0.5,
			MIN_ANGULAR_BULLET_SWEEP: 0.05,
			// Accuracy threshold for sweeps on distance.
			SWEEP_LIMIT: 0.0005,
			// Amount of slop permitted in a continuous collision.
			SWEEP_SLOP: 0.05,
			// Minimum fractional TOI-alpha advancement
			MINIMUM_SWEEP_ADVANCE: 1e-6,
			// Maximum sub-steps in sweep
			MAX_SWEEP_ITER: 50,
			// Squared relative velocity in dynamic sweeps to ignore pair
			EQUAL_SQ_VEL: 0.2,
			// Sum of angular-velocity * radius for pair of shapes to ignore pair in dynamic sweeps.
			ZERO_ANG_BIAS: 0.02,
			// Scale factor for angular velocity when TOI has been permitted to slip.
			// This helps prevent an object getting 'stuck' for a few steps when in
			// a fast rotating continuous set of collisions at one point.
			TOI_SLIP_SCALE: 0.75,
			// ================================================
			// (Arbiter/Contact persistance)
			// Number of simulation steps before inactive arbiter is killed.
			DELAYED_DEATH: 30,
			// ================================================
			// (Body integration)
			DELTA_ROTATION_EPSILON: 1e-4,
			// ================================================
			// (Sleeping)
			SLEEP_DELAY: 60,
			// squared linear velocity for sleeping
			SLEEP_LINEAR_SQ: 0.0006,
			// squared tangent velocity for sleeping (body radius taken into account)
			SLEEP_ANGULAR_SQ: 0.001,
			// ================================================
			// (Point containment)
			CONTAINS_EPSILON: 1e-6,
			CONTAINS_SQ_EPSILON: 1e-12,
			// ================================================
			// (General)
			COLLINEAR_EPSILON: 1e-5,
			COLLINEAR_SQ_EPSILON: (1e-5 * 1e-5),
			NORMALIZE_EPSILON: 1e-6,
			NORMALIZE_SQ_EPSILON: (1e-6 * 1e-6)
		};

		return Physics2DConfig;

})
/**
 * Physics2D Rigid Body
 * @class spell.physics.2D.RigidBody
 */
// =========================================================================
//
//
//
// BODY DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*BODY_IMASS*/0           // 1 / mass (possibly 0) for body. Always 0 for non-dynamic
///*BODY_IINERTIA*/1        // 1 / inertia (possibly 0) for body. Always 0 for non-dynamic
///*BODY_POS*/2             // World position and rotation (CW rad) of body (x, y, r)
///*BODY_AXIS*/5            // (cos(rotation), sin(rotation))
///*BODY_VEL*/7             // World velocity and ang.vel of body (vx, vy, w)
///*BODY_FORCE*/10          // World force + torque, persistently applied (fx, fy, t)
///*BODY_SURFACE_VEL*/13    // Surface velocity biasing contact physics (vt, vn)
///*BODY_PRE_POS*/15        // Previous position and rotation (x, y, r)
///*BODY_SWEEP_TIME*/18     // Time alpha for current partial integration of body.
///*BODY_RADIUS*/19         // Approximate radius of body about its origin.
///*BODY_SWEEP_ANGVEL*/20   // Angular velocity % (2 * pi / timeStep) for sweeps.
///*BODY_LIN_DRAG*/21       // Log of (1 - linear drag).
///*BODY_ANG_DRAG*/22       // Log of (1 - angular drag).
///*BODY_MASS*/23           // Untainted by body type mass.
///*BODY_INERTIA*/24        // Untainted by body type inertia.
//
///*BODY_DATA_SIZE*/25
//
// BODY TYPE CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*TYPE_DYNAMIC*/0
///*TYPE_KINEMATIC*/1
///*TYPE_STATIC*/2
define(
	'spell/physics/2D/RigidBody',
	[
		'spell/physics/2D/Config',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DConfig,
		Types
		) {
			var Physics2DRigidBody = function() {
			}

			/**
			 * Returns *true*, if body is of a *dynamic* type.
			 *
			 *     var isDynamic = body.isDynamic();
			 *
			 * @returns {boolean}
			 * @method isDynamic
			 */
			Physics2DRigidBody.prototype.isDynamic = function () {
				return (this._type === (/*TYPE_DYNAMIC*/ 0));
			};

			/**
			 * Change rigid body type to *dynamic*. This operation can be made at any time except for during a simulation step.
			 *
			 *     body.setAsDynamic();
			 *
			 * @method setAsDynamic
			 */
			Physics2DRigidBody.prototype.setAsDynamic = function () {
				if (this.world && this.world._midStep) {
					return;
				}

				this._setTypeValue((/*TYPE_DYNAMIC*/ 0));
				var data = this._data;

				var mass = data[(/*BODY_MASS*/ 23)];
				var inertia = data[(/*BODY_INERTIA*/ 24)];
				data[(/*BODY_IMASS*/ 0)] = (mass === Number.POSITIVE_INFINITY ? 0 : (1 / mass));
				data[(/*BODY_IINERTIA*/ 1)] = (inertia === Number.POSITIVE_INFINITY ? 0 : (1 / inertia));
			};

			/**
			 * Returns *true*, if body is of a *static* type.
			 *
			 *     var isStatic = body.isStatic();
			 *
			 * @returns {boolean}
			 * @method isStatic
			 */
			Physics2DRigidBody.prototype.isStatic = function () {
				return (this._type === (/*TYPE_STATIC*/ 2));
			};

			/**
			 * Change rigid body type to *static*. This operation can be made at any time except for during a simulation step.
			 *
			 * This method will also set the *velocity* and *angularVelocity* of the rigid body to *0* as static bodies are not permitted to have velocity.
			 *
			 *     body.setAsStatic();
			 *
			 * @method setAsStatic
			 */
			Physics2DRigidBody.prototype.setAsStatic = function () {
				if (this.world && this.world._midStep) {
					return;
				}

				this._setTypeValue((/*TYPE_STATIC*/ 2));
				var data = this._data;
				data[(/*BODY_IMASS*/ 0)] = data[(/*BODY_IINERTIA*/ 1)] = 0;

				// Static body cannot have velocity
				data[(/*BODY_VEL*/ 7)] = data[(/*BODY_VEL*/ 7) + 1] = data[(/*BODY_VEL*/ 7) + 2] = 0;
			};

			/**
			 * Returns *true*, if body is of a *kinematic* type.
			 *
			 *     var isKinematic = body.isKinematic();
			 *
			 * @returns {boolean}
			 * @method isKinematic
			 */
			Physics2DRigidBody.prototype.isKinematic = function () {
				return (this._type === (/*TYPE_KINEMATIC*/ 1));
			};

			/**
			 * Change rigid body type to *kinematic*. This operation can be made at any time except for during a simulation step.
			 *
			 *     body.setAsKinematic();
			 *
			 * @method setAsKinematic
			 */
			Physics2DRigidBody.prototype.setAsKinematic = function () {
				if (this.world && this.world._midStep) {
					return;
				}

				this._setTypeValue((/*TYPE_KINEMATIC*/ 1));
				var data = this._data;
				data[(/*BODY_IMASS*/ 0)] = data[(/*BODY_IINERTIA*/ 1)] = 0;
			};

			Physics2DRigidBody.prototype._setTypeValue = function (newType) {
				if (newType === this._type) {
					return;
				}

				if (!this.world) {
					this._type = newType;
					return;
				}

				this.world._transmitBodyType(this, newType);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.applyImpulse = function (impulse /*v2*/ , position /*v2*/ ) {
				// Static cannot have velocity
				// Kinematic always has infinite mass/inertia (physics wise) so impulse has no effect.
				if (this._type !== (/*TYPE_DYNAMIC*/ 0)) {
					return;
				}

				var data = this._data;
				var x, y;
				if (position) {
					x = (position[0] - data[(/*BODY_POS*/ 2)]);
					y = (position[1] - data[(/*BODY_POS*/ 2) + 1]);
				} else {
					x = 0;
					y = 0;
				}
				var ix = impulse[0];
				var iy = impulse[1];
				var im = data[(/*BODY_IMASS*/ 0)];
				data[(/*BODY_VEL*/ 7)] += (ix * im);
				data[(/*BODY_VEL*/ 7) + 1] += (iy * im);
				data[(/*BODY_VEL*/ 7) + 2] += (((x * iy) - (y * ix)) * data[(/*BODY_IINERTIA*/ 1)]);
				this.wake(true);
			};

			Physics2DRigidBody.prototype.setVelocityFromPosition = function (newPosition /*v2*/ , newRotation, deltaTime) {
				if (this._type === (/*TYPE_STATIC*/ 2)) {
					return;
				}

				var data = this._data;
				var idt = (1 / deltaTime);
				data[(/*BODY_VEL*/ 7)] = ((newPosition[0] - data[(/*BODY_POS*/ 2)]) * idt);
				data[(/*BODY_VEL*/ 7) + 1] = ((newPosition[1] - data[(/*BODY_POS*/ 2) + 1]) * idt);
				data[(/*BODY_VEL*/ 7) + 2] = ((newRotation - data[(/*BODY_POS*/ 2) + 2]) * idt);
				this.wake(true);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.transformWorldPointToLocal = function (src /*v2*/ , dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var cos = data[(/*BODY_AXIS*/ 5)];
				var sin = data[(/*BODY_AXIS*/ 5) + 1];
				var x = (src[0] - data[(/*BODY_POS*/ 2)]);
				var y = (src[1] - data[(/*BODY_POS*/ 2) + 1]);
				dst[0] = ((cos * x) + (sin * y));
				dst[1] = ((cos * y) - (sin * x));
				return dst;
			};

			Physics2DRigidBody.prototype.transformWorldVectorToLocal = function (src /*v2*/ , dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var cos = data[(/*BODY_AXIS*/ 5)];
				var sin = data[(/*BODY_AXIS*/ 5) + 1];
				var x = src[0];
				var y = src[1];
				dst[0] = ((cos * x) + (sin * y));
				dst[1] = ((cos * y) - (sin * x));
				return dst;
			};

			Physics2DRigidBody.prototype.transformLocalPointToWorld = function (src /*v2*/ , dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var cos = data[(/*BODY_AXIS*/ 5)];
				var sin = data[(/*BODY_AXIS*/ 5) + 1];
				var x = src[0];
				var y = src[1];
				dst[0] = ((cos * x) - (sin * y) + data[(/*BODY_POS*/ 2)]);
				dst[1] = ((sin * x) + (cos * y) + data[(/*BODY_POS*/ 2) + 1]);
				return dst;
			};

			Physics2DRigidBody.prototype.transformLocalVectorToWorld = function (src /*v2*/ , dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var data = this._data;
				var cos = data[(/*BODY_AXIS*/ 5)];
				var sin = data[(/*BODY_AXIS*/ 5) + 1];
				var x = src[0];
				var y = src[1];
				dst[0] = ((cos * x) - (sin * y));
				dst[1] = ((sin * x) + (cos * y));
				return dst;
			};

			// ===============================================================================

			/**
			 * Retrieve the current position of this rigid body.
			 *
			 *     var position = body.getPosition();
			 *     // or
			 *     body.getPosition(position);
			 *
			 * @param {Array} [position] If specified, the position of the body will be stored in this array, otherwise a new array will be created.
			 * @method getPosition
			 */
			Physics2DRigidBody.prototype.getPosition = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}

				var data = this._data;
				dst[0] = data[(/*BODY_POS*/ 2)];
				dst[1] = data[(/*BODY_POS*/ 2) + 1];
				return dst;
			};

			/**
			 * Set the position of this rigid body.
			 * This method will be ignored for *static* type bodies which are in a World as well as if it is made during a simulation step.
			 *
			 *     body.setPosition(position);
			 *
			 * @param {Array} position
			 * @method setPosition
			 */
			Physics2DRigidBody.prototype.setPosition = function (position /*v2*/ ) {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return;
				}

				var data = this._data;
				var newX = position[0];
				var newY = position[1];
				if ((data[(/*BODY_POS*/ 2)] !== newX) || (data[(/*BODY_POS*/ 2) + 1] !== newY)) {
					data[(/*BODY_POS*/ 2)] = newX;
					data[(/*BODY_POS*/ 2) + 1] = newY;
					this._invalidated = true;
					this.wake(true);
				}
			};

			/**
			 * Retrieve the current rotation of this rigid body.
			 *
			 *     var rotation = body.getRotation();
			 *
			 * @returns {Number}
			 * @method getRotation
			 */
			Physics2DRigidBody.prototype.getRotation = function () {
				return this._data[(/*BODY_POS*/ 2) + 2];
			};

			/**
			 * Set the rotation of this rigid body. This method will be ignored for *static* type bodies which are in a World as well as if it is made during a simulation step.
			 *
			 *     body.setRotation(rotation);
			 *
			 * @returns {Number}
			 * @method setRotation
			 */
			Physics2DRigidBody.prototype.setRotation = function (rotation) {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return;
				}

				var data = this._data;
				if (data[(/*BODY_POS*/ 2) + 2] !== rotation) {
					this._data[(/*BODY_POS*/ 2) + 2] = rotation;
					this._data[(/*BODY_AXIS*/ 5)] = Math.cos(rotation);
					this._data[(/*BODY_AXIS*/ 5) + 1] = Math.sin(rotation);
					this._invalidated = true;
					this.wake(true);
				}
			};

			// ===============================================================================
			/**
			 * Retrieve the current velocity of this rigid body.
			 *
			 *     var velocity = body.getVelocity();
			 *     // or
			 *     body.getVelocity(velocity);
			 *
			 * @param [dst] If specified, the velocity of the body will be stored in this array, otherwise a new array will be created.
			 * @returns {*}
			 * @method getVelocity
			 */
			Physics2DRigidBody.prototype.getVelocity = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}

				var data = this._data;
				dst[0] = data[(/*BODY_VEL*/ 7)];
				dst[1] = data[(/*BODY_VEL*/ 7) + 1];
				return dst;
			};

			/**
			 * Set the velocity of this rigid body.
			 *
			 * This method will be ignored for *static* type bodies which are in a World.
			 *
			 *     body.setVelocity(velocity);
			 *
			 * @param velocity The velocity with which to set body.
			 * @method setVelocity
			 */
			Physics2DRigidBody.prototype.setVelocity = function (velocity /*v2*/ ) {
				// Static body cannot have velocity.
				if (this._type === (/*TYPE_STATIC*/ 2)) {
					return;
				}

				var data = this._data;
				var newX = velocity[0];
				var newY = velocity[1];
				if ((data[(/*BODY_VEL*/ 7)] !== newX) || (data[(/*BODY_VEL*/ 7) + 1] !== newY)) {
					data[(/*BODY_VEL*/ 7)] = newX;
					data[(/*BODY_VEL*/ 7) + 1] = newY;
					this.wake(true);
				}
			};

			/**
			 * Retrieve the current angular velocity of this rigid body.
			 *
			 *     var angularVelocity = body.getAngularVelocity();
			 *
			 * @returns {Number}
			 * @method getAngularVelocity
			 */
			Physics2DRigidBody.prototype.getAngularVelocity = function () {
				return this._data[(/*BODY_VEL*/ 7) + 2];
			};

			/**
			 * Set the angular velocity of this rigid body.
			 *
			 * This method will be ignored for *static* type bodies which are in a World.
			 *
			 *     body.setAngularVelocity(angularVelocity)
			 *
			 * @param {Array} angularVelocity The angular velocity with which to set body.
			 * @method setAngularVelocity
			 */
			Physics2DRigidBody.prototype.setAngularVelocity = function (angularVelocity) {
				// Static body cannot have velocity.
				if (this._type === (/*TYPE_STATIC*/ 2)) {
					return;
				}

				var data = this._data;
				if (data[(/*BODY_VEL*/ 7) + 2] !== angularVelocity) {
					data[(/*BODY_VEL*/ 7) + 2] = angularVelocity;
					this.wake(true);
				}
			};

			// ===============================================================================
			/**
			 * Retrieve the current force of this rigid body.
			 *
			 *     var force = body.getForce();
			 *     // or
			 *     body.getForce(force);
			 *
			 * @param {Array} [dst] If specified, the force of the body will be stored in this array, otherwise a new array will be created.
			 * @returns {*}
			 * @method getForce
			 */
			Physics2DRigidBody.prototype.getForce = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}

				var data = this._data;
				dst[0] = data[(/*BODY_FORCE*/ 10)];
				dst[1] = data[(/*BODY_FORCE*/ 10) + 1];
				return dst;
			};

			/**
			 * Set the force of this rigid body.
			 *
			 * *Static* bodies may have their force changed even if they are in a World.
			 *
			 * @param {Array} force The force with which to set body.
			 * @method setForce
			 */
			Physics2DRigidBody.prototype.setForce = function (force /*v2*/ ) {
				var data = this._data;
				var newX = force[0];
				var newY = force[1];
				if ((data[(/*BODY_FORCE*/ 10)] !== newX) || (data[(/*BODY_FORCE*/ 10) + 1] !== newY)) {
					data[(/*BODY_FORCE*/ 10)] = newX;
					data[(/*BODY_FORCE*/ 10) + 1] = newY;

					// we wake static/kinematic bodies even if force has no effect
					// incase user has some crazy callback that queries force to
					// make a decision
					this.wake(true);
				}
			};

			/**
			 * Retrieve the current torque of this rigid body.
			 *
			 *    var torque = body.getTorque();
			 *
			 * @returns {Number}
			 * @method getTorque
			 */
			Physics2DRigidBody.prototype.getTorque = function () {
				return this._data[(/*BODY_FORCE*/ 10) + 2];
			};

			/**
			 * Set the torque of this rigid body.
			 *
			 * *Static* bodies may have their torque changed even if they are in a World.
			 *
			 *    body.setTorque(torque)
			 *
			 * @param {Number} torque
			 * @method setTorque
			 */
			Physics2DRigidBody.prototype.setTorque = function (torque) {
				var data = this._data;
				if (data[(/*BODY_FORCE*/ 10) + 2] !== torque) {
					data[(/*BODY_FORCE*/ 10) + 2] = torque;

					// we wake static/kinematic bodies even if force has no effect
					// incase user has some crazy callback that queries torque to
					// make a decision
					this.wake(true);
				}
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.getSurfaceVelocity = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}

				var data = this._data;
				dst[0] = data[(/*BODY_SURFACE_VEL*/ 13)];
				dst[1] = data[(/*BODY_SURFACE_VEL*/ 13) + 1];
				return dst;
			};

			Physics2DRigidBody.prototype.setSurfaceVelocity = function (surfaceVelocity /*v2*/ ) {
				var data = this._data;
				data[(/*BODY_SURFACE_VEL*/ 13)] = surfaceVelocity[0];
				data[(/*BODY_SURFACE_VEL*/ 13) + 1] = surfaceVelocity[1];
				this.wake(true);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.getMass = function () {
				return this._data[(/*BODY_MASS*/ 23)];
			};

			Physics2DRigidBody.prototype.getInertia = function () {
				return this._data[(/*BODY_INERTIA*/ 24)];
			};

			Physics2DRigidBody.prototype.setMass = function (mass) {
				var data = this._data;
				var oldMass = data[(/*BODY_MASS*/ 23)];
				if (!this._customMass || (oldMass !== mass)) {
					data[(/*BODY_MASS*/ 23)] = mass;
					this._customMass = true;
					this._invalidateMassInertia();
				}
			};

			Physics2DRigidBody.prototype.setMassFromShapes = function () {
				if (this._customMass) {
					this._customMass = false;
					this._data[(/*BODY_MASS*/ 23)] = this.computeMassFromShapes();
					this._invalidateMassInertia();
				}
			};

			Physics2DRigidBody.prototype.setInertia = function (inertia) {
				var data = this._data;
				var oldInertia = data[(/*BODY_INERTIA*/ 24)];
				if (!this._customInertia || (oldInertia !== inertia)) {
					data[(/*BODY_INERTIA*/ 24)] = inertia;
					this._customInertia = true;
					this._invalidateMassInertia();
				}
			};

			Physics2DRigidBody.prototype.setInertiaFromShapes = function () {
				if (this._customInertia) {
					this._customInertia = false;
					this._data[(/*BODY_INERTIA*/ 24)] = this.computeInertiaFromShapes();
					this._invalidateMassInertia();
				}
			};

			Physics2DRigidBody.prototype._invalidateMassInertia = function () {
				var data = this._data;
				var mass = data[(/*BODY_MASS*/ 23)];
				var inertia = data[(/*BODY_INERTIA*/ 24)];

				var staticType = (this._type !== (/*TYPE_DYNAMIC*/ 0));
				var inf = Number.POSITIVE_INFINITY;
				data[(/*BODY_IMASS*/ 0)] = (staticType || mass === inf) ? 0 : (1 / mass);
				data[(/*BODY_IINERTIA*/ 1)] = (staticType || inertia === inf) ? 0 : (1 / inertia);

				// We wake body, even if static/kinematic incase user has some crazy
				// callback which queries mass/inertia to make decision
				this.wake(true);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.getLinearDrag = function () {
				return (1 - Math.exp(this._data[(/*BODY_LIN_DRAG*/ 21)]));
			};

			Physics2DRigidBody.prototype.setLinearDrag = function (linearDrag) {
				this._data[(/*BODY_LIN_DRAG*/ 21)] = Math.log(1 - linearDrag);

				// We wake body, even if static/kinematic incase user has some crazy
				// callback which queries mass/inertia to make decision
				this.wake(true);
			};

			Physics2DRigidBody.prototype.getAngularDrag = function () {
				return (1 - Math.exp(this._data[(/*BODY_ANG_DRAG*/ 22)]));
			};

			Physics2DRigidBody.prototype.setAngularDrag = function (angularDrag) {
				this._data[(/*BODY_ANG_DRAG*/ 22)] = Math.log(1 - angularDrag);

				// We wake body, even if static/kinematic incase user has some crazy
				// callback which queries mass/inertia to make decision
				this.wake(true);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.addShape = function (shape) {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return false;
				}

				if (shape.body) {
					return false;
				}

				shape.body = this;
				this.shapes.push(shape);

				if (this.world) {
					this.wake(true);
					this.world._addShape(shape);
				}

				// Recompute body radius
				var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/ 4)];
				var data = this._data;
				if (rad > data[(/*BODY_RADIUS*/ 19)]) {
					data[(/*BODY_RADIUS*/ 19)] = rad;
				}

				this._invalidate();

				return true;
			};

			Physics2DRigidBody.prototype.removeShape = function (shape) {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return false;
				}

				if (shape.body !== this) {
					return false;
				}

				if (this.world) {
					this.wake(true);
					this.world._removeShape(shape);
				}

				shape.body = null;
				var shapes = this.shapes;
				var limit = (shapes.length - 1);
				var index = shapes.indexOf(shape);
				shapes[index] = shapes[limit];
				shapes.pop();

				// Recompute body radius.
				var i;
				var radius = 0;
				for (i = 0; i < limit; i += 1) {
					shape = shapes[i];
					var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/ 4)];
					if (rad > radius) {
						radius = rad;
					}
				}
				this._data[(/*BODY_RADIUS*/ 19)] = radius;

				this._invalidate();

				return true;
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.computeMassFromShapes = function () {
				var mass = 0;
				var i;
				var shapes = this.shapes;
				var limit = shapes.length;
				for (i = 0; i < limit; i += 1) {
					var shape = shapes[i];
					mass += shape._material._data[(/*MAT_DENSITY*/ 4)] * shape.computeArea();
				}
				return mass;
			};

			Physics2DRigidBody.prototype.computeInertiaFromShapes = function () {
				var inertia = 0;
				var i;
				var shapes = this.shapes;
				var limit = shapes.length;
				for (i = 0; i < limit; i += 1) {
					var shape = shapes[i];
					inertia += shape._material._data[(/*MAT_DENSITY*/ 4)] * shape.computeMasslessInertia() * shape.computeArea();
				}
				return inertia;
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.wake = function (automated) {
				if (!this.world) {
					this.sleeping = false;
					return;
				}

				this.world._wakeBody(this, !automated);
			};

			Physics2DRigidBody.prototype.sleep = function () {
				if (!this.world) {
					this.sleeping = true;
					return;
				}

				this.world._forceSleepBody(this);
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.computeLocalCenterOfMass = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(2);
				}
				var comX = 0;
				var comY = 0;
				var totalMass = 0;

				var shapes = this.shapes;
				var limit = shapes.length;
				var i;
				for (i = 0; i < limit; i += 1) {
					var shape = shapes[i];
					shape.computeCenterOfMass(dst);
					var mass = shape.computeArea() * shape._material._data[(/*MAT_DENSITY*/ 4)];
					comX += (dst[0] * mass);
					comY += (dst[1] * mass);
					totalMass += mass;
				}

				var imass = (1 / totalMass);
				dst[0] = (comX * imass);
				dst[1] = (comY * imass);
				return dst;
			};

			Physics2DRigidBody.prototype.computeWorldBounds = function (dst /*v2*/ ) {
				if (dst === undefined) {
					dst = Types.createFloatArray(4);
				}
				var inf = Number.POSITIVE_INFINITY;
				var minX = inf;
				var minY = inf;
				var maxX = -inf;
				var maxY = -inf;

				this._update();
				var shapes = this.shapes;
				var limit = shapes.length;
				var i;
				for (i = 0; i < limit; i += 1) {
					var shape = shapes[i]._data;
					var x0 = shape[(/*SHAPE_AABB*/ 0)];
					var y0 = shape[(/*SHAPE_AABB*/ 0) + 1];
					var x1 = shape[(/*SHAPE_AABB*/ 0) + 2];
					var y1 = shape[(/*SHAPE_AABB*/ 0) + 3];
					if (x0 < minX) {
						minX = x0;
					}
					if (x1 > maxX) {
						maxX = x1;
					}
					if (y0 < minY) {
						minY = y0;
					}
					if (y1 > maxY) {
						maxY = y1;
					}
				}

				dst[0] = minX;
				dst[1] = minY;
				dst[2] = maxX;
				dst[3] = maxY;
				return dst;
			};

			// ===============================================================================
			Physics2DRigidBody.prototype.alignWithOrigin = function () {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return;
				}

				var negCOM = this.computeLocalCenterOfMass();
				negCOM[0] *= -1;
				negCOM[1] *= -1;

				var shapes = this.shapes;
				var limit = shapes.length;
				var i;
				for (i = 0; i < limit; i += 1) {
					shapes[i].translate(negCOM, true);
				}
				this._invalidate();
			};

			// ===============================================================================
			Physics2DRigidBody.prototype._invalidate = function () {
				this._invalidated = true;

				var customMass = this._customMass;
				var customInertia = this._customInertia;
				if ((!customMass) || (!customInertia)) {
					if (!customMass) {
						this._data[(/*BODY_MASS*/ 23)] = this.computeMassFromShapes();
					}
					if (!customInertia) {
						this._data[(/*BODY_INERTIA*/ 24)] = this.computeInertiaFromShapes();
					}

					this._invalidateMassInertia();
				}

				this.wake(true);
			};

			Physics2DRigidBody.prototype._update = function () {
				if (this._invalidated) {
					this._invalidated = false;
					var data = this._data;
					var shapes = this.shapes;
					var limit = shapes.length;
					var i;
					for (i = 0; i < limit; i += 1) {
						shapes[i]._update(data[(/*BODY_POS*/ 2)], data[(/*BODY_POS*/ 2) + 1], data[(/*BODY_AXIS*/ 5)], data[(/*BODY_AXIS*/ 5) + 1]);
					}
				}
			};

			// =====================================================================
			Physics2DRigidBody.prototype._atRest = function (deltaTime, timeStamp) {
				if (this._type !== (/*TYPE_DYNAMIC*/ 0)) {
					return this.sleeping;
				} else {
					var data = this._data;
					var canSleep;

					do {
						var x = data[(/*BODY_VEL*/ 7)];
						var y = data[(/*BODY_VEL*/ 7) + 1];
						var conf = Physics2DConfig.SLEEP_LINEAR_SQ;
						if (((x * x) + (y * y)) > conf) {
							canSleep = false;
							break;
						}

						x = (data[(/*BODY_POS*/ 2)] - data[(/*BODY_PRE_POS*/ 15)]);
						y = (data[(/*BODY_POS*/ 2) + 1] - data[(/*BODY_PRE_POS*/ 15) + 1]);
						var threshold = (deltaTime * deltaTime * conf);
						if (((x * x) + (y * y)) > threshold) {
							canSleep = false;
							break;
						}

						y = data[(/*BODY_RADIUS*/ 19)];
						x = data[(/*BODY_VEL*/ 7) + 2] * y;
						conf = Physics2DConfig.SLEEP_ANGULAR_SQ;
						if ((x * x) > conf) {
							canSleep = false;
							break;
						}

						x = (data[(/*BODY_POS*/ 2) + 2] - data[(/*BODY_PRE_POS*/ 15) + 2]) * y;
						threshold = (deltaTime * deltaTime * conf);
						canSleep = (x * x <= threshold);
					} while(false);

					if (!canSleep) {
						this._wakeTime = timeStamp;
						return false;
					} else {
						return ((this._wakeTime + Physics2DConfig.SLEEP_DELAY) < timeStamp);
					}
				}
			};

			// =====================================================================
			Physics2DRigidBody.prototype._deltaRotation = function (delta) {

                if( this.fixedRotation ) return

				var data = this._data;
				var rotation = (data[(/*BODY_POS*/ 2) + 2] += delta);
				if ((delta * delta) > Physics2DConfig.DELTA_ROTATION_EPSILON) {
					data[(/*BODY_AXIS*/ 5)] = Math.cos(rotation);
					data[(/*BODY_AXIS*/ 5) + 1] = Math.sin(rotation);
				} else {
					// approximation of axis rotation
					// p, delta provide small angle approximations
					// whilst m provides an approximation to 1/|axis| after
					// the small angle rotation approximation, so as to
					// approximate the the normalization and hugely reduce
					// errors over many calls
					//
					// in testing even with an epsilon above of 0.01
					// the error in the axis is limited to 0.00002 after 100
					// updates.
					//
					// each update of the world, sin/cos is recomputed fully
					// so the accumulate error here is limited to a single step
					// and is really, very, very small.
					var d2 = (delta * delta);
					var p = (1 - (0.5 * d2));
					var m = (1 - (d2 * d2 * 0.125));

					var cos = data[(/*BODY_AXIS*/ 5)];
					var sin = data[(/*BODY_AXIS*/ 5) + 1];

					var nSin = ((p * sin) + (delta * cos)) * m;
					var nCos = ((p * cos) - (delta * sin)) * m;
					data[(/*BODY_AXIS*/ 5)] = nCos;
					data[(/*BODY_AXIS*/ 5) + 1] = nSin;
				}
				return rotation;
			};

			// Integrate to deltaTime from current sweepTime (back or forth).
			Physics2DRigidBody.prototype._sweepIntegrate = function (deltaTime) {
				var data = this._data;
				var delta = (deltaTime - data[(/*BODY_SWEEP_TIME*/ 18)]);
				if (delta !== 0) {
					data[(/*BODY_SWEEP_TIME*/ 18)] = deltaTime;
					data[(/*BODY_POS*/ 2)] += (data[(/*BODY_VEL*/ 7)] * delta);
					data[(/*BODY_POS*/ 2) + 1] += (data[(/*BODY_VEL*/ 7) + 1] * delta);

					var angVel = data[(/*BODY_SWEEP_ANGVEL*/ 20)];
					if (angVel !== 0) {
						this._deltaRotation(data[(/*BODY_SWEEP_ANGVEL*/ 20)] * delta);
					}
				}
			};

			Physics2DRigidBody.prototype.integrate = function (deltaTime) {
				if (this.world && (this.world._midStep || this._type === (/*TYPE_STATIC*/ 2))) {
					return;
				}

				var data = this._data;
				data[(/*BODY_SWEEP_TIME*/ 18)] = 0;
				data[(/*BODY_SWEEP_ANGVEL*/ 20)] = data[(/*BODY_VEL*/ 7) + 2];
				this._sweepIntegrate(deltaTime);
				data[(/*BODY_SWEEP_TIME*/ 18)] = 0;
				this._invalidated = true;
				this.wake(true);
			};

			// ==========================================================
			Physics2DRigidBody.prototype.addEventListener = function (eventType, callback) {
				var events = (eventType === 'wake' ? this._onWake : eventType === 'sleep' ? this._onSleep : null);

				if (events === null) {
					return false;
				}

				var index = events.indexOf(callback);
				if (index !== -1) {
					return false;
				}

				events.push(callback);

				this.wake();

				return true;
			};

			Physics2DRigidBody.prototype.removeEventListener = function (eventType, callback) {
				var events = (eventType === 'wake' ? this._onWake : eventType === 'sleep' ? this._onSleep : null);

				if (events === null) {
					return false;
				}

				var index = events.indexOf(callback);
				if (index === -1) {
					return false;
				}

				// Need to keep order, cannot use swap-pop
				events.splice(index, 1);

				this.wake();

				return true;
			};

			// params = {
			//      shapes: [...],
			//      mass: [...] = computed from shapes + type
			//      inertia: [...] = computed from shapes + type
			//      type: 'static', 'kinematic', 'dynamic' = 'kinematic'
			//      sleeping: = false,
			//      force: [, ] = [0,0],
			//      torque: = 0
			//      position: [...] = [0,0],
			//      rotation: = 0
			//      surfaceVelocity = [0,0]
			//      velocity: = [0,0],
			//      angularVelocity: = 0,
			//      bullet = false,
			//      linearDrag = 0.05,
			//      angularDrag = 0.05
			// }
			Physics2DRigidBody.create = function (params) {
				var b = new Physics2DRigidBody();
				var data = b._data = Types.createFloatArray((/*BODY_DATA_SIZE*/ 25));

				var inf = Number.POSITIVE_INFINITY;

				b._type = (params.type === 'dynamic' ? (/*TYPE_DYNAMIC*/ 0) : params.type === 'static' ? (/*TYPE_STATIC*/ 2) : params.type === 'kinematic' ? (/*TYPE_KINEMATIC*/ 1) : (/*TYPE_DYNAMIC*/ 0));

				var shapes = params.shapes;
				b.shapes = [];
				b.constraints = [];
				b.world = null;
                b.fixedRotation = params.fixedRotation

				var radius = 0;
				if (shapes) {
					var limit = shapes.length;
					var i;
					for (i = 0; i < limit; i += 1) {
						var shape = shapes[i];
						if (shape.body === b) {
							continue;
						}

						shape.body = b;
						b.shapes.push(shape);

						var rad = shape._data[(/*SHAPE_SWEEP_RADIUS*/ 4)];
						if (rad > radius) {
							radius = rad;
						}
					}
				}

				data[(/*BODY_RADIUS*/ 19)] = radius;

				b._customMass = (params.mass !== undefined);
				b._customInertia = (params.inertia !== undefined);
				var mass = (b._customMass ? params.mass : b.computeMassFromShapes());
				var inertia = (b._customInertia ? params.inertia : b.computeInertiaFromShapes());

				var isDynamic = (b._type === (/*TYPE_DYNAMIC*/ 0));
				var isStatic = (b._type === (/*TYPE_STATIC*/ 2));

				data[(/*BODY_IMASS*/ 0)] = ((!isDynamic) || mass === inf) ? 0 : (1 / mass);
				data[(/*BODY_IINERTIA*/ 1)] = ((!isDynamic) || inertia === inf) ? 0 : (1 / inertia);
				data[(/*BODY_MASS*/ 23)] = mass;
				data[(/*BODY_INERTIA*/ 24)] = inertia;

				var vec = params.position;
				var x = data[(/*BODY_POS*/ 2)] = (vec ? vec[0] : 0);
				var y = data[(/*BODY_POS*/ 2) + 1] = (vec ? vec[1] : 0);
				var rot = data[(/*BODY_POS*/ 2) + 2] = (params.rotation || 0);

				data[(/*BODY_AXIS*/ 5)] = Math.cos(rot);
				data[(/*BODY_AXIS*/ 5) + 1] = Math.sin(rot);

				data[(/*BODY_PRE_POS*/ 15)] = x;
				data[(/*BODY_PRE_POS*/ 15) + 1] = y;
				data[(/*BODY_PRE_POS*/ 15) + 2] = rot;

				vec = params.velocity;
				data[(/*BODY_VEL*/ 7)] = (((!isStatic) && vec) ? vec[0] : 0);
				data[(/*BODY_VEL*/ 7) + 1] = (((!isStatic) && vec) ? vec[1] : 0);
				data[(/*BODY_VEL*/ 7) + 2] = (((!isStatic) && params.angularVelocity) || 0);

				vec = params.force;
				data[(/*BODY_FORCE*/ 10)] = (vec ? vec[0] : 0);
				data[(/*BODY_FORCE*/ 10) + 1] = (vec ? vec[1] : 0);
				data[(/*BODY_FORCE*/ 10) + 2] = (params.torque || 0);

				vec = params.surfaceVelocity;
				data[(/*BODY_SURFACE_VEL*/ 13)] = (vec ? vec[0] : 0);
				data[(/*BODY_SURFACE_VEL*/ 13) + 1] = (vec ? vec[1] : 0);

				b.sleeping = (params.sleeping || false);
				b.bullet = (params.bullet || false);

				// Static/kinematic always 'frozen'
				b._sweepFrozen = (b._type !== (/*TYPE_DYNAMIC*/ 0));
				b._deferred = false;

				b._island = null;
				b._islandRank = 0;
				b._islandRoot = null;

				b._isBody = true;
				b._wakeTime = 0;
				b._woken = false; // for deferred WAKE callbacks.

				b._invalidated = true;

				data[(/*BODY_LIN_DRAG*/ 21)] = Math.log(1 - (params.linearDrag !== undefined ? params.linearDrag : 0.05));
				data[(/*BODY_ANG_DRAG*/ 22)] = Math.log(1 - (params.angularDrag !== undefined ? params.angularDrag : 0.05));

				b.userData = (params.userData || null);

				b._onWake = [];
				b._onSleep = [];

				return b;
			};
			Physics2DRigidBody.version = 1;
			return Physics2DRigidBody;
})

// =========================================================================
//
// Physics2D Polygon
//
// POLYGON DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POLY_VERTICES*/6   // Start of vertex data
///*POLY_STRIDE*/13    // Values per vertex till end of object.
//
// PER VERTEX CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*POLY_LOCAL*/0     // Local position of vertex (x, y)
///*POLY_WORLD*/2     // World position of vertex (x, y)
///*POLY_LNORMAL*/4   // Local normal of edge starting at vertex (x, y)
///*POLY_WNORMAL*/6   // World normal of edge starting at vertex (x, y)
///*POLY_LPROJ*/8     // Local projection of polygon to edge.
///*POLY_WPROJ*/9      // World projection of polygon to edge.
///*POLY_CROSS1*/10    // World cross-projection of vertex to its edge.
///*POLY_CROSS2*/11   // World cross-projection of 'next' vertex to this edge.
///*POLY_LENGTH*/12   // Length of edge startinga t this vertex.
define(
	'spell/physics/2D/Polygon',
	[
		'spell/physics/2D/Shape',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DShape,
		Types
		) {

		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DPolygon = function Physics2DPolygon() {
			Physics2DShape.call(this);
			this.type = "POLYGON";
		}

		__extends(Physics2DPolygon, Physics2DShape);

		Physics2DPolygon.prototype.computeArea = function () {
			var data = this._data;
			var index = (/*POLY_VERTICES*/ 6);
			var limit = data.length;
			var doubleArea = 0;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var next = index + (/*POLY_STRIDE*/ 13);
				if (next === limit) {
					next = (/*POLY_VERTICES*/ 6);
				}

				doubleArea += ((data[index + (/*POLY_LOCAL*/ 0)] * data[next + (/*POLY_LOCAL*/ 0) + 1]) - (data[index + (/*POLY_LOCAL*/ 0) + 1] * data[next + (/*POLY_LOCAL*/ 0)]));
			}
			return (doubleArea * 0.5);
		};

		Physics2DPolygon.prototype.computeMasslessInertia = function () {
			var data = this._data;
			var index = (/*POLY_VERTICES*/ 6);
			var limit = data.length;
			var s1 = 0;
			var s2 = 0;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var next = index + (/*POLY_STRIDE*/ 13);
				if (next === limit) {
					next = (/*POLY_VERTICES*/ 6);
				}

				var x1 = data[index + (/*POLY_LOCAL*/ 0)];
				var y1 = data[index + (/*POLY_LOCAL*/ 0) + 1];
				var x2 = data[next + (/*POLY_LOCAL*/ 0)];
				var y2 = data[next + (/*POLY_LOCAL*/ 0) + 1];

				var a = (x1 * y2) - (x2 * y1);
				var b = ((x1 * x1) + (y1 * y1)) + ((x2 * x2) + (y2 * y2)) + ((x1 * x2) + (y1 * y2));

				s1 += (a * b);
				s2 += a;
			}

			return (s1 / (6 * s2));
		};

		// Workaround for TS lack of support for abstract methods
		Physics2DPolygon.prototype.computeCenterOfMass = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = Types.createFloatArray(2);
			}

			var data = this._data;
			var index = (/*POLY_VERTICES*/ 6);
			var limit = data.length;
			var doubleArea = 0;
			var cx = 0;
			var cy = 0;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var next = index + (/*POLY_STRIDE*/ 13);
				if (next === limit) {
					next = (/*POLY_VERTICES*/ 6);
				}

				var x1 = data[index + (/*POLY_LOCAL*/ 0)];
				var y1 = data[index + (/*POLY_LOCAL*/ 0) + 1];
				var x2 = data[next + (/*POLY_LOCAL*/ 0)];
				var y2 = data[next + (/*POLY_LOCAL*/ 0) + 1];

				var cross = ((x1 * y2) - (y1 * x2));
				doubleArea += cross;
				cx += ((x1 + x2) * cross);
				cy += ((y1 + y2) * cross);
			}

			var rec = (1 / (3 * doubleArea));
			dst[0] = (cx * rec);
			dst[1] = (cy * rec);

			return dst;
		};

		// ===========================================================================
		Physics2DPolygon.prototype.setVertices = function (vertices /*v2[]*/ ) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			this._validate(vertices);
			if (body) {
				body._invalidate();
			}
		};

		// ===========================================================================
		Physics2DPolygon.prototype.clone = function () {
			var c = new Physics2DPolygon();
			Physics2DShape.prototype.copyCommon(this, c);
			return c;
		};

		// ===========================================================================
		Physics2DPolygon.prototype.scale = function (scaleX, scaleY) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			if (scaleY === undefined) {
				scaleY = scaleX;
			}

			if (scaleX <= 0 || scaleY <= 0) {
				return;
			}

			var iscaleX = (1 / scaleX);
			var iscaleY = (1 / scaleY);

			var data = this._data;
			var limit = data.length;
			var index = (/*POLY_VERTICES*/ 6);

			var radius = 0.0;
			var minProj = Number.POSITIVE_INFINITY;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var x = (data[index + (/*POLY_LOCAL*/ 0)] *= scaleX);
				var y = (data[index + (/*POLY_LOCAL*/ 0) + 1] *= scaleY);

				var nx = (data[index + (/*POLY_LNORMAL*/ 4)] * iscaleX);
				var ny = (data[index + (/*POLY_LNORMAL*/ 4) + 1] * iscaleY);
				var rec = (1 / Math.sqrt((nx * nx) + (ny * ny)));

				data[index + (/*POLY_LNORMAL*/ 4)] = (nx *= rec);
				data[index + (/*POLY_LNORMAL*/ 4) + 1] = (ny *= rec);
				var lproj = data[index + (/*POLY_LPROJ*/ 8)] = ((nx * x) + (ny * y));
				if (lproj < minProj) {
					minProj = lproj;
				}
				var vlsq = ((x * x) + (y * y));
				if (vlsq > radius) {
					radius = vlsq;
				}

				var next = (index + (/*POLY_STRIDE*/ 13));
				if (next === limit) {
					next = (/*POLY_VERTICES*/ 6);
				}

				var dx = ((data[next + (/*POLY_LOCAL*/ 0)] * scaleX) - x);
				var dy = ((data[next + (/*POLY_LOCAL*/ 0) + 1] * scaleY) - y);
				var dL = Math.sqrt((dx * dx) + (dy * dy));
				data[index + (/*POLY_LENGTH*/ 12)] = dL;
			}

			data[(/*SHAPE_SWEEP_RADIUS*/ 4)] = Math.sqrt(radius);
			data[(/*SHAPE_SWEEP_FACTOR*/ 5)] = (data[(/*SHAPE_SWEEP_RADIUS*/ 4)] - Math.max(minProj, 0));
			if (body) {
				body._invalidate();
			}
		};

		Physics2DPolygon.prototype.translate = function (translation /*v2*/ , skip) {
			var body = this.body;
			if (!skip && body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			var limit = data.length;
			var index = (/*POLY_VERTICES*/ 6);

			var tx = translation[0];
			var ty = translation[1];

			var radius = 0.0;
			var minProj = Number.POSITIVE_INFINITY;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var x = (data[index + (/*POLY_LOCAL*/ 0)] += tx);
				var y = (data[index + (/*POLY_LOCAL*/ 0) + 1] += ty);

				var nx = data[index + (/*POLY_LNORMAL*/ 4)];
				var ny = data[index + (/*POLY_LNORMAL*/ 4) + 1];
				var lproj = (data[index + (/*POLY_LPROJ*/ 8)] += ((nx * tx) + (ny * ty)));
				if (lproj < minProj) {
					minProj = lproj;
				}
				var vlsq = ((x * x) + (y * y));
				if (vlsq > radius) {
					radius = vlsq;
				}
				// Translation does not effect local normal or edge length.
			}

			data[(/*SHAPE_SWEEP_RADIUS*/ 4)] = Math.sqrt(radius);
			data[(/*SHAPE_SWEEP_FACTOR*/ 5)] = (data[(/*SHAPE_SWEEP_RADIUS*/ 4)] - Math.max(minProj, 0));
			if (!skip && body) {
				body._invalidate();
			}
		};

		Physics2DPolygon.prototype.rotate = function (rotation) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			var limit = data.length;
			var index = (/*POLY_VERTICES*/ 6);

			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);

			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				var x = data[index + (/*POLY_LOCAL*/ 0)];
				var y = data[index + (/*POLY_LOCAL*/ 0) + 1];
				data[index + (/*POLY_LOCAL*/ 0)] = ((x * cos) - (y * sin));
				data[index + (/*POLY_LOCAL*/ 0) + 1] = ((x * sin) + (y * cos));

				x = data[index + (/*POLY_LNORMAL*/ 4)];
				y = data[index + (/*POLY_LNORMAL*/ 4) + 1];
				data[index + (/*POLY_LNORMAL*/ 4)] = ((x * cos) - (y * sin));
				data[index + (/*POLY_LNORMAL*/ 4) + 1] = ((x * sin) + (y * cos));
				// Rotation does not effect local projection, edge length
				// nor does it effect radius and sweep factor.
			}

			if (body) {
				body._invalidate();
			}
		};

		Physics2DPolygon.prototype.transform = function (matrix /*m32*/ ) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			// a b tx
			// c d ty
			var a = matrix[0];
			var b = matrix[2];
			var c = matrix[1];
			var d = matrix[3];
			var tx = matrix[4];
			var ty = matrix[5];

			if (((a * d) - (b * c)) <= 0) {
				return;
			}

			var data = this._data;
			var limit = data.length;
			var index = (/*POLY_VERTICES*/ 6);
			var x, y;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				x = data[index + (/*POLY_LOCAL*/ 0)];
				y = data[index + (/*POLY_LOCAL*/ 0) + 1];
				data[index + (/*POLY_LOCAL*/ 0)] = ((a * x) + (b * y) + tx);
				data[index + (/*POLY_LOCAL*/ 0) + 1] = ((c * x) + (d * y) + ty);
			}

			var radius = 0.0;
			var minProj = Number.POSITIVE_INFINITY;
			index = (/*POLY_VERTICES*/ 6);
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				x = data[index + (/*POLY_LOCAL*/ 0)];
				y = data[index + (/*POLY_LOCAL*/ 0) + 1];

				var next = (index + (/*POLY_STRIDE*/ 13));
				if (next === limit) {
					next = (/*POLY_VERTICES*/ 6);
				}

				var dx = -(data[next + (/*POLY_LOCAL*/ 0)] - x);
				var dy = -(data[next + (/*POLY_LOCAL*/ 0) + 1] - y);
				var dL = Math.sqrt((dx * dx) + (dy * dy));
				var rec = (1 / dL);

				var nx = (-dy * rec);
				var ny = (dx * rec);

				data[index + (/*POLY_LNORMAL*/ 4)] = nx;
				data[index + (/*POLY_LNORMAL*/ 4) + 1] = ny;
				data[index + (/*POLY_LENGTH*/ 12)] = dL;
				var lproj = data[index + (/*POLY_LPROJ*/ 8)] = ((nx * x) + (ny * y));

				var vlsq = ((x * x) + (y * y));
				if (vlsq > radius) {
					radius = vlsq;
				}
				if (lproj < minProj) {
					minProj = lproj;
				}
			}

			data[(/*SHAPE_SWEEP_RADIUS*/ 4)] = Math.sqrt(radius);
			data[(/*SHAPE_SWEEP_FACTOR*/ 5)] = (data[(/*SHAPE_SWEEP_RADIUS*/ 4)] - Math.max(minProj, 0));
			if (body) {
				body._invalidate();
			}
		};

		// ===========================================================================
		Physics2DPolygon.prototype._update = function (posX, posY, cos, sin, skipAABB) {
			var data = this._data;
			var limit = data.length;
			var index = (/*POLY_VERTICES*/ 6);
			var j;

			var minX, minY, maxX, maxY;
			for (; index < limit; index += (/*POLY_STRIDE*/ 13)) {
				// Compute world-space vertex.
				var x = data[index + (/*POLY_LOCAL*/ 0)];
				var y = data[index + (/*POLY_LOCAL*/ 0) + 1];
				var vX = data[index + (/*POLY_WORLD*/ 2)] = posX + (cos * x) - (sin * y);
				var vY = data[index + (/*POLY_WORLD*/ 2) + 1] = posY + (sin * x) + (cos * y);

				// Compute world-space normal.
				x = data[index + (/*POLY_LNORMAL*/ 4)];
				y = data[index + (/*POLY_LNORMAL*/ 4) + 1];
				var nx = data[index + (/*POLY_WNORMAL*/ 6)] = (cos * x) - (sin * y);
				var ny = data[index + (/*POLY_WNORMAL*/ 6) + 1] = (sin * x) + (cos * y);

				// Compute world-space projections.
				data[index + (/*POLY_WPROJ*/ 9)] = (nx * vX) + (ny * vY);
				data[index + (/*POLY_CROSS1*/ 10)] = (nx * vY) - (ny * vX);
				if (index !== (/*POLY_VERTICES*/ 6)) {
					j = index - (/*POLY_STRIDE*/ 13);
					data[j + (/*POLY_CROSS2*/ 11)] = ((data[j + (/*POLY_WNORMAL*/ 6)] * vY) - (data[j + (/*POLY_WNORMAL*/ 6) + 1] * vX));

					if (!skipAABB) {
						// Update partial AABB.
						if (vX < minX) {
							minX = vX;
						} else if (vX > maxX) {
							maxX = vX;
						}

						if (vY < minY) {
							minY = vY;
						} else if (vY > maxY) {
							maxY = vY;
						}
					}
				} else if (!skipAABB) {
					// Init. partial AABB.
					minX = maxX = vX;
					minY = maxY = vY;
				}
			}

			// Compute remaining projection
			index = (/*POLY_VERTICES*/ 6);
			j = data.length - (/*POLY_STRIDE*/ 13);
			data[j + (/*POLY_CROSS2*/ 11)] = ((data[j + (/*POLY_WNORMAL*/ 6)] * data[index + (/*POLY_WORLD*/ 2) + 1]) - (data[j + (/*POLY_WNORMAL*/ 6) + 1] * data[index + (/*POLY_WORLD*/ 2)]));

			if (!skipAABB) {
				// AABB
				data[(/*SHAPE_AABB*/ 0)] = minX;
				data[(/*SHAPE_AABB*/ 0) + 1] = minY;
				data[(/*SHAPE_AABB*/ 0) + 2] = maxX;
				data[(/*SHAPE_AABB*/ 0) + 3] = maxY;
			}
		};

		Physics2DPolygon.prototype._validate = function (vertices /*v2[]*/ ) {
			var vCount = vertices.length;
			var data = this._data;

			// Avoid recreating array if number of vertices is unchanged!
			var newLimit = (/*POLY_VERTICES*/ 6) + (vCount * (/*POLY_STRIDE*/ 13));
			if (!data || newLimit !== data.length) {
				data = this._data = Types.createFloatArray(newLimit);
			}

			var radius = 0.0;
			var minProj = Number.POSITIVE_INFINITY;

			var index = (/*POLY_VERTICES*/ 6);
			var i;
			for (i = 0; i < vCount; i += 1, index += (/*POLY_STRIDE*/ 13)) {
				var v1 = vertices[i];
				var v2 = vertices[(i === (vCount - 1) ? 0 : (i + 1))];

				var x = v1[0];
				var y = v1[1];
				var dx = x - v2[0];
				var dy = y - v2[1];
				var dL = Math.sqrt((dx * dx) + (dy * dy));
				var rec = (1 / dL);

				var nx = (-dy * rec);
				var ny = (dx * rec);

				data[index + (/*POLY_LOCAL*/ 0)] = x;
				data[index + (/*POLY_LOCAL*/ 0) + 1] = y;
				data[index + (/*POLY_LNORMAL*/ 4)] = nx;
				data[index + (/*POLY_LNORMAL*/ 4) + 1] = ny;
				data[index + (/*POLY_LENGTH*/ 12)] = dL;
				var lproj = data[index + (/*POLY_LPROJ*/ 8)] = ((nx * x) + (ny * y));

				// ---
				var vlsq = ((x * x) + (y * y));
				if (vlsq > radius) {
					radius = vlsq;
				}
				if (lproj < minProj) {
					minProj = lproj;
				}
			}

			data[(/*SHAPE_SWEEP_RADIUS*/ 4)] = Math.sqrt(radius);
			data[(/*SHAPE_SWEEP_FACTOR*/ 5)] = (data[(/*SHAPE_SWEEP_RADIUS*/ 4)] - Math.max(minProj, 0));
		};

		// params = {
		//      vertices: [v2, v2, ...]  (CLOCKWISE)
		//      ... common shape props.
		// }
		// inVertices optionally replacing params.vertices
		Physics2DPolygon.create = function (params, inVertices) {
			var p = new Physics2DPolygon();
			p._type = (/*TYPE_POLYGON*/ 1);
			Physics2DShape.prototype.init(p, params);

			p._validate(inVertices || params.vertices);
			return p;
		};

	Physics2DPolygon.version = 1;

	return Physics2DPolygon;
})
define(
	'spell/physics/2D/Shape',
	[
		'spell/physics/2D/Material',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DMaterial,
	    Types
	) {
		var Physics2DShape = function () {
		}

		// _validate()
		// {
		//     debug.abort("abstract method");
		// }
		// Abstract methods (have to have a body unfortunately)
		Physics2DShape.prototype.computeArea = function () {
			//debug.abort("abstract method");
			return 0;
		};
		Physics2DShape.prototype.computeMasslessInertia = function () {
			//debug.abort("abstract method");
			return 0;
		};
		Physics2DShape.prototype.computeCenterOfMass = function (dst /*v2*/ ) {
			//debug.abort("abstract method");
			return null;
		};

		// {
		//     debug.abort("abstract method"); return 0;
		// }
		Physics2DShape.prototype.translate = function (translation, skip) {
			//debug.abort("abstract method");
		};
		Physics2DShape.prototype._update = function (posX, posY, cos, sin, skipAABB) {
			//debug.abort("abstract method");
		};
		Physics2DShape.prototype.clone = function () {
			//debug.abort("abstract method");
			return undefined;
		};

		// Methods
		Physics2DShape.prototype.getGroup = function () {
			return this._group;
		};

		Physics2DShape.prototype.setGroup = function (group) {
			this._group = group;
			if (this.body) {
				this.body.wake(true);
			}
		};

		Physics2DShape.prototype.getMask = function () {
			return this._mask;
		};

		Physics2DShape.prototype.setMask = function (mask) {
			this._mask = mask;
			if (this.body) {
				this.body.wake(true);
			}
		};

		Physics2DShape.prototype.getMaterial = function () {
			return this._material;
		};

		Physics2DShape.prototype.setMaterial = function (material) {
			if (this._material !== material) {
				this._material = material;
				if (this.body) {
					this.body._invalidate();
				}

				var arbiters = this.arbiters;
				var limit2 = arbiters.length;
				var j;
				for (j = 0; j < limit2; j += 1) {
					arbiters[j]._invalidate();
				}
			}
		};

		Physics2DShape.prototype.copyCommon = function (from, to) {
			to._type = from._type;

			to._material = from._material;
			to._group = from._group;
			to._mask = from._mask;
			to.sensor = from.sensor;

			to.id = Physics2DShape.uniqueId;
			Physics2DShape.uniqueId += 1;

			to.arbiters = [];
			to._bphaseHandle = null;

			to.userData = from.userData;

			var fromData = from._data;
			var limit = from._data.length;
			var toData = to._data = Types.createFloatArray(limit);
			var i;
			for (i = 0; i < limit; i += 1) {
				toData[i] = fromData[i];
			}

			to._onPreSolve = [];
			to._events = []; // onBegin, onEnd, onProgress combined.
		};

		Physics2DShape.prototype.init = function (shape, params) {
			shape._material = params.material || Physics2DMaterial.create();
			shape._group = (params.group !== undefined) ? params.group : 1;
			shape._mask = (params.mask !== undefined) ? params.mask : 0xffffffff;
			shape.sensor = (params.sensor !== undefined) ? params.sensor : false;

			shape.arbiters = [];
			shape._bphaseHandle = null;
			shape.userData = (params.userData !== undefined) ? params.userData : null;

			shape.id = Physics2DShape.uniqueId;
			Physics2DShape.uniqueId += 1;

			shape._onPreSolve = [];
			shape._events = []; // onBegin, onEnd, onProgress combined.
		};

		// =============================================================================
		Physics2DShape.eventIndex = function (events, type, callback, callbackMask) {
			var limit = events.length;
			var i;
			for (i = 0; i < limit; i += 1) {
				var eventObject = events[i];
				if (eventObject.callback === callback && eventObject.mask === callbackMask && eventObject.type === type) {
					return i;
				}
			}

			return -1;
		};

		Physics2DShape.prototype.addEventListener = function (eventType, callback, callbackMask, deterministic) {
			var events, type;
			if (eventType === 'preSolve') {
				events = this._onPreSolve;
				type = (/*EVENT_PRESOLVE*/ 6);
			} else {
				events = this._events;
				type = (eventType === 'begin' ? (/*EVENT_BEGIN*/ 1) : eventType === 'progress' ? (/*EVENT_PROGRESS*/ 2) : eventType === 'end' ? (/*EVENT_END*/ 3) : null);
			}

			if (type === null) {
				return false;
			}

			if (eventType !== 'preSolve') {
				deterministic = undefined;
			} else if (deterministic === undefined) {
				deterministic = false;
			}

			var index = Physics2DShape.eventIndex(events, type, callback, callbackMask);
			if (index !== -1) {
				return false;
			}

			events.push({
				callback: callback,
				mask: callbackMask,
				type: type,
				deterministic: deterministic
			});

			if (this.body) {
				this.body.wake(true);
			}

			return true;
		};

		Physics2DShape.prototype.removeEventListener = function (eventType, callback, callbackMask) {
			var events, type;
			if (eventType === 'preSolve') {
				events = this._onPreSolve;
				type = (/*EVENT_PRESOLVE*/ 6);
			} else {
				events = this._events;
				type = (eventType === 'begin' ? (/*EVENT_BEGIN*/ 1) : eventType === 'progress' ? (/*EVENT_PROGRESS*/ 2) : eventType === 'end' ? (/*EVENT_END*/ 3) : null);
			}

			if (type === null) {
				return false;
			}

			var index = Physics2DShape.eventIndex(events, type, callback, callbackMask);
			if (index === -1) {
				return false;
			}

			// Need to keep order, cannot use swap-pop
			events.splice(index, 1);

			if (this.body) {
				this.body.wake(true);
			}

			return true;
		};

		Physics2DShape.uniqueId = 0;
		return Physics2DShape;
})

// =========================================================================
//
// Physics2D Circle
//
// CIRCLE DATA CONSTANTS
// !! Must use regexp to change these globally (in all files) !!
//
///*CIRCLE_RADIUS*/6    // Radius of circle about its origin
///*CIRCLE_LOCAL*/7     // Local position of circle origin (x, y)
///*CIRCLE_WORLD*/9     // World position of circle origin (x, y)
//
///*CIRCLE_DATA_SIZE*/11
define(
	'spell/physics/2D/Circle',
	[
		'spell/physics/2D/Shape',
		'spell/shared/util/platform/Types'
	],
	function(
		Physics2DShape,
	    Types
	) {
		var __extends = function (d, b) {
			for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
			function __() { this.constructor = d; }
			__.prototype = b.prototype;
			d.prototype = new __();
		};

		var Physics2DCircle = function() {
			Physics2DShape.call(this);
			this.type = "CIRCLE";
		}

		__extends(Physics2DCircle, Physics2DShape);

		// ==============================================================
		Physics2DCircle.prototype.computeArea = function () {
			var r = this._data[(/*CIRCLE_RADIUS*/ 6)];
			return (Math.PI * r * r);
		};

		Physics2DCircle.prototype.computeMasslessInertia = function () {
			var data = this._data;
			var r = this._data[(/*CIRCLE_RADIUS*/ 6)];
			var x = data[(/*CIRCLE_LOCAL*/ 7)];
			var y = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			return ((0.5 * r * r) + ((x * x) + (y * y)));
		};

		// ==============================================================
		Physics2DCircle.prototype.getRadius = function () {
			return this._data[(/*CIRCLE_RADIUS*/ 6)];
		};

		Physics2DCircle.prototype.setRadius = function (radius) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			if (radius !== data[(/*CIRCLE_RADIUS*/ 6)]) {
				data[(/*CIRCLE_RADIUS*/ 6)] = radius;
				this._validate();
				if (body) {
					body._invalidate();
				}
			}
		};

		// ==============================================================
		Physics2DCircle.prototype.getOrigin = function (dst /*v2*/ ) {
			if (dst === undefined) {
				dst = new Types.createFloatArray(2);
			}
			var data = this._data;
			dst[0] = data[(/*CIRCLE_LOCAL*/ 7)];
			dst[1] = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			return dst;
		};

		Physics2DCircle.prototype.setOrigin = function (origin /*v2*/ ) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			var originX = origin[0];
			var originY = origin[1];

			if (data[(/*CIRCLE_LOCAL*/ 7)] !== originX || data[(/*CIRCLE_LOCAL*/ 7) + 1] !== originY) {
				data[(/*CIRCLE_LOCAL*/ 7)] = originX;
				data[(/*CIRCLE_LOCAL*/ 7) + 1] = originY;
				this._validate();
				if (body) {
					body._invalidate();
				}
			}
		};

		// ==============================================================
		Physics2DCircle.prototype.clone = function () {
			var c = new Physics2DCircle();
			Physics2DShape.prototype.copyCommon(this, c);
			return c;
		};

		// ==============================================================
		Physics2DCircle.prototype.scale = function (scale) {
			if (scale <= 0) {
				return;
			}

			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			data[(/*CIRCLE_LOCAL*/ 7)] *= scale;
			data[(/*CIRCLE_LOCAL*/ 7) + 1] *= scale;
			data[(/*CIRCLE_RADIUS*/ 6)] *= scale;

			this._validate();
			if (body) {
				body._invalidate();
			}
		};

		Physics2DCircle.prototype.translate = function (translation /*v2*/ , skip) {
			var body = this.body;
			if (!skip && body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var data = this._data;
			data[(/*CIRCLE_LOCAL*/ 7)] += translation[0];
			data[(/*CIRCLE_LOCAL*/ 7) + 1] += translation[1];

			this._validate();
			if (!skip && body) {
				body._invalidate();
			}
		};

		Physics2DCircle.prototype.rotate = function (rotation) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			var cos = Math.cos(rotation);
			var sin = Math.sin(rotation);
			var data = this._data;
			var x = data[(/*CIRCLE_LOCAL*/ 7)];
			var y = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			data[(/*CIRCLE_LOCAL*/ 7)] = ((cos * x) - (sin * y));
			data[(/*CIRCLE_LOCAL*/ 7) + 1] = ((sin * x) + (cos * y));

			this._validate();
			if (body) {
				body._invalidate();
			}
		};

		Physics2DCircle.prototype.transform = function (matrix /*m23*/ ) {
			var body = this.body;
			if (body && body.world && (body._type === (/*TYPE_STATIC*/ 2) || body.world._midStep)) {
				return;
			}

			// a b tx
			// c d ty
			var a = matrix[0];
			var b = matrix[2];
			var c = matrix[1];
			var d = matrix[3];

			var data = this._data;
			var det = ((a * d) - (b * c));
			if (det <= 0) {
				return;
			}

			data[(/*CIRCLE_RADIUS*/ 6)] *= Math.sqrt(det);

			var x = data[(/*CIRCLE_LOCAL*/ 7)];
			var y = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			data[(/*CIRCLE_LOCAL*/ 7)] = ((a * x) + (b * y) + matrix[4]);
			data[(/*CIRCLE_LOCAL*/ 7) + 1] = ((c * x) + (d * y) + matrix[5]);

			this._validate();
			if (body) {
				body._invalidate();
			}
		};

		// ==============================================================
		Physics2DCircle.prototype._update = function (posX, posY, cos, sin, skipAABB) {
			var data = this._data;
			var originX = data[(/*CIRCLE_LOCAL*/ 7)];
			var originY = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			var ox = data[(/*CIRCLE_WORLD*/ 9)] = posX + (cos * originX) - (sin * originY);
			var oy = data[(/*CIRCLE_WORLD*/ 9) + 1] = posY + (sin * originX) + (cos * originY);

			if (!skipAABB) {
				var radius = data[(/*CIRCLE_RADIUS*/ 6)];
				data[(/*SHAPE_AABB*/ 0)] = (ox - radius);
				data[(/*SHAPE_AABB*/ 0) + 1] = (oy - radius);
				data[(/*SHAPE_AABB*/ 0) + 2] = (ox + radius);
				data[(/*SHAPE_AABB*/ 0) + 3] = (oy + radius);
			}
		};

		Physics2DCircle.prototype._validate = function () {
			var data = this._data;
			var originX = data[(/*CIRCLE_LOCAL*/ 7)];
			var originY = data[(/*CIRCLE_LOCAL*/ 7) + 1];
			var radius = data[(/*CIRCLE_RADIUS*/ 6)];

			var olength = Math.sqrt((originX * originX) + (originY * originY));
			data[(/*SHAPE_SWEEP_RADIUS*/ 4)] = (radius + olength);
			data[(/*SHAPE_SWEEP_FACTOR*/ 5)] = (data[(/*SHAPE_SWEEP_RADIUS*/ 4)] - Math.max(radius - olength, 0));
		};

		Physics2DCircle.prototype.computeCenterOfMass = function (dst /*v2*/ ) {
			return this.getOrigin(dst);
		};

		// params = {
		//      radius: ##,
		//      origin: [##, ##] = [0, 0],
		//      ... common shape props.
		// }
		Physics2DCircle.create = function (params) {
			var c = new Physics2DCircle();
			c._type = (/*TYPE_CIRCLE*/ 0);
			Physics2DShape.prototype.init(c, params);

			var radius = params.radius;
			var originX = (params.origin ? params.origin[0] : 0);
			var originY = (params.origin ? params.origin[1] : 0);

			var data = c._data = Types.createFloatArray((/*CIRCLE_DATA_SIZE*/ 11));
			data[(/*CIRCLE_RADIUS*/ 6)] = radius;
			data[(/*CIRCLE_LOCAL*/ 7)] = originX;
			data[(/*CIRCLE_LOCAL*/ 7) + 1] = originY;
			c._validate();

			return c;
		};
		Physics2DCircle.version = 1;

		return Physics2DCircle;

});
define(
	'spell/physics/2D/Material',
	[
		'spell/shared/util/platform/Types'
	],
	function( Types ) {
		var Physics2DMaterial = function() {
		}
		Physics2DMaterial.prototype.getElasticity = function () {
			return this._data[(/*MAT_ELASTICITY*/ 0)];
		};

		Physics2DMaterial.prototype.getStaticFriction = function () {
			return this._data[(/*MAT_STATIC*/ 1)];
		};

		Physics2DMaterial.prototype.getDynamicFriction = function () {
			return this._data[(/*MAT_DYNAMIC*/ 2)];
		};

		Physics2DMaterial.prototype.getRollingFriction = function () {
			return this._data[(/*MAT_ROLLING*/ 3)];
		};

		Physics2DMaterial.prototype.getDensity = function () {
			return this._data[(/*MAT_DENSITY*/ 4)];
		};

		// params = {
		//    elasticity: ## = 0,
		//    staticFriction: ## = 2,
		//    dynamicFriction: ## = 1,
		//    rollingFriction: ## = 0.005,
		//    density: ## = 1,
		//    userData: null
		// }
		Physics2DMaterial.create = function (params) {
			var m = new Physics2DMaterial();
			var elasticity = (params && params.elasticity !== undefined ? params.elasticity : 0);
			var staticFriction = (params && params.staticFriction !== undefined ? params.staticFriction : 2);
			var dynamicFriction = (params && params.dynamicFriction !== undefined ? params.dynamicFriction : 1);
			var rollingFriction = (params && params.rollingFriction !== undefined ? params.rollingFriction : 0.005);
			var density = (params && params.density !== undefined ? params.density : 1);

			var data = m._data = Types.createFloatArray((/*MATERIAL_DATA_SIZE*/ 5));

			data[(/*MAT_ELASTICITY*/ 0)] = elasticity;
			data[(/*MAT_STATIC*/ 1)] = staticFriction;
			data[(/*MAT_DYNAMIC*/ 2)] = dynamicFriction;
			data[(/*MAT_ROLLING*/ 3)] = rollingFriction;
			data[(/*MAT_DENSITY*/ 4)] = density;

			m.userData = (params && params.userData ? params.userData : null);

			return m;
		};
		Physics2DMaterial.version = 1;

		Physics2DMaterial.defaultMaterial = Physics2DMaterial.create();

		return Physics2DMaterial;
	}
)


/**
 * @class spell.physicsManager
 * @singleton
 *
 * Provides rigid body physics
 *
 * The PhysicsManager is powered by Turblenz 2DPhysicsDevice Copyright (c) 2009-2014 Turbulenz Limited
 *
 * physicsManager uses SI units of meters (m), radians (rad), seconds (s), kilograms (kg) and Newtons (N).
 *
 * Physics parameters are tuned for objects in size ranging down to an absolute minimum of 0.001m = 1mm. Objects smaller than this will not behave correctly due to contact slop and thresholds in continuous collision detection routines. At the same time, for stability reasons there is a permitted slop in positional contacts of 0.01m = 1cm so that whilst objects down to 1mm are acceptible, objects this small will not interact together properly. You should try to keep objects at least 1cm big.
 * A suggestion if your game operates in pixels (px) is to use a scaling factor of roughly 60px for every 1m.
 */
define(
	'spell/PhysicsManager',
	[
		'spell/shared/util/platform/Types',
		'spell/physics/2D/Material',
		'spell/physics/2D/Circle',
		'spell/physics/2D/Polygon',
		'spell/physics/2D/RigidBody',
		'spell/physics/2D/World',
		'spell/physics/2D/AngleConstraint',
		'spell/physics/2D/PulleyConstraint',
		'spell/physics/2D/MotorConstraint',
		'spell/physics/2D/WeldConstraint',
		'spell/physics/2D/PointConstraint',
		'spell/physics/2D/LineConstraint',
		'spell/physics/2D/DistanceConstraint',
		'spell/physics/2D/CustomConstraint',
		'spell/physics/2D/SweepAndPrune',
		'spell/physics/2D/BoxTreeBroadphase',
		'spell/physics/2D/CollisionUtils',
		'spell/physics/2D/DebugDraw'
	],
	function(
		Types,
		Physics2DMaterial,
		Physics2DCircle,
		Physics2DPolygon,
		Physics2DRigidBody,
		Physics2DWorld,
		Physics2DAngleConstraint,
		Physics2DPulleyConstraint,
		Physics2DMotorConstraint,
		Physics2DWeldConstraint,
		Physics2DPointConstraint,
		Physics2DLineConstraint,
		Physics2DDistanceConstraint,
		Physics2DCustomConstraint,
		Physics2DSweepAndPrune,
		Physics2DBoxTreeBroadphase,
		Physics2DCollisionUtils,
		Physics2DDebugDraw
	) {
		'use strict'


		var PhysicsManager = function() {

			var _graphicsDevice = {
				width: 800,
				height: 600,
				technique: undefined,
				setStream: function() {

				},
				setTechnique: function( technique ) {
					this.technique = technique
				},
				setTechniqueParameters: function() {

				},
				setScissor: function() {

				},
				createIndexBuffer: function() {
					return {
						destroy: function() {

						},
						setData: function() {

						}
					}
				},
				setIndexBuffer: function() {

				},
				drawIndexed: function() {

				},
				createSemantics: function() {

				},
				createVertexBuffer: function() {
					return {
						destroy: function() {

						},
						setData: function() {

						}
					}
				},
				createShader: function() {
					return {
						getTechnique: function() {
							return {}
						}
					}
				},
				createTechniqueParameters: function() {

					return {
						clipSpace: new Array(4)
					}
				}
			}

			this.debugDraw = Physics2DDebugDraw.create( { graphicsDevice: _graphicsDevice } )
			this.debug = false
		}

		var idToBody           = {}




		var getBodyById = function( entityId ) {
			return idToBody[ entityId ]
		}

		var applyForce = function( entityId, force ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var scale  = this.scale,
				forceX = force[ 0 ] * scale,
				forceY = force[ 1 ] * scale

			if( forceX || forceY ) {
				body.setForce( [ forceX, forceY ] )
			}
		}

		var setTorque = function( entityId, torque ) {
			var body = getBodyById( entityId )
			if( !body ) return

			if( torque ) {
				body.setTorque( torque )
			}
		}

		var applyImpulse = function( entityId, impulse, point ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var scale    = this.scale,
				impulseX = impulse[ 0 ] * scale,
				impulseY = impulse[ 1 ] * scale

			if( impulseX || impulseY ) {
				body.applyImpulse(
					[ impulseX, impulseY ],
					point ?
						[ point[ 0 ] * scale, point[ 1 ] * scale ] :
						undefined
				)
			}
		}

		var setVelocity = function( entityId, velocity ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var scale = this.scale

			body.setVelocity( [
				velocity[ 0 ] * scale,
				velocity[ 1 ] * scale
			])
		}

		var setVelocityX = function( entityId, velocityX ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var scale    = this.scale,
				velocity = body.getVelocity()

			body.setVelocity( [
				velocityX * scale,
				velocity[ 1 ]
			])
		}

		var setVelocityY = function( entityId, velocityY ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var scale    = this.scale,
				velocity = body.getVelocity()

			body.setVelocity( [
				velocity[ 0 ],
				velocityY * scale
			])
		}

		var getVelocity = function( entityId, dst ) {
			var body = getBodyById( entityId )
			if( !body ) return

			return body.getVelocity( dst )
		}

		var setFilterData = function( entityId, group, maskBits ) {
			var body = getBodyById( entityId )
			if( !body ) return

			var shapes = body.shapes

			for( var i = 0; i < shapes.length; i++ ) {
				var shape = shapes[ i ]

				if( group !== undefined ) {
					shape.setGroup( group )
				}

				if( maskBits !== undefined ) {
					shape.setMask( maskBits )
				}
			}
		}

		var setPosition = function( entityId, position ) {
			var body = getBodyById( entityId )
			if( !body ) return

			body.setPosition( position )
		}

		var getPosition = function( entityId, dst ) {
			var body = getBodyById( entityId )
			if( !body ) return

			return body.getPosition( dst )
		}

		var getRotation = function( entityId ) {
			var body = getBodyById( entityId )
			if( !body ) return

			return body.getRotation()
		}

		var setRotation = function( entityId, rotation ) {
			var body = getBodyById( entityId )
			if( !body ) return

			body.setRotation( rotation )
		}

		var createBodyDef = function( entityId, body, shapes, transform ) {
			var translation = transform.translation,
				scale       = this.scale

			var physicsBody = Physics2DRigidBody.create({
				type            : body.type,
				velocity        : [
					body.velocity[ 0 ] * scale,
					body.velocity[ 1 ] * scale
				],
				shapes          : shapes,
				position        :[
					translation[ 0 ],
					translation[ 1 ]
				],
				rotation        : transform.rotation,
                fixedRotation   : body.fixedRotation,
				mass            : body.mass > 0 ? body.mass : undefined,
				inertia         : body.inertia > 0 ? body.inertia : undefined,
				sleeping        : body.sleeping,
				bullet          : body.bullet,
				angularVelocity : body.angularVelocity,
				force           : body.force,
				torque          : body.torque,
				linearDrag      : body.linearDrag,
				angularDrag     : body.angularDrag,
				surfaceVelocity : body.surfaceVelocity,
				userData        : entityId
			})

			this.rawWorld.addRigidBody( physicsBody )

			idToBody[ entityId ] = physicsBody

			return physicsBody
		}

		var destroyBody = function( entityId ) {
			var body = getBodyById( entityId )
			if( !body ) return

			delete idToBody[ entityId ]

			this.rawWorld.removeRigidBody( body )
		}

		var step = function( deltaTime) {
			this.rawWorld.step( deltaTime )
		}

		var setAngularVelocity = function( entityId, angularVelocity ) {
			var body = getBodyById( entityId )
			if( !body ) return

			body.setAngularVelocity( angularVelocity )
		}

		var getAngularVelocity = function( entityId ) {
			var body = getBodyById( entityId )
			if( !body ) return

			return body.getAngularVelocity()
		}

		var setSurfaceVelocity = function( entityId, velocity ) {
			var body = getBodyById( entityId )
			if( !body ) return

			body.setSurfaceVelocity( velocity )
		}

		var getSurfaceVelocity = function( entityId ) {
			var body = getBodyById( entityId )
			if( !body ) return

			return body.getSurfaceVelocity()
		}

		var clear = function() {
			this.rawWorld.clear()
		}

		var getWorld = function() {
			return this.rawWorld
		}

        var putToSleep = function( entityId ) {
            var body = getBodyById( entityId )
            if( !body ) return

            return body.sleep()
        }

        var wakeUp = function( entityId ) {
            var body = getBodyById( entityId )
            if( !body ) return

            return body.wake()
        }

		var createWorld = function( gravity, scale, velocityIterations, positionIterations ) {
			if( !gravity ) gravity = [ 0, 0 ]
			if( !scale ) scale = 1

			this.rawWorld = Physics2DWorld.create({
				gravity            : gravity,
				velocityIterations : velocityIterations,
				positionIterations : positionIterations
			})

			this.scale = scale

			return this.rawWorld
		}

		var createRectangleVertices = function (minX, minY, maxX, maxY) {
			var tmp;
			if (maxX < minX) {
				tmp = minX;
				minX = maxX;
				maxX = tmp;
			}
			if (maxY < minY) {
				tmp = minY;
				minY = maxY;
				maxY = tmp;
			}

			var v0 = Types.createFloatArray(2);
			v0[0] = minX;
			v0[1] = minY;
			var v1 = Types.createFloatArray(2);
			v1[0] = maxX;
			v1[1] = minY;
			var v2 = Types.createFloatArray(2);
			v2[0] = maxX;
			v2[1] = maxY;
			var v3 = Types.createFloatArray(2);
			v3[0] = minX;
			v3[1] = maxY;

			return [v0, v1, v2, v3];
		};

		var createBoxVertices = function (width, height) {
			var w = (width * 0.5);
			var h = (height * 0.5);

			var v0 = Types.createFloatArray(2);
			v0[0] = -w;
			v0[1] = -h;
			var v1 = Types.createFloatArray(2);
			v1[0] = w;
			v1[1] = -h;
			var v2 = Types.createFloatArray(2);
			v2[0] = w;
			v2[1] = h;
			var v3 = Types.createFloatArray(2);
			v3[0] = -w;
			v3[1] = h;

			return [v0, v1, v2, v3];
		};

		var createRegularPolygonVertices = function (diameterX, diameterY, numVertices) {
			var rX = (diameterX * 0.5);
			var rY = (diameterY * 0.5);
			var vertices = [];

			var num = numVertices;
			var angInc = (Math.PI * 2 / num);

			var i;
			for (i = 0; i < num; i += 1) {
				var ang = (angInc * i);
				var vec = vertices[vertices.length] = Types.createFloatArray(2);
				vec[0] = (rX * Math.cos(ang));
				vec[1] = (rY * Math.sin(ang));
			}

			return vertices;
		};


		PhysicsManager.prototype = {
			createRectangleVertices : createRectangleVertices,

			createBoxVertices : createBoxVertices,

			createRegularPolygonVertices : createRegularPolygonVertices,

			getDefaultMaterial: function() {
				return Physics2DMaterial.defaultMaterial
			},

			createCircleShape: function( params ) {
				return Physics2DCircle.create( params )
			},

			createPolygonShape: function( params ) {
			 return Physics2DPolygon.create( params, null )
			},

			/**
			 * Create a RigidBody object.
			 * @param params
			 * @param {String} [params.type] The type of Rigid Body to create. One of *static*, *dynamic*, *kinematic*. Defaults to *dynamic*.
			 * @param {Array} [params.shapes] The set of Shapes to assign to the Rigid Body. Shapes may not be shared between rigid bodies. Shapes of a *static* body may not be modified once the body has been assigned to a World object.
			 * @param {Number} [params.mass] The mass in *kg* for this rigid body. This value must be strictly positive and has no effect on *static* and *kinematic* bodies which in terms of physics computations are assumed to have infinite mass. However if such a body should be transformed into a *dynamic* body at run-time, this value will still persist. If unspecified, mass will be computed as per *body.computeMassFromShapes()*.
			 * @param {Number} [params.inertia] The moment of inertia in kg*m²/rad². This value must be strictly positive and has no effect on *static* and *kinematic* bodies which in terms of physics computations are assumed to have infinite inertia. However if such a body should be transformed into a *dynamic* body at run-time, this value will still persist. If unspecified, inertia will be computed as per *body.computeInertiaFromShapes()*.
			 * @param {Boolean} [params.sleeping] Define if the body is to be created in a sleeping state. When added to a World object, the body will remain asleep until woken. Defaults to *false*.
			 * @param {Boolean} [params.bullet] Define if a *dynamic* body should collide continuously with other *dynamic* bodies. Continuous collision occur always between static/kinematic and dynamic bodies, but will occur between two dynamic bodies only if at least one of them is marked as a *bullet*. Due to implementation details of continuous collisions, you are advised not to create groups of bodies that interact together as bullets which may lead to visual stalling.
			 * @param {Array} [params.position] The position of the body’s origin in world coordinates. The position of a *static* body cannot be changed once it has been assigned to a World object, and modifications to this value equate to a teleportation of the body. *kinematic* bodies should be moved via manipulations of the body *velocity*. Defaults to *[0, 0]*.
			 * @param {Number} [params.rotation] The rotation of the body in clockwise radians. The rotation of a *static* body cannot be changed once it has been assigned to a World object, and modifications to this value equate to a teleportation of the body. *kinematic* bodies should be rotated via manipulations of the body *angularVelocity*. Defaults to *0*.
			 * @param {Array} [params.velocity] The linear velocity of the body in *m/s*. This parameter is ignored for *static* bodies which are not permitted to have a velocity. Defaults to *[0, 0]*.
			 * @param {Array} [params.angularVelocity] The angular velocity of the body in *rad/s*. This parameter is ignored for *static* bodies which are not permitted to have a velocity. Defaults to *[0, 0]*.
			 * @param {Array} [params.force] Force applied to the body at it’s origin for every update. As this is a force, and not an acceleration this property has no effect on *static* and *kinematic* bodies, or any *dynamic* body with infinite mass. This force is persistent, and is not reset after world update. Defaults to *[0, 0]*.
			 * @param {Array} [params.torque] Torque applied to the body at it’s origin for every update. As this is a torque, and not an acceleration this property has no effect on *static* and *kinematic* bodies, or any *dynamic* body with infinite inertia. This torque is persistent, and is not reset after world update. Defaults to *[0, 0]*.
			 * @param {Number} [params.linearDrag] The fraction of the linear velocity of a body which will be lost per second. This value must be >= 0. This property has no effect on *static* and *kinematic* bodies, or any *dynamic* body with infinite mass. Defaults to *0.05*.
			 * @param {Number} [params.angularDrag] The fraction of the angular velocity of a body which will be lost per second. This value must be >= 0. This property has no effect on *static* and *kinematic* bodies, or any *dynamic* body with infinite inertia. Defaults to *0.05*.
			 * @param {Array} [params.surfaceVelocity] An additional velocity in (*m/s*) used for contact physics and rotated to match the surface direction used to manipulate the effects of friction and normal reactions. Static objects may also be given a surface velocity. For example one may create a conveyor belt that moves objects pushed against in a clockwise direction by supplying a surface velocity with positive x-component. Defaults to *[0, 0]*.
			 * @param {Object} [params.userData] Field on which to store whatever information you may like.

			 * @returns {params}
			 */
			createRigidBody: function( params ) {
				return Physics2DRigidBody.create( params )
			},

			createMaterial: function( params ) {
				return Physics2DMaterial.create( params )
			},

			createCollisionUtils: function () {
				return Physics2DCollisionUtils.create()
			},

			createSweepAndPruneBroadphase: function () {
				return Physics2DSweepAndPrune.create()
			},

			createBoxTreeBroadphase: function () {
				return Physics2DBoxTreeBroadphase.create()
			},

			createPointConstraint: function( params ) {
				return Physics2DPointConstraint.create( params )
			},

			createWeldConstraint: function( params ) {
				return Physics2DWeldConstraint.create( params )
			},

			createAngleConstraint: function( params ) {
				return Physics2DAngleConstraint.create( params );
			},

			createDistanceConstraint: function( params ) {
				return Physics2DDistanceConstraint.create( params )
			},

			createLineConstraint: function( params ) {
				return Physics2DLineConstraint.create( params )
			},

			createMotorConstraint: function( params ) {
				return Physics2DMotorConstraint.create( params )
			},

			createPulleyConstraint: function( params ) {
				return Physics2DPulleyConstraint.create( params )
			},

			createCustomConstraint: function( params ) {
				return Physics2DCustomConstraint.create( params )
			},

			setDebugDrawOptions  : function( params ) {
				this.debugDraw.showConstraints     = params.showConstraints
				this.debugDraw.showContacts        = params.showContacts
				this.debugDraw.showContactImpulses = params.showContactImpulses
				this.debugDraw.showRigidBodies     = params.showRigidBodies
				this.debugDraw.showColliderShapes  = params.showColliderShapes
				this.debugDraw.showSensorShapes    = params.showSensorShapes
				this.debugDraw.showBodyDetail      = params.showBodyDetail
				this.debugDraw.showShapeDetail     = params.showShapeDetail

				this.debug = (
					params.showConstraints ||
					params.showContacts ||
					params.showContactImpulses ||
					params.showRigidBodies ||
					params.showColliderShapes ||
					params.showSensorShapes ||
					params.showBodyDetail ||
					params.showShapeDetail
				)
			},

			debugDrawHook : function( renderingContext, viewport ) {
				if( !this.debug == true )
					return

				this.debugDraw.renderingContext = renderingContext
				this.debugDraw.begin()
				this.debugDraw.drawWorld( this.rawWorld, viewport )
				this.debugDraw.end()

			},

			createWorld   : createWorld,

			getWorld      : getWorld,

			step          : step,

			clear         : clear,

            putToSleep    : putToSleep,

            wakeUp        : wakeUp,

			applyForce    : applyForce,

			setAngularVelocity: setAngularVelocity,

			getAngularVelocity: getAngularVelocity,

			getSurfaceVelocity: getSurfaceVelocity,

			setSurfaceVelocity: setSurfaceVelocity,

			applyImpulse  : applyImpulse,

			setTorque     : setTorque,

			createBodyDef : createBodyDef,

			destroyBody   : destroyBody,

			setFilterData : setFilterData,

			setPosition   : setPosition,

			getPosition   : getPosition,

			setVelocity   : setVelocity,

			setVelocityX  : setVelocityX,

			setVelocityY  : setVelocityY,

			getVelocity   : getVelocity,

			setRotation   : setRotation,

			getRotation   : getRotation
		}

		return PhysicsManager
	}
)

/*



*/
define(
	'spell/data/spatial/BoxTreeNode',
	function() {
		'use strict'
		// Copyright (c) 2012 Turbulenz Limited

		var BoxTreeNode = function BoxTreeNode(extents, escapeNodeOffset, externalNode) {
			this.escapeNodeOffset = escapeNodeOffset;
			this.externalNode = externalNode;
			this.extents = extents;
		}
		BoxTreeNode.prototype.isLeaf = function () {
			return !!this.externalNode;
		};

		BoxTreeNode.prototype.reset = function (minX, minY, maxX, maxY, escapeNodeOffset, externalNode) {
			this.escapeNodeOffset = escapeNodeOffset;
			this.externalNode = externalNode;
			var oldExtents = this.extents;
			oldExtents[0] = minX;
			oldExtents[1] = minY;
			oldExtents[2] = maxX;
			oldExtents[3] = maxY;
		};

		BoxTreeNode.prototype.clear = function () {
			this.escapeNodeOffset = 1;
			this.externalNode = undefined;
			var oldExtents = this.extents;
			var maxNumber = Number.MAX_VALUE;
			oldExtents[0] = maxNumber;
			oldExtents[1] = maxNumber;
			oldExtents[2] = -maxNumber;
			oldExtents[3] = -maxNumber;
		};

		// Constructor function
		BoxTreeNode.create = function (extents, escapeNodeOffset, externalNode) {
			return new BoxTreeNode(extents, escapeNodeOffset, externalNode);
		};
		BoxTreeNode.version = 1;
		return BoxTreeNode;
	}
)

define(
	'spell/data/spatial/BoxTree',
	[
		'spell/data/spatial/BoxTreeNode',
		'spell/shared/util/platform/Types'
	],
	function( BoxTreeNode, Types ) {
		'use strict'
		// Copyright (c) 2012 Turbulenz Limited

		var BoxTree = function(highQuality) {
			this.numNodesLeaf = 4;
			this.nodes = [];
			this.endNode = 0;
			this.needsRebuild = false;
			this.needsRebound = false;
			this.numAdds = 0;
			this.numUpdates = 0;
			this.numExternalNodes = 0;
			this.startUpdate = 0x7FFFFFFF;
			this.endUpdate = -0x7FFFFFFF;
			this.highQuality = highQuality;
		}

		BoxTree.prototype.add = function (externalNode, extents) {
			var endNode = this.endNode;
			externalNode.boxTreeIndex = endNode;
			var copyExtents = Types.createFloatArray(4);
			copyExtents[0] = extents[0];
			copyExtents[1] = extents[1];
			copyExtents[2] = extents[2];
			copyExtents[3] = extents[3];
			this.nodes[endNode] = BoxTreeNode.create(copyExtents, 1, externalNode);
			this.endNode = (endNode + 1);
			this.needsRebuild = true;
			this.numAdds += 1;
			this.numExternalNodes += 1;
		};

		BoxTree.prototype.remove = function (externalNode) {
			var index = externalNode.boxTreeIndex;
			if (index !== undefined) {
				if (this.numExternalNodes > 1) {
					var nodes = this.nodes;

					nodes[index].clear();

					var endNode = this.endNode;
					if ((index + 1) >= endNode) {
						while (!nodes[endNode - 1].externalNode) {
							endNode -= 1;
						}
						this.endNode = endNode;
					} else {
						this.needsRebuild = true;
					}
					this.numExternalNodes -= 1;
				} else {
					this.clear();
				}

				externalNode.boxTreeIndex = undefined;
			}
		};

		BoxTree.prototype.findParent = function (nodeIndex) {
			var nodes = this.nodes;
			var parentIndex = nodeIndex;
			var nodeDist = 0;
			var parent;
			do {
				parentIndex -= 1;
				nodeDist += 1;
				parent = nodes[parentIndex];
			} while(parent.escapeNodeOffset <= nodeDist);
			return parent;
		};

		BoxTree.prototype.update = function (externalNode, extents) {
			var index = externalNode.boxTreeIndex;
			if (index !== undefined) {
				var min0 = extents[0];
				var min1 = extents[1];
				var max0 = extents[2];
				var max1 = extents[3];

				var needsRebuild = this.needsRebuild;
				var needsRebound = this.needsRebound;
				var nodes = this.nodes;
				var node = nodes[index];
				var nodeExtents = node.extents;

				var doUpdate = (needsRebuild || needsRebound || nodeExtents[0] > min0 || nodeExtents[1] > min1 || nodeExtents[2] < max0 || nodeExtents[3] < max1);

				nodeExtents[0] = min0;
				nodeExtents[1] = min1;
				nodeExtents[2] = max0;
				nodeExtents[3] = max1;

				if (doUpdate) {
					if (!needsRebuild && 1 < nodes.length) {
						this.numUpdates += 1;
						if (this.startUpdate > index) {
							this.startUpdate = index;
						}
						if (this.endUpdate < index) {
							this.endUpdate = index;
						}
						if (!needsRebound) {
							// force a rebound when things change too much
							if ((2 * this.numUpdates) > this.numExternalNodes) {
								this.needsRebound = true;
							} else {
								var parent = this.findParent(index);
								var parentExtents = parent.extents;
								if (parentExtents[0] > min0 || parentExtents[1] > min1 || parentExtents[2] < max0 || parentExtents[3] < max1) {
									this.needsRebound = true;
								}
							}
						} else {
							// force a rebuild when things change too much
							if (this.numUpdates > (3 * this.numExternalNodes)) {
								this.needsRebuild = true;
								this.numAdds = this.numUpdates;
							}
						}
					}
				}
			} else {
				this.add(externalNode, extents);
			}
		};

		BoxTree.prototype.needsFinalize = function () {
			return (this.needsRebuild || this.needsRebound);
		};

		BoxTree.prototype.finalize = function () {
			if (this.needsRebuild) {
				this.rebuild();
			} else if (this.needsRebound) {
				this.rebound();
			}
		};

		BoxTree.prototype.rebound = function () {
			var nodes = this.nodes;
			if (nodes.length > 1) {
				var startUpdateNodeIndex = this.startUpdate;
				var endUpdateNodeIndex = this.endUpdate;

				var nodesStack = [];
				var numNodesStack = 0;
				var topNodeIndex = 0;
				for (; ;) {
					var topNode = nodes[topNodeIndex];
					var currentNodeIndex = topNodeIndex;
					var currentEscapeNodeIndex = (topNodeIndex + topNode.escapeNodeOffset);
					var nodeIndex = (topNodeIndex + 1);
					var node;
					do {
						node = nodes[nodeIndex];
						var escapeNodeIndex = (nodeIndex + node.escapeNodeOffset);
						if (nodeIndex < endUpdateNodeIndex) {
							if (!node.externalNode) {
								if (escapeNodeIndex > startUpdateNodeIndex) {
									nodesStack[numNodesStack] = topNodeIndex;
									numNodesStack += 1;
									topNodeIndex = nodeIndex;
								}
							}
						} else {
							break;
						}
						nodeIndex = escapeNodeIndex;
					} while(nodeIndex < currentEscapeNodeIndex);

					if (topNodeIndex === currentNodeIndex) {
						nodeIndex = (topNodeIndex + 1); // First child
						node = nodes[nodeIndex];

						var extents = node.extents;
						var minX = extents[0];
						var minY = extents[1];
						var maxX = extents[2];
						var maxY = extents[3];

						nodeIndex = (nodeIndex + node.escapeNodeOffset);
						while (nodeIndex < currentEscapeNodeIndex) {
							node = nodes[nodeIndex];
							extents = node.extents;
							if (minX > extents[0]) {
								minX = extents[0];
							}
							if (minY > extents[1]) {
								minY = extents[1];
							}
							if (maxX < extents[2]) {
								maxX = extents[2];
							}
							if (maxY < extents[3]) {
								maxY = extents[3];
							}
							nodeIndex = (nodeIndex + node.escapeNodeOffset);
						}

						extents = topNode.extents;
						extents[0] = minX;
						extents[1] = minY;
						extents[2] = maxX;
						extents[3] = maxY;

						endUpdateNodeIndex = topNodeIndex;

						if (0 < numNodesStack) {
							numNodesStack -= 1;
							topNodeIndex = nodesStack[numNodesStack];
						} else {
							break;
						}
					}
				}
			}

			this.needsRebuild = false;
			this.needsRebound = false;
			this.numAdds = 0;

			//this.numUpdates = 0;
			this.startUpdate = 0x7FFFFFFF;
			this.endUpdate = -0x7FFFFFFF;
		};

		BoxTree.prototype.rebuild = function () {
			if (this.numExternalNodes > 0) {
				var nodes = this.nodes;

				var buildNodes, numBuildNodes, endNodeIndex;

				if (this.numExternalNodes === nodes.length) {
					buildNodes = nodes;
					numBuildNodes = nodes.length;
					nodes = [];
					this.nodes = nodes;
				} else {
					buildNodes = [];
					buildNodes.length = this.numExternalNodes;
					numBuildNodes = 0;
					endNodeIndex = this.endNode;
					for (var n = 0; n < endNodeIndex; n += 1) {
						var currentNode = nodes[n];
						if (currentNode.externalNode) {
							nodes[n] = undefined;
							buildNodes[numBuildNodes] = currentNode;
							numBuildNodes += 1;
						}
					}
					if (buildNodes.length > numBuildNodes) {
						buildNodes.length = numBuildNodes;
					}
				}

				if (numBuildNodes > 1) {
					if (numBuildNodes > this.numNodesLeaf && this.numAdds > 0) {
						if (this.highQuality) {
							this.sortNodesHighQuality(buildNodes);
						} else {
							this.sortNodes(buildNodes);
						}
					}

					this.recursiveBuild(buildNodes, 0, numBuildNodes, 0);

					endNodeIndex = nodes[0].escapeNodeOffset;
					if (nodes.length > endNodeIndex) {
						nodes.length = endNodeIndex;
					}
					this.endNode = endNodeIndex;
				} else {
					var rootNode = buildNodes[0];
					rootNode.externalNode.boxTreeIndex = 0;
					nodes.length = 1;
					nodes[0] = rootNode;
					this.endNode = 1;
				}
				buildNodes = null;
			}

			this.needsRebuild = false;
			this.needsRebound = false;
			this.numAdds = 0;
			this.numUpdates = 0;
			this.startUpdate = 0x7FFFFFFF;
			this.endUpdate = -0x7FFFFFFF;
		};

		BoxTree.prototype.sortNodes = function (nodes) {
			var numNodesLeaf = this.numNodesLeaf;
			var numNodes = nodes.length;

			var getkeyXfn = function getkeyXfnFn(node) {
				var extents = node.extents;
				return (extents[0] + extents[2]);
			};

			var getkeyYfn = function getkeyYfnFn(node) {
				var extents = node.extents;
				return (extents[1] + extents[3]);
			};

			var getreversekeyXfn = function getreversekeyXfnFn(node) {
				var extents = node.extents;
				return -(extents[0] + extents[2]);
			};

			var getreversekeyYfn = function getreversekeyYfnFn(node) {
				var extents = node.extents;
				return -(extents[1] + extents[3]);
			};

			var nthElement = this.nthElement;
			var reverse = false;
			var axis = 0;

			var sortNodesRecursive = function sortNodesRecursiveFn(nodes, startIndex, endIndex) {
				/*jshint bitwise: false*/
				var splitNodeIndex = ((startIndex + endIndex) >> 1);

				/*jshint bitwise: true*/
				if (axis === 0) {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
					}
				} else {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
					}
				}

				if (axis === 0) {
					axis = 2;
				} else if (axis === 2) {
					axis = 1;
				} else {
					axis = 0;
				}

				reverse = !reverse;

				if ((startIndex + numNodesLeaf) < splitNodeIndex) {
					sortNodesRecursive(nodes, startIndex, splitNodeIndex);
				}

				if ((splitNodeIndex + numNodesLeaf) < endIndex) {
					sortNodesRecursive(nodes, splitNodeIndex, endIndex);
				}
			};

			sortNodesRecursive(nodes, 0, numNodes);
		};

		BoxTree.prototype.sortNodesHighQuality = function (nodes) {
			var numNodesLeaf = this.numNodesLeaf;
			var numNodes = nodes.length;

			var getkeyXfn = function getkeyXfnFn(node) {
				var extents = node.extents;
				return (extents[0] + extents[2]);
			};

			var getkeyYfn = function getkeyYfnFn(node) {
				var extents = node.extents;
				return (extents[1] + extents[3]);
			};

			var getkeyXYfn = function getkeyXYfnFn(node) {
				var extents = node.extents;
				return (extents[0] + extents[1] + extents[2] + extents[3]);
			};

			var getkeyYXfn = function getkeyYXfnFn(node) {
				var extents = node.extents;
				return (extents[0] - extents[1] + extents[2] - extents[3]);
			};

			var getreversekeyXfn = function getreversekeyXfnFn(node) {
				var extents = node.extents;
				return -(extents[0] + extents[2]);
			};

			var getreversekeyYfn = function getreversekeyYfnFn(node) {
				var extents = node.extents;
				return -(extents[1] + extents[3]);
			};

			var getreversekeyXYfn = function getreversekeyXYfnFn(node) {
				var extents = node.extents;
				return -(extents[0] + extents[1] + extents[2] + extents[3]);
			};

			var getreversekeyYXfn = function getreversekeyYXfnFn(node) {
				var extents = node.extents;
				return -(extents[0] - extents[1] + extents[2] - extents[3]);
			};

			var nthElement = this.nthElement;
			var calculateSAH = this.calculateSAH;
			var reverse = false;

			var sortNodesHighQualityRecursive = function sortNodesHighQualityRecursiveFn(nodes, startIndex, endIndex) {
				/*jshint bitwise: false*/
				var splitNodeIndex = ((startIndex + endIndex) >> 1);

				/*jshint bitwise: true*/
				nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
				var sahX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

				nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
				var sahY = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

				nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn);
				var sahXY = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

				nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn);
				var sahYX = (calculateSAH(nodes, startIndex, splitNodeIndex) + calculateSAH(nodes, splitNodeIndex, endIndex));

				if (sahX <= sahY && sahX <= sahXY && sahX <= sahYX) {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXfn);
					}
				} else if (sahY <= sahXY && sahY <= sahYX) {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYfn);
					}
				} else if (sahXY <= sahYX) {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyXYfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyXYfn);
					}
				} else {
					if (reverse) {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getreversekeyYXfn);
					} else {
						nthElement(nodes, startIndex, splitNodeIndex, endIndex, getkeyYXfn);
					}
				}

				reverse = !reverse;

				if ((startIndex + numNodesLeaf) < splitNodeIndex) {
					sortNodesHighQualityRecursive(nodes, startIndex, splitNodeIndex);
				}

				if ((splitNodeIndex + numNodesLeaf) < endIndex) {
					sortNodesHighQualityRecursive(nodes, splitNodeIndex, endIndex);
				}
			};

			sortNodesHighQualityRecursive(nodes, 0, numNodes);
		};

		BoxTree.prototype.calculateSAH = function (buildNodes, startIndex, endIndex) {
			var buildNode, extents, minX, minY, maxX, maxY;

			buildNode = buildNodes[startIndex];
			extents = buildNode.extents;
			minX = extents[0];
			minY = extents[1];
			maxX = extents[2];
			maxY = extents[3];

			for (var n = (startIndex + 1); n < endIndex; n += 1) {
				buildNode = buildNodes[n];
				extents = buildNode.extents;
				if (minX > extents[0]) {
					minX = extents[0];
				}
				if (minY > extents[1]) {
					minY = extents[1];
				}
				if (maxX < extents[2]) {
					maxX = extents[2];
				}
				if (maxY < extents[3]) {
					maxY = extents[3];
				}
			}

			return ((maxX - minX) + (maxY - minY));
		};

		BoxTree.prototype.nthElement = function (nodes, first, nth, last, getkey) {
			function medianFn(a, b, c) {
				if (a < b) {
					if (b < c) {
						return b;
					} else if (a < c) {
						return c;
					} else {
						return a;
					}
				} else if (a < c) {
					return a;
				} else if (b < c) {
					return c;
				}
				return b;
			}

			function insertionSortFn(nodes, first, last, getkey) {
				var sorted = (first + 1);
				while (sorted !== last) {
					var tempNode = nodes[sorted];
					var tempKey = getkey(tempNode);

					var next = sorted;
					var current = (sorted - 1);

					while (next !== first && tempKey < getkey(nodes[current])) {
						nodes[next] = nodes[current];
						next -= 1;
						current -= 1;
					}

					if (next !== sorted) {
						nodes[next] = tempNode;
					}

					sorted += 1;
				}
			}

			while ((last - first) > 8) {
				/*jshint bitwise: false*/
				var midValue = medianFn(getkey(nodes[first]), getkey(nodes[first + ((last - first) >> 1)]), getkey(nodes[last - 1]));

				/*jshint bitwise: true*/
				var firstPos = first;
				var lastPos = last;
				var midPos;
				for (; ; firstPos += 1) {
					while (getkey(nodes[firstPos]) < midValue) {
						firstPos += 1;
					}

					do {
						lastPos -= 1;
					} while(midValue < getkey(nodes[lastPos]));

					if (firstPos >= lastPos) {
						midPos = firstPos;
						break;
					} else {
						var temp = nodes[firstPos];
						nodes[firstPos] = nodes[lastPos];
						nodes[lastPos] = temp;
					}
				}

				if (midPos <= nth) {
					first = midPos;
				} else {
					last = midPos;
				}
			}

			insertionSortFn(nodes, first, last, getkey);
		};

		BoxTree.prototype.recursiveBuild = function (buildNodes, startIndex, endIndex, lastNodeIndex) {
			var nodes = this.nodes;
			var nodeIndex = lastNodeIndex;
			lastNodeIndex += 1;

			var minX, minY, maxX, maxY, extents;
			var buildNode, lastNode;

			if ((startIndex + this.numNodesLeaf) >= endIndex) {
				buildNode = buildNodes[startIndex];
				extents = buildNode.extents;
				minX = extents[0];
				minY = extents[1];
				maxX = extents[2];
				maxY = extents[3];

				buildNode.externalNode.boxTreeIndex = lastNodeIndex;
				nodes[lastNodeIndex] = buildNode;

				for (var n = (startIndex + 1); n < endIndex; n += 1) {
					buildNode = buildNodes[n];
					extents = buildNode.extents;
					if (minX > extents[0]) {
						minX = extents[0];
					}
					if (minY > extents[1]) {
						minY = extents[1];
					}
					if (maxX < extents[2]) {
						maxX = extents[2];
					}
					if (maxY < extents[3]) {
						maxY = extents[3];
					}
					lastNodeIndex += 1;
					buildNode.externalNode.boxTreeIndex = lastNodeIndex;
					nodes[lastNodeIndex] = buildNode;
				}

				lastNode = nodes[lastNodeIndex];
			} else {
				/*jshint bitwise: false*/
				var splitPosIndex = ((startIndex + endIndex) >> 1);

				/*jshint bitwise: true*/
				if ((startIndex + 1) >= splitPosIndex) {
					buildNode = buildNodes[startIndex];
					buildNode.externalNode.boxTreeIndex = lastNodeIndex;
					nodes[lastNodeIndex] = buildNode;
				} else {
					this.recursiveBuild(buildNodes, startIndex, splitPosIndex, lastNodeIndex);
				}

				lastNode = nodes[lastNodeIndex];
				extents = lastNode.extents;
				minX = extents[0];
				minY = extents[1];
				maxX = extents[2];
				maxY = extents[3];

				lastNodeIndex = (lastNodeIndex + lastNode.escapeNodeOffset);

				if ((splitPosIndex + 1) >= endIndex) {
					buildNode = buildNodes[splitPosIndex];
					buildNode.externalNode.boxTreeIndex = lastNodeIndex;
					nodes[lastNodeIndex] = buildNode;
				} else {
					this.recursiveBuild(buildNodes, splitPosIndex, endIndex, lastNodeIndex);
				}

				lastNode = nodes[lastNodeIndex];
				extents = lastNode.extents;
				if (minX > extents[0]) {
					minX = extents[0];
				}
				if (minY > extents[1]) {
					minY = extents[1];
				}
				if (maxX < extents[2]) {
					maxX = extents[2];
				}
				if (maxY < extents[3]) {
					maxY = extents[3];
				}
			}

			var node = nodes[nodeIndex];
			if (node !== undefined) {
				node.reset(minX, minY, maxX, maxY, (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
			} else {
				var parentExtents = Types.createFloatArray(4);
				parentExtents[0] = minX;
				parentExtents[1] = minY;
				parentExtents[2] = maxX;
				parentExtents[3] = maxY;

				nodes[nodeIndex] = BoxTreeNode.create(parentExtents, (lastNodeIndex + lastNode.escapeNodeOffset - nodeIndex));
			}
		};

		BoxTree.prototype.getVisibleNodes = function (planes, visibleNodes) {
			if (this.numExternalNodes > 0) {
				var nodes = this.nodes;
				var endNodeIndex = this.endNode;
				var numPlanes = planes.length;
				var numVisibleNodes = visibleNodes.length;
				var node, extents, endChildren;
				var n0, n1, p0, p1;
				var isInside, n, plane, d0, d1;
				var nodeIndex = 0;

				for (; ;) {
					node = nodes[nodeIndex];
					extents = node.extents;
					n0 = extents[0];
					n1 = extents[1];
					p0 = extents[2];
					p1 = extents[3];

					//isInsidePlanesBox
					isInside = true;
					n = 0;
					do {
						plane = planes[n];
						d0 = plane[0];
						d1 = plane[1];
						if ((d0 * (d0 < 0 ? n0 : p0) + d1 * (d1 < 0 ? n1 : p1)) < plane[2]) {
							isInside = false;
							break;
						}
						n += 1;
					} while(n < numPlanes);
					if (isInside) {
						if (node.externalNode) {
							visibleNodes[numVisibleNodes] = node.externalNode;
							numVisibleNodes += 1;
							nodeIndex += 1;
							if (nodeIndex >= endNodeIndex) {
								break;
							}
						} else {
							//isFullyInsidePlanesBox
							isInside = true;
							n = 0;
							do {
								plane = planes[n];
								d0 = plane[0];
								d1 = plane[1];
								if ((d0 * (d0 > 0 ? n0 : p0) + d1 * (d1 > 0 ? n1 : p1)) < plane[2]) {
									isInside = false;
									break;
								}
								n += 1;
							} while(n < numPlanes);
							if (isInside) {
								endChildren = (nodeIndex + node.escapeNodeOffset);
								nodeIndex += 1;
								do {
									node = nodes[nodeIndex];
									if (node.externalNode) {
										visibleNodes[numVisibleNodes] = node.externalNode;
										numVisibleNodes += 1;
									}
									nodeIndex += 1;
								} while(nodeIndex < endChildren);
								if (nodeIndex >= endNodeIndex) {
									break;
								}
							} else {
								nodeIndex += 1;
							}
						}
					} else {
						nodeIndex += node.escapeNodeOffset;
						if (nodeIndex >= endNodeIndex) {
							break;
						}
					}
				}
			}
		};

		BoxTree.prototype.getOverlappingNodes = function (queryExtents, overlappingNodes, startIndex) {
			if (this.numExternalNodes > 0) {
				var queryMinX = queryExtents[0];
				var queryMinY = queryExtents[1];
				var queryMaxX = queryExtents[2];
				var queryMaxY = queryExtents[3];
				var nodes = this.nodes;
				var endNodeIndex = this.endNode;
				var node, extents, endChildren;
				var numOverlappingNodes = 0;
				var storageIndex = (startIndex === undefined) ? overlappingNodes.length : startIndex;
				var nodeIndex = 0;
				for (; ;) {
					node = nodes[nodeIndex];
					extents = node.extents;
					var minX = extents[0];
					var minY = extents[1];
					var maxX = extents[2];
					var maxY = extents[3];
					if (queryMinX <= maxX && queryMinY <= maxY && queryMaxX >= minX && queryMaxY >= minY) {
						if (node.externalNode) {
							overlappingNodes[storageIndex] = node.externalNode;
							storageIndex += 1;
							numOverlappingNodes += 1;
							nodeIndex += 1;
							if (nodeIndex >= endNodeIndex) {
								break;
							}
						} else {
							if (queryMaxX >= maxX && queryMaxY >= maxY && queryMinX <= minX && queryMinY <= minY) {
								endChildren = (nodeIndex + node.escapeNodeOffset);
								nodeIndex += 1;
								do {
									node = nodes[nodeIndex];
									if (node.externalNode) {
										overlappingNodes[storageIndex] = node.externalNode;
										storageIndex += 1;
										numOverlappingNodes += 1;
									}
									nodeIndex += 1;
								} while(nodeIndex < endChildren);
								if (nodeIndex >= endNodeIndex) {
									break;
								}
							} else {
								nodeIndex += 1;
							}
						}
					} else {
						nodeIndex += node.escapeNodeOffset;
						if (nodeIndex >= endNodeIndex) {
							break;
						}
					}
				}
				return numOverlappingNodes;
			} else {
				return 0;
			}
		};

		BoxTree.prototype.getCircleOverlappingNodes = function (center, radius, overlappingNodes) {
			if (this.numExternalNodes > 0) {
				var radiusSquared = (radius * radius);
				var centerX = center[0];
				var centerY = center[1];
				var nodes = this.nodes;
				var endNodeIndex = this.endNode;
				var node, extents;
				var numOverlappingNodes = overlappingNodes.length;
				var nodeIndex = 0;
				for (; ;) {
					node = nodes[nodeIndex];
					extents = node.extents;
					var minX = extents[0];
					var minY = extents[1];
					var maxX = extents[2];
					var maxY = extents[3];
					var totalDistance = 0, sideDistance;
					if (centerX < minX) {
						sideDistance = (minX - centerX);
						totalDistance += (sideDistance * sideDistance);
					} else if (centerX > maxX) {
						sideDistance = (centerX - maxX);
						totalDistance += (sideDistance * sideDistance);
					}
					if (centerY < minY) {
						sideDistance = (minY - centerY);
						totalDistance += (sideDistance * sideDistance);
					} else if (centerY > maxY) {
						sideDistance = (centerY - maxY);
						totalDistance += (sideDistance * sideDistance);
					}
					if (totalDistance <= radiusSquared) {
						nodeIndex += 1;
						if (node.externalNode) {
							overlappingNodes[numOverlappingNodes] = node.externalNode;
							numOverlappingNodes += 1;
							if (nodeIndex >= endNodeIndex) {
								break;
							}
						}
					} else {
						nodeIndex += node.escapeNodeOffset;
						if (nodeIndex >= endNodeIndex) {
							break;
						}
					}
				}
			}
		};

		BoxTree.prototype.getOverlappingPairs = function (overlappingPairs, startIndex) {
			if (this.numExternalNodes > 0) {
				var nodes = this.nodes;
				var endNodeIndex = this.endNode;
				var currentNode, currentExternalNode, node, extents;
				var numInsertions = 0;
				var storageIndex = (startIndex === undefined) ? overlappingPairs.length : startIndex;
				var currentNodeIndex = 0, nodeIndex;
				for (; ;) {
					currentNode = nodes[currentNodeIndex];
					while (!currentNode.externalNode) {
						currentNodeIndex += 1;
						currentNode = nodes[currentNodeIndex];
					}

					currentNodeIndex += 1;
					if (currentNodeIndex < endNodeIndex) {
						currentExternalNode = currentNode.externalNode;
						extents = currentNode.extents;
						var minX = extents[0];
						var minY = extents[1];
						var maxX = extents[2];
						var maxY = extents[3];

						nodeIndex = currentNodeIndex;
						for (; ;) {
							node = nodes[nodeIndex];
							extents = node.extents;
							if (minX <= extents[2] && minY <= extents[3] && maxX >= extents[0] && maxY >= extents[1]) {
								nodeIndex += 1;
								if (node.externalNode) {
									overlappingPairs[storageIndex] = currentExternalNode;
									overlappingPairs[storageIndex + 1] = node.externalNode;
									storageIndex += 2;
									numInsertions += 2;
									if (nodeIndex >= endNodeIndex) {
										break;
									}
								}
							} else {
								nodeIndex += node.escapeNodeOffset;
								if (nodeIndex >= endNodeIndex) {
									break;
								}
							}
						}
					} else {
						break;
					}
				}
				return numInsertions;
			} else {
				return 0;
			}
		};

		BoxTree.prototype.getRootNode = function () {
			return this.nodes[0];
		};

		BoxTree.prototype.getNodes = function () {
			return this.nodes;
		};

		BoxTree.prototype.getEndNodeIndex = function () {
			return this.endNode;
		};

		BoxTree.prototype.clear = function () {
			this.nodes = [];
			this.endNode = 0;
			this.needsRebuild = false;
			this.needsRebound = false;
			this.numAdds = 0;
			this.numUpdates = 0;
			this.numExternalNodes = 0;
			this.startUpdate = 0x7FFFFFFF;
			this.endUpdate = -0x7FFFFFFF;
		};

		BoxTree.rayTest = function (trees, ray, callback) {
			// convert ray to parametric form
			var origin = ray.origin;
			var direction = ray.direction;

			// values used throughout calculations.
			var o0 = origin[0];
			var o1 = origin[1];
			var d0 = direction[0];
			var d1 = direction[1];
			var id0 = 1 / d0;
			var id1 = 1 / d1;

			// evaluate distance factor to a node's extents from ray origin, along direction
			// use this to induce an ordering on which nodes to check.
			var distanceExtents = function distanceExtentsFn(extents, upperBound) {
				var min0 = extents[0];
				var min1 = extents[1];
				var max0 = extents[2];
				var max1 = extents[3];

				// treat origin internal to extents as 0 distance.
				if (min0 <= o0 && o0 <= max0 && min1 <= o1 && o1 <= max1) {
					return 0.0;
				}

				var tmin, tmax;
				var tymin, tymax;
				var del;
				if (d0 >= 0) {
					// Deal with cases where d0 == 0
					del = (min0 - o0);
					tmin = ((del === 0) ? 0 : (del * id0));
					del = (max0 - o0);
					tmax = ((del === 0) ? 0 : (del * id0));
				} else {
					tmin = ((max0 - o0) * id0);
					tmax = ((min0 - o0) * id0);
				}

				if (d1 >= 0) {
					// Deal with cases where d1 == 0
					del = (min1 - o1);
					tymin = ((del === 0) ? 0 : (del * id1));
					del = (max1 - o1);
					tymax = ((del === 0) ? 0 : (del * id1));
				} else {
					tymin = ((max1 - o1) * id1);
					tymax = ((min1 - o1) * id1);
				}

				if ((tmin > tymax) || (tymin > tmax)) {
					return undefined;
				}

				if (tymin > tmin) {
					tmin = tymin;
				}

				if (tymax < tmax) {
					tmax = tymax;
				}

				if (tmin < 0) {
					tmin = tmax;
				}

				return (0 <= tmin && tmin < upperBound) ? tmin : undefined;
			};

			// we traverse both trees at once
			// keeping a priority list of nodes to check next.
			// TODO: possibly implement priority list more effeciently?
			//       binary heap probably too much overhead in typical case.
			var priorityList = [];

			//current upperBound on distance to first intersection
			//and current closest object properties
			var minimumResult = null;

			//if node is a leaf, intersect ray with shape
			// otherwise insert node into priority list.
			var processNode = function processNodeFn(tree, nodeIndex, upperBound) {
				var nodes = tree.getNodes();
				var node = nodes[nodeIndex];
				var distance = distanceExtents(node.extents, upperBound);
				if (distance === undefined) {
					return upperBound;
				}

				if (node.externalNode) {
					var result = callback(tree, node.externalNode, ray, distance, upperBound);
					if (result) {
						minimumResult = result;
						upperBound = result.factor;
					}
				} else {
					// TODO: change to binary search?
					var length = priorityList.length;
					var i;
					for (i = 0; i < length; i += 1) {
						var curObj = priorityList[i];
						if (distance > curObj.distance) {
							break;
						}
					}

					//insert node at index i
					priorityList.splice(i - 1, 0, {
						tree: tree,
						nodeIndex: nodeIndex,
						distance: distance
					});
				}

				return upperBound;
			};

			var upperBound = ray.maxFactor;

			var tree;
			var i;
			for (i = 0; i < trees.length; i += 1) {
				tree = trees[i];
				if (tree.endNode !== 0) {
					upperBound = processNode(tree, 0, upperBound);
				}
			}

			while (priorityList.length !== 0) {
				var nodeObj = priorityList.pop();

				// A node inserted into priority list after this one may have
				// moved the upper bound.
				if (nodeObj.distance >= upperBound) {
					continue;
				}

				var nodeIndex = nodeObj.nodeIndex;
				tree = nodeObj.tree;
				var nodes = tree.getNodes();

				var node = nodes[nodeIndex];
				var maxIndex = nodeIndex + node.escapeNodeOffset;

				var childIndex = nodeIndex + 1;
				do {
					upperBound = processNode(tree, childIndex, upperBound);
					childIndex += nodes[childIndex].escapeNodeOffset;
				} while(childIndex < maxIndex);
			}

			return minimumResult;
		};

		// Constructor function

		/**
		 *     var boxtree = Boxtree.create(highQuality);
		 *
		 * @param highQuality A boolean parameter. Setting to true enables a more optimal division of space when updating the tree. This can improve performance when doing many queries but it will make updating the tree more expensive. Usually it is only enabled for trees of objects that are either static or that don’t move much every frame.
		 */
		BoxTree.create = function (highQuality) {
			return new BoxTree(highQuality);
		};
		BoxTree.version = 1;

		return BoxTree;
	}
)

/**
 * Determines which entities' bounds are currently intersected or contained by the view frustum defined by the
 * currently active camera.
 *
 * @class spell.visibilityManager
 * @singleton
 */
define(
	'spell/VisibilityManager',
	[
		'spell/data/spatial/BoxTree',
		'spell/client/util/createEffectiveCameraDimensions',
		'spell/Defines',
		'spell/math/vec2',
		'spell/functions'
	],
	function(
		BoxTree,
		createEffectiveCameraDimensions,
		Defines,
		vec2,
		_
	) {
		'use strict'

		var VisibilityManager = function( eventManager, configurationManager, entityManager ) {
			this.configurationManager       = configurationManager
			this.eventManager               = eventManager
			this.entityManager              = entityManager


			this.uiPassEntitiesMap             = {}
			this.uiPassEntities                = []
			this.backgroundPassEntitiesMap     = {}
			this.backgroundPassEntities        = []

			this.worldPassEntitiesLength    = 0
			this.worldPassEntities          = []

			this.boxtree                    = undefined

			this.currentCameraId            = undefined
			this.screenSize                 = undefined

			// callback handler for event handling
			this.screenResizeHandler        = undefined
			this.cameraChangeHandler        = undefined
			this.componentChangeHandler     = undefined
			this.entityChangeHandler        = undefined

		}

		var entityIdsToBoxTreeNode = {}

		var updateEntity = function( entityId ) {
			var boxtree             = this.boxtree,
				entityManager       = this.entityManager,
				componentMaps       = entityManager.componentMaps,
				transforms          = componentMaps[ Defines.TRANSFORM_COMPONENT_ID ],
				visualObjects       = componentMaps[ Defines.VISUAL_OBJECT_COMPONENT_ID ],
				composites          = componentMaps[ Defines.COMPOSITE_COMPONENT_ID ],
				transform           = transforms ? transforms[ entityId ] : undefined,
				visualObject        = visualObjects ? visualObjects[ entityId ] : undefined,
				compositeComponent  = composites ? composites[ entityId ] : undefined,
				childrenIds         = compositeComponent ? compositeComponent.childrenIds : []


			if( !transform || !visualObject ) {
				// make sure that entities without a visual reprentation are removed from the boxtree
				if( entityIdsToBoxTreeNode[ entityId ] ) {
					boxtree.remove( entityIdsToBoxTreeNode[ entityId ] )
					delete entityIdsToBoxTreeNode[ entityId ]
				}

				if( this.backgroundPassEntitiesMap[ entityId ] )
					delete this.backgroundPassEntitiesMap[ entityId ]

				if( this.uiPassEntities[ entityId ] )
					delete this.uiPassEntities[ entityId ]

			} else {

				var dimensions          = entityManager.getEntityDimensions( entityId ),
					vertices            = transform && dimensions ? [
						transform.worldTranslation[ 0 ] - dimensions[ 0 ] / 2,
						transform.worldTranslation[ 1 ] - dimensions[ 1 ] / 2,
						transform.worldTranslation[ 0 ] + dimensions[ 0 ] / 2,
						transform.worldTranslation[ 1 ] + dimensions[ 1 ] / 2
					] : [ 0, 0, 0, 0 ]

				var entityInfo = entityIdsToBoxTreeNode[ entityId ] || {}

				if( !entityInfo.id ) {
					entityInfo.parent    = compositeComponent.parentId
					entityInfo.children  = compositeComponent.childrenIds
					entityInfo.layer     = visualObject ? visualObject.worldLayer : 0
					entityInfo.id        = entityId
					entityInfo.vertices  = vertices

					entityIdsToBoxTreeNode[ entityId ] = entityInfo
				}

				if( visualObject.pass === 'ui' ) {
					this.uiPassEntitiesMap[ entityId ] = entityInfo

				} else if ( visualObject.pass === 'background' ) {

					this.backgroundPassEntitiesMap[ entityId ] = entityInfo

				} else if ( visualObject.pass === 'world' ) {

					if( !entityInfo.boxTreeIndex ) {
						boxtree.add( entityInfo, entityInfo.vertices )

					} else if (
						vertices[ 0 ] != entityInfo.vertices[ 0 ] ||
						vertices[ 1 ] != entityInfo.vertices[ 1 ] ||
						vertices[ 2 ] != entityInfo.vertices[ 2 ] ||
						vertices[ 3 ] != entityInfo.vertices[ 3 ]
					) {

						boxtree.update( entityInfo, vertices )
						entityInfo.vertices  = vertices
					}
				}
			}

			_.each(
				childrenIds,
				_.bind( updateEntity, this )
			)

		}

		var registerScreenSizeHandler = function() {
			this.screenResizeHandler = _.bind(function( size ) {
				this.screenSize = size
			}, this)

			this.screenSize = this.configurationManager.getValue( 'currentScreenSize' )
			this.eventManager.subscribe(
				this.eventManager.EVENT.SCREEN_RESIZE,
				this.screenResizeHandler
			)
		}

		var unregisterScreenSizeHandler = function() {
			this.eventManager.unsubscribe(
				this.eventManager.EVENT.SCREEN_RESIZE,
				this.screenResizeHandler
			)
			this.screenSize = undefined
		}

		var registerCameraChangeHandler = function() {
			//register for camera changes
			this.cameraChangeHandler = _.bind(function( camera, entityId ) {
				this.currentCameraId = camera.active ? entityId : undefined
			}, this)

			this.eventManager.subscribe(
				[ this.eventManager.EVENT.COMPONENT_CREATED, Defines.CAMERA_COMPONENT_ID ],
				this.cameraChangeHandler
			)

			this.eventManager.subscribe(
				[ this.eventManager.EVENT.COMPONENT_UPDATED, Defines.CAMERA_COMPONENT_ID ],
				this.cameraChangeHandler
			)
		}

		var unregisterCameraChangeHandler = function() {
			this.eventManager.unsubscribe(
				[
					this.eventManager.EVENT.COMPONENT_CREATED,
					Defines.CAMERA_COMPONENT_ID
				],
				this.cameraChangeHandler
			)

			this.eventManager.unsubscribe(
				[
					this.eventManager.EVENT.COMPONENT_UPDATED,
					Defines.CAMERA_COMPONENT_ID
				],
				this.cameraChangeHandler
			)
			this.currentCameraId = undefined
		}

		var registerEntityHandler = function() {
			var me = this,
				eventManager = this.eventManager

			this.entityChangeHandler = _.bind(
				function( entityId, entityComponents ) {
					updateEntity.call( me, entityId )
				},
				this
			)

			_.each(
				[ eventManager.EVENT.ENTITY_CREATED, eventManager.EVENT.ENTITY_REMOVED ],
				function( event ) {
					eventManager.subscribe( event, me.entityChangeHandler )
				}
			)
		}

		var unregisterEntityHandler = function() {
			var me = this,
				eventManager = this.eventManager

			_.each(
				[ eventManager.EVENT.ENTITY_CREATED, eventManager.EVENT.ENTITY_REMOVED ],
				function( event ) {
					eventManager.unsubscribe( event, me.entityChangeHandler )
				}
			)

			me.entityChangeHandler = undefined
		}

		var registerComponentHandler = function() {
			var me = this,
				eventManager = this.eventManager

			this.componentChangeHandler = _.bind(
				function( object, entityId ) {

					if( !_.isObject( object ) ) { //removal of the component
						entityId = object
					}

					updateEntity.call( me, entityId )
				},
				this
			)

			_.each(
				[
					[ eventManager.EVENT.COMPONENT_CREATED, Defines.VISUAL_OBJECT_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_UPDATED, Defines.VISUAL_OBJECT_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_REMOVED, Defines.VISUAL_OBJECT_COMPONENT_ID ],

					[ eventManager.EVENT.COMPONENT_CREATED, Defines.TRANSFORM_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_UPDATED, Defines.TRANSFORM_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_REMOVED, Defines.TRANSFORM_COMPONENT_ID ]
				],
				function( event ) {
					eventManager.subscribe( event, me.componentChangeHandler )
				}
			)
		}

		var unregisterComponentHandler = function() {
			var me = this,
				eventManager = this.eventManager

			_.each(
				[
					[ eventManager.EVENT.COMPONENT_CREATED, Defines.VISUAL_OBJECT_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_UPDATED, Defines.VISUAL_OBJECT_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_REMOVED, Defines.VISUAL_OBJECT_COMPONENT_ID ],

					[ eventManager.EVENT.COMPONENT_CREATED, Defines.TRANSFORM_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_UPDATED, Defines.TRANSFORM_COMPONENT_ID ],
					[ eventManager.EVENT.COMPONENT_REMOVED, Defines.TRANSFORM_COMPONENT_ID ]
				],
				function( event ) {
					eventManager.unsubscribe( event, me.componentChangeHandler )
				}
			)

			me.componentChangeHandler = undefined
		}

		var init = function() {
			registerScreenSizeHandler.call( this )
			registerCameraChangeHandler.call( this )
			registerEntityHandler.call( this )
			registerComponentHandler.call( this )

			this.boxtree = new BoxTree.create( false )
		}

		var destroy = function( spell ) {
			unregisterScreenSizeHandler.call( this )
			unregisterCameraChangeHandler.call( this )
			unregisterEntityHandler.call( this )
			unregisterComponentHandler.call( this )
		}

		var layerCompareFunction = function( a, b ) {
			if ( a.layer == b.layer ) {
				return 0

			} else {
				return ( a.layer < b.layer ) ? -1 : 1

			}
		}

		var updateVisibility = function( spell ) {
			var currentCameraId = this.currentCameraId,
				camera          = this.entityManager.getComponentById( currentCameraId, Defines.CAMERA_COMPONENT_ID),
				transform       = this.entityManager.getComponentById( currentCameraId, Defines.TRANSFORM_COMPONENT_ID )

			if( !camera || !transform ) {
				return
			}

			var screenSize                = this.screenSize,
				aspectRatio               = screenSize[ 0 ] / screenSize[ 1 ],
				effectiveCameraDimensions = createEffectiveCameraDimensions( camera.width, camera.height, transform.scale, aspectRatio),
				position                  = transform.translation

			//TODO: only if boxtree was updated
			this.boxtree.finalize()

			this.worldPassEntities = []
			this.worldPassEntitiesLength = this.boxtree.getOverlappingNodes(
				[
					position[ 0 ] - effectiveCameraDimensions[ 0 ] / 2,
					position[ 1 ] - effectiveCameraDimensions[ 1 ] / 2,
					position[ 0 ] + effectiveCameraDimensions[ 0 ] / 2,
					position[ 1 ] + effectiveCameraDimensions[ 1 ] / 2
				],
				this.worldPassEntities,
				0
			)

			this.worldPassEntities.sort( layerCompareFunction )

			this.uiPassEntities				= _.values( this.uiPassEntitiesMap )
			this.uiPassEntities.sort( layerCompareFunction )

			this.backgroundPassEntities	= _.values( this.backgroundPassEntitiesMap )
			this.backgroundPassEntities.sort( layerCompareFunction )
		}


		VisibilityManager.prototype = {
			init:               init,
			destroy:            destroy,
			updateVisibility:   updateVisibility,
			updateEntity:       updateEntity,
			getCurrentScreenSize : function() {
				return this.screenSize
			},
			transformScreenToUI : function( position ) {
				var screenSize                  = this.screenSize,
					currentCameraId             = this.currentCameraId,
					camera                      = this.entityManager.getComponentById( currentCameraId, Defines.CAMERA_COMPONENT_ID),
					transform                   = this.entityManager.getComponentById( currentCameraId, Defines.TRANSFORM_COMPONENT_ID),
					aspectRatio                 = screenSize[ 0 ] / screenSize[ 1 ],
					effectiveCameraDimensions   = createEffectiveCameraDimensions( camera.width, camera.height, transform.scale, aspectRatio)

					return [
					( position[ 0 ] / screenSize[ 0 ] - 0.5 ) * effectiveCameraDimensions[ 0 ],
					( position[ 1 ] / screenSize[ 1 ] - 0.5 ) * -effectiveCameraDimensions[ 1 ]
				]
			}
		}

		return VisibilityManager
	}
)


define(
	'spell/shared/util/platform/log',
	[
		'spell/shared/util/platform/private/log'
	],
	function(
		log
	) {
		'use strict'


		return log
	}
)

/**
 * The Console enables logging of messages. Messages logged to this console are shown in the SpellEd console.
 *
 * The following log levels are available: LOG_LEVEL_DEBUG (0), LOG_LEVEL_INFO (1), LOG_LEVEL_WARN (2), LOG_LEVEL_ERROR (3), LOG_LEVEL_SILENT (4). The
 * log level is used for filtering the logged messages. For example setting the log level to *LOG_LEVEL_WARN* (2) causes all messages with a lower level
 * to be discarded without being logged. The default log level is LOG_LEVEL_INFO (1). If you want to disable all logging set the log level to
 * *LOG_LEVEL_SILENT* (4).
 *
 * Example:
 *
 *     spell.console.debug( "collected gold : " + numGold )
 *
 * @class spell.console
 * @singleton
 */
define(
	'spell/Console',
	[
		'spell/shared/util/platform/log'
	],
	function(
		platformLog
	) {
		'use strict'


		var LOG_LEVEL_DEBUG  = 0,
			LOG_LEVEL_INFO   = 1,
			LOG_LEVEL_WARN   = 2,
			LOG_LEVEL_ERROR  = 3,
			LOG_LEVEL_SILENT = 4

		var logLevels = [
			'DEBUG',
			'INFO',
			'WARN',
			'ERROR',
			'SILENT'
		]

		var validate = function( logLevel ) {
			if( logLevel < 0 ||
				logLevel > 4 ) {

				throw 'Log level ' + logLevel + ' is not supported.'
			}
		}

		var createMessage = function( level, text ) {
			return logLevels[ level ] + ' - ' + text
		}


		var Console = function( level ) {
			validate( level )

			this.currentLogLevel     = level || LOG_LEVEL_INFO
			this.sendMessageToEditor = undefined
		}

		Console.prototype = {
			LOG_LEVEL_DEBUG : LOG_LEVEL_DEBUG,

			LOG_LEVEL_INFO : LOG_LEVEL_INFO,

			LOG_LEVEL_WARN : LOG_LEVEL_WARN,

			LOG_LEVEL_ERROR : LOG_LEVEL_ERROR,

			LOG_LEVEL_SILENT : LOG_LEVEL_SILENT,

			/**
			 * Sets the callback that establishes forwarding of log messages to the editor.
			 *
			 * @param {Function} fn
			 */
			setSendMessageToEditor : function( fn ) {
				this.sendMessageToEditor = fn
			},

			/**
			 * Sets the current log level.
			 *
			 * @param {Number} level
			 */
			setLogLevel : function( level ) {
				validate( level )

				this.currentLogLevel = level
			},

			/**
			 * Logs the supplied text with the supplied level.
			 *
			 * @param {Number} level
			 * @param {String} text
			 */
			log : function( level, text ) {
				if( arguments.length === 1 ) {
					text = level
					level = LOG_LEVEL_DEBUG
				}

				if( level < this.currentLogLevel ) return

				if( this.sendMessageToEditor ) {
					this.sendMessageToEditor(
						'spelled.debug.consoleMessage',
						{
							level : logLevels[ level ],
							text : text
						}
					)
				}

				platformLog( createMessage( level, text ) )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_DEBUG.
			 *
			 * @param {String} message
			 */
			debug : function( message ) {
				this.log( LOG_LEVEL_DEBUG, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_INFO.
			 *
			 * @param {String} message
			 */
			info : function( message ) {
				this.log( LOG_LEVEL_INFO, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_WARN.
			 *
			 * @param {String} message
			 */
			warn : function( message ) {
				this.log( LOG_LEVEL_WARN, message )
			},

			/**
			 * Logs the supplied message with log level LOG_LEVEL_ERROR.
			 *
			 * @param {String} message
			 */
			error : function( message ) {
				this.log( LOG_LEVEL_ERROR, message )
			}
		}

		return Console
	}
)

define(
	'spell/StatisticsManager',
	[
		'spell/data/Tree'
	],
	function(
		Tree
	) {
		'use strict'


		var NUM_VALUES   = 63,
			FLOAT_DIGITS = 1

		var addNode = Tree.addNode,
			getNode = Tree.getNode,
			eachNode = Tree.eachNode

		var createBuffer = function( bufferSize ) {
			var buffer = []

			while( bufferSize > 0 ) {
				buffer.push( 0 )
				bufferSize--
			}

			return buffer
		}

		/**
		 * Computes the "standard deviation of the sample".
		 * See http://en.wikipedia.org/wiki/Standard_deviation#Standard_deviation_of_the_sample
		 *
		 * @param expected
		 * @param values
		 */
		var createStandardDeviation = function( expected, values ) {
			var numValues = values.length,
				sum = 0

			for( var i = 0; i < numValues; i++ ) {
				sum += Math.pow( values[ i ] - expected, 2 )
			}

			return Math.sqrt( sum / numValues )
		}

		var createNode = function( id ) {
			return {
				children : [],
				id : id,
				metrics : [ 0, 0, 0, 0 ],
				values : createBuffer( NUM_VALUES )
			}
		}

		var updateNodeMetrics = function( node ) {
			var values = node.values,
				mean = 0,
				min = Number.MAX_VALUE,
				max = 0,
				sum = 0

			for( var i = 0, numValues = values.length; i < numValues; i++ ) {
				var value = values[ i ]

				if( value === 0 ) continue

				if( value < min ) min = value
				if( value > max ) max = value

				sum += value
			}

			if( sum !== 0 ) {
				mean = sum / NUM_VALUES

			} else {
				min = 0
			}

			var metrics = node.metrics

			metrics[ 0 ] = mean.toFixed( FLOAT_DIGITS )
			metrics[ 1 ] = min.toFixed( FLOAT_DIGITS )
			metrics[ 2 ] = max.toFixed( FLOAT_DIGITS )
			metrics[ 3 ] = createStandardDeviation( mean, values ).toFixed( 2 )
		}

		var incrementNode = function( node ) {
			var values = node.values

			values.shift()
			values.push( 0 )
		}

		var resetNode = function( node ) {
			var values = node.values

			for( var i = 0, n = values.length; i < n; i++ ) {
				values[ i ] = 0
			}
		}


		var StatisticsManager = function() {
			this.tree = null
			this.timestamps = createBuffer( NUM_VALUES )

			this.totalTickTimeInMs = 0
			this.numTicks = 0
		}

		StatisticsManager.prototype = {
			init : function() {
				this.tree = createNode( 'total' )

				addNode( this.tree, 'total', createNode( 'render' ) )
				addNode( this.tree, 'total', createNode( 'update' ) )
			},
			addNode : function( id, parentId ) {
				var success = addNode( this.tree, parentId, createNode( id ) )

				if( !success ) {
					throw 'Could not add node "' + id + '" to parent node "' + parentId + '".'
				}
			},
			/*
			 * call this method to signal the beginning of a new measurement period
			 */
			startTick : function( timestamp, elapsedTimeInMs ) {
				this.totalTickTimeInMs += elapsedTimeInMs
				this.numTicks++

				var timestamps = this.timestamps

				timestamps.shift()
				timestamps.push( timestamp )

				eachNode( this.tree, incrementNode )
			},
			updateNode : function( id, value ) {
				var node = getNode( this.tree, id )
				if( !node ) return

				node.values[ node.values.length - 1 ] += value
			},
			getMetrics : function( periodInMs ) {
				eachNode( this.tree, updateNodeMetrics )

				return this.tree
			},
			getAverageTickTime : function() {
				return Math.round( this.totalTickTimeInMs / this.numTicks )
			},
			reset : function() {
				this.totalTickTimeInMs = 0
				this.numTicks = 0

				eachNode( this.tree, resetNode )
			}
		}

		return StatisticsManager
	}
)

/**
 * @class spell.pluginManager
 * @singleton
 */
define(
	'spell/PluginManager',
	[
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		PlatformKit
	) {
		'use strict'


		var PluginManager = function() {
			this.plugins = PlatformKit.getPlugins()
		}

		PluginManager.prototype = {
			getById : function( pluginId ) {
				return this.plugins[ pluginId ]
			}
		}

		return PluginManager
	}
)

define(
	"spell/math/hash/SHA256",
	function() {
		/* A JavaScript implementation of the SHA family of hashes, as defined in FIPS
		 * PUB 180-2 as well as the corresponding HMAC implementation as defined in
		 * FIPS PUB 198a
		 *
		 * Version 1.31 Copyright Brian Turek 2008-2012
		 * Distributed under the BSD License
		 * See http://caligatio.github.com/jsSHA/ for more information
		 *
		 * Several functions taken from Paul Johnson
		 */

		var charSize = 8,
		b64pad = "=",
		hexCase = 0,

		str2binb = function (str)
		{
			var bin = [], mask = (1 << charSize) - 1,
					length = str.length * charSize, i;

			for (i = 0; i < length; i += charSize)
			{
				bin[i >> 5] |= (str.charCodeAt(i / charSize) & mask) <<
						(32 - charSize - (i % 32));
			}

			return bin;
		},

		hex2binb = function (str)
		{
			var bin = [], length = str.length, i, num;

			for (i = 0; i < length; i += 2)
			{
				num = parseInt(str.substr(i, 2), 16);
				if (!isNaN(num))
				{
					bin[i >> 3] |= num << (24 - (4 * (i % 8)));
				}
				else
				{
					return "INVALID HEX STRING";
				}
			}

			return bin;
		},

		binb2hex = function (binarray)
		{
			var hex_tab = (hexCase) ? "0123456789ABCDEF" : "0123456789abcdef",
					str = "", length = binarray.length * 4, i, srcByte;

			for (i = 0; i < length; i += 1)
			{
				srcByte = binarray[i >> 2] >> ((3 - (i % 4)) * 8);
				str += hex_tab.charAt((srcByte >> 4) & 0xF) +
						hex_tab.charAt(srcByte & 0xF);
			}

			return str;
		},

		binb2b64 = function (binarray)
		{
			var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz" +
							"0123456789+/", str = "", length = binarray.length * 4, i, j,
					triplet;

			for (i = 0; i < length; i += 3)
			{
				triplet = (((binarray[i >> 2] >> 8 * (3 - i % 4)) & 0xFF) << 16) |
						(((binarray[i + 1 >> 2] >> 8 * (3 - (i + 1) % 4)) & 0xFF) << 8) |
						((binarray[i + 2 >> 2] >> 8 * (3 - (i + 2) % 4)) & 0xFF);
				for (j = 0; j < 4; j += 1)
				{
					if (i * 8 + j * 6 <= binarray.length * 32)
					{
						str += tab.charAt((triplet >> 6 * (3 - j)) & 0x3F);
					}
					else
					{
						str += b64pad;
					}
				}
			}
			return str;
		},

		rotr = function (x, n)
		{
			return (x >>> n) | (x << (32 - n));
		},

		shr = function (x, n)
		{
			return x >>> n;
		},

		ch = function (x, y, z)
		{
			return (x & y) ^ (~x & z);
		},

		maj = function (x, y, z)
		{
			return (x & y) ^ (x & z) ^ (y & z);
		},

		sigma0 = function (x)
		{
			return rotr(x, 2) ^ rotr(x, 13) ^ rotr(x, 22);
		},

		sigma1 = function (x)
		{
			return rotr(x, 6) ^ rotr(x, 11) ^ rotr(x, 25);
		},

		gamma0 = function (x)
		{
			return rotr(x, 7) ^ rotr(x, 18) ^ shr(x, 3);
		},

		gamma1 = function (x)
		{
			return rotr(x, 17) ^ rotr(x, 19) ^ shr(x, 10);
		},

		safeAdd_2 = function (x, y)
		{
			var lsw = (x & 0xFFFF) + (y & 0xFFFF),
					msw = (x >>> 16) + (y >>> 16) + (lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		safeAdd_4 = function (a, b, c, d)
		{
			var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF),
					msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
							(lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		safeAdd_5 = function (a, b, c, d, e)
		{
			var lsw = (a & 0xFFFF) + (b & 0xFFFF) + (c & 0xFFFF) + (d & 0xFFFF) +
							(e & 0xFFFF),
					msw = (a >>> 16) + (b >>> 16) + (c >>> 16) + (d >>> 16) +
							(e >>> 16) + (lsw >>> 16);

			return ((msw & 0xFFFF) << 16) | (lsw & 0xFFFF);
		},

		coreSHA2 = function (message, messageLen, variant)
		{
			var a, b, c, d, e, f, g, h, T1, T2, H, lengthPosition, i, t, K, W = [],
					appendedMessageLength;

			if (variant === "SHA-224" || variant === "SHA-256")
			{
				lengthPosition = (((messageLen + 65) >> 9) << 4) + 15;
				K = [
					0x428A2F98, 0x71374491, 0xB5C0FBCF, 0xE9B5DBA5,
					0x3956C25B, 0x59F111F1, 0x923F82A4, 0xAB1C5ED5,
					0xD807AA98, 0x12835B01, 0x243185BE, 0x550C7DC3,
					0x72BE5D74, 0x80DEB1FE, 0x9BDC06A7, 0xC19BF174,
					0xE49B69C1, 0xEFBE4786, 0x0FC19DC6, 0x240CA1CC,
					0x2DE92C6F, 0x4A7484AA, 0x5CB0A9DC, 0x76F988DA,
					0x983E5152, 0xA831C66D, 0xB00327C8, 0xBF597FC7,
					0xC6E00BF3, 0xD5A79147, 0x06CA6351, 0x14292967,
					0x27B70A85, 0x2E1B2138, 0x4D2C6DFC, 0x53380D13,
					0x650A7354, 0x766A0ABB, 0x81C2C92E, 0x92722C85,
					0xA2BFE8A1, 0xA81A664B, 0xC24B8B70, 0xC76C51A3,
					0xD192E819, 0xD6990624, 0xF40E3585, 0x106AA070,
					0x19A4C116, 0x1E376C08, 0x2748774C, 0x34B0BCB5,
					0x391C0CB3, 0x4ED8AA4A, 0x5B9CCA4F, 0x682E6FF3,
					0x748F82EE, 0x78A5636F, 0x84C87814, 0x8CC70208,
					0x90BEFFFA, 0xA4506CEB, 0xBEF9A3F7, 0xC67178F2
				];

				if (variant === "SHA-224")
				{
					H = [
						0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
						0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4
					];
				}
				else
				{
					H = [
						0x6A09E667, 0xBB67AE85, 0x3C6EF372, 0xA54FF53A,
						0x510E527F, 0x9B05688C, 0x1F83D9AB, 0x5BE0CD19
					];
				}
			}

			message[messageLen >> 5] |= 0x80 << (24 - messageLen % 32);
			message[lengthPosition] = messageLen;

			appendedMessageLength = message.length;

			for (i = 0; i < appendedMessageLength; i += 16)
			{
				a = H[0];
				b = H[1];
				c = H[2];
				d = H[3];
				e = H[4];
				f = H[5];
				g = H[6];
				h = H[7];

				for (t = 0; t < 64; t += 1)
				{
					if (t < 16)
					{
						W[t] = message[t + i];
					}
					else
					{
						W[t] = safeAdd_4(
								gamma1(W[t - 2]), W[t - 7],
								gamma0(W[t - 15]), W[t - 16]
						);
					}

					T1 = safeAdd_5(h, sigma1(e), ch(e, f, g), K[t], W[t]);
					T2 = safeAdd_2(sigma0(a), maj(a, b, c));
					h = g;
					g = f;
					f = e;
					e = safeAdd_2(d, T1);
					d = c;
					c = b;
					b = a;
					a = safeAdd_2(T1, T2);
				}

				H[0] = safeAdd_2(a, H[0]);
				H[1] = safeAdd_2(b, H[1]);
				H[2] = safeAdd_2(c, H[2]);
				H[3] = safeAdd_2(d, H[3]);
				H[4] = safeAdd_2(e, H[4]);
				H[5] = safeAdd_2(f, H[5]);
				H[6] = safeAdd_2(g, H[6]);
				H[7] = safeAdd_2(h, H[7]);
			}

			switch (variant)
			{
				case "SHA-224":
					return [
						H[0], H[1], H[2], H[3],
						H[4], H[5], H[6]
					];
				case "SHA-256":
					return H;
				default:
					return [];
			}
		},

		jsSHA = function (srcString, inputFormat)
		{

			this.sha224 = null;
			this.sha256 = null;

			this.strBinLen = null;
			this.strToHash = null;

			if ("HEX" === inputFormat)
			{
				if (0 !== (srcString.length % 2))
				{
					return "TEXT MUST BE IN BYTE INCREMENTS";
				}
				this.strBinLen = srcString.length * 4;
				this.strToHash = hex2binb(srcString);
			}
			else if (("ASCII" === inputFormat) ||
					('undefined' === typeof(inputFormat)))
			{
				this.strBinLen = srcString.length * charSize;
				this.strToHash = str2binb(srcString);
			}
			else
			{
				return "UNKNOWN TEXT INPUT TYPE";
			}
		};

		jsSHA.prototype = {
			getHash : function (variant, format)
			{
				var formatFunc = null, message = this.strToHash.slice();

				switch (format)
				{
					case "HEX":
						formatFunc = binb2hex;
						break;
					case "B64":
						formatFunc = binb2b64;
						break;
					default:
						return "FORMAT NOT RECOGNIZED";
				}

				switch (variant)
				{
					case "SHA-224":
						if (null === this.sha224)
						{
							this.sha224 = coreSHA2(message, this.strBinLen, variant);
						}
						return formatFunc(this.sha224);
					case "SHA-256":
						if (null === this.sha256)
						{
							this.sha256 = coreSHA2(message, this.strBinLen, variant);
						}
						return formatFunc(this.sha256);
					default:
						return "HASH NOT RECOGNIZED";
				}
			},

			getHMAC : function (key, inputFormat, variant, outputFormat)
			{
				var formatFunc, keyToUse, i, retVal, keyBinLen, hashBitSize,
						keyWithIPad = [], keyWithOPad = [];

				switch (outputFormat)
				{
					case "HEX":
						formatFunc = binb2hex;
						break;
					case "B64":
						formatFunc = binb2b64;
						break;
					default:
						return "FORMAT NOT RECOGNIZED";
				}

				switch (variant)
				{
					case "SHA-224":
						hashBitSize = 224;
						break;
					case "SHA-256":
						hashBitSize = 256;
						break;
					default:
						return "HASH NOT RECOGNIZED";
				}

				if ("HEX" === inputFormat)
				{
					if (0 !== (key.length % 2))
					{
						return "KEY MUST BE IN BYTE INCREMENTS";
					}
					keyToUse = hex2binb(key);
					keyBinLen = key.length * 4;
				}
				else if ("ASCII" === inputFormat)
				{
					keyToUse = str2binb(key);
					keyBinLen = key.length * charSize;
				}
				else
				{
					return "UNKNOWN KEY INPUT TYPE";
				}

				if (64 < (keyBinLen / 8))
				{
					keyToUse = coreSHA2(keyToUse, keyBinLen, variant);
					keyToUse[15] &= 0xFFFFFF00;
				}
				else if (64 > (keyBinLen / 8))
				{
					keyToUse[15] &= 0xFFFFFF00;
				}

				for (i = 0; i <= 15; i += 1)
				{
					keyWithIPad[i] = keyToUse[i] ^ 0x36363636;
					keyWithOPad[i] = keyToUse[i] ^ 0x5C5C5C5C;
				}

				retVal = coreSHA2(
						keyWithIPad.concat(this.strToHash),
						512 + this.strBinLen, variant);
				retVal = coreSHA2(
						keyWithOPad.concat(retVal),
						512 + hashBitSize, variant);

				return (formatFunc(retVal));
			}
		};

		return jsSHA
	}
)



define(
	'spell/shared/util/hashModuleId',
	[
		'spell/math/hash/SHA256'
	],
	function(
		SHA256
	) {
		'use strict'


		return function( text ) {
			var shaObj = new SHA256( text, 'ASCII' )

			return shaObj.getHash( 'SHA-256', 'B64' )
		}
	}
)

define(
	'spell/shared/util/createModuleLoader',
	[
		'spell/shared/util/hashModuleId',
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		hashModuleId,
		PlatformKit
	) {
		'use strict'


		var instance

		return function( libraryManager, isModeDevelopment, libraryUrl ) {
			if( !instance ) {
				instance = {
					require : function( moduleId ) {
						var config = {
							libraryManager : isModeDevelopment ? libraryManager : undefined,
							hashModuleId   : hashModuleId,
							loadingAllowed : isModeDevelopment,
							libraryUrl     : libraryUrl
						}

						return PlatformKit.ModuleLoader.require( moduleId, null, config )
					}
				}
			}

			return instance
		}
	}
)

define(
	'spell/shared/util/createUrlWithCacheBreaker',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		return function( url ) {
			return url + '?t=' + Types.Time.getCurrentInMs()
		}
	}
)

define(
	'spell/shared/util/createIdFromLibraryFilePath',
	function() {
		'use strict'


		return function( libraryFilePath, asArray ) {
			// strip the file extension
			var tmp = libraryFilePath.substr( 0, libraryFilePath.lastIndexOf( '.' ) )

			return asArray ?
				tmp.split( '/' ) :
				tmp.replace( /\//g, '.' )
		}
	}
)

define(
	'spell/LibraryManager',
	[
		'spell/client/loading/addNamespaceAndName',
		'spell/shared/util/createIdFromLibraryFilePath',
		'spell/shared/util/createLibraryFilePath',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createUrlWithCacheBreaker',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		addNamespaceAndName,
		createIdFromLibraryFilePath,
		createLibraryFilePath,
		createLibraryFilePathFromId,
		createUrlWithCacheBreaker,
		PlatformKit,

		_
	) {
		'use strict'


		var nextLoadingProcessId = 0

		var createLoadingProcessId = function() {
			return nextLoadingProcessId++
		}

		var resourceJsonDecoder = function( resource ) {
			return PlatformKit.jsonCoder.decode( resource )
		}

		var createResourceTypeToLoaderFactory = function( renderingContext, soundContext ) {
			var createTexture = _.bind( PlatformKit.createImageLoader, null, renderingContext ),
				createSound   = _.bind( PlatformKit.createSoundLoader, null, soundContext ),
				createText    = _.bind( PlatformKit.createTextLoader, null, resourceJsonDecoder )

			return {
				jpeg : createTexture,
				png  : createTexture,
				mp3  : createSound,
				wav  : createSound,
				ogg  : createSound,
				json : createText
			}
		}

		var getLoaderFactory = function( resourceTypeToLoaderFactory, type, libraryFilePath ) {
			var actualType = 'auto' ?
				_.last( libraryFilePath.split( '.' ) ) :
				type

			return resourceTypeToLoaderFactory[ actualType ]
		}

		var createLoadingProcess = function( id, libraryIdsToLibraryFilePaths, libraryUrl, invalidateCache, config, next ) {
			return {
				assetManager       : config.assetManager,
				id                 : id,
				libraryFilePaths   : libraryIdsToLibraryFilePaths,
				invalidateCache    : invalidateCache,
				numCompleted       : 0,
				name               : config.name,
				next               : next,
				type               : config.type ? config.type : 'auto',
				libraryUrl         : libraryUrl,
				omitCache          : !!config.omitCache,
				onLoadingCompleted : config.onLoadingCompleted,
				isMetaDataLoad     : config.isMetaDataLoad !== undefined ? config.isMetaDataLoad : true
			}
		}

		var updateProgress = function( eventManager, cache, loadingProcesses, loadingProcess ) {
			loadingProcess.numCompleted++

			var libraryFilePaths = loadingProcess.libraryFilePaths,
				numLibraryPaths  = _.size( libraryFilePaths ),
				progress         = loadingProcess.numCompleted / numLibraryPaths,
				name             = loadingProcess.name

			eventManager.publish(
				[ eventManager.EVENT.RESOURCE_PROGRESS, name ],
				[ progress, loadingProcess.numCompleted, numLibraryPaths ]
			)

			if( loadingProcess.numCompleted === numLibraryPaths ) {
				var loadedLibraryRecords = _.pick( cache, _.keys( libraryFilePaths ) )

				if( loadingProcess.isMetaDataLoad ) {
					addNamespaceAndName( loadedLibraryRecords )
				}

				if( loadingProcess.onLoadingCompleted ) {
					loadingProcess.onLoadingCompleted( loadedLibraryRecords )
				}

				delete loadingProcesses[ loadingProcess.id ]

				if( name ) {
					eventManager.publish(
						[ eventManager.EVENT.RESOURCE_LOADING_COMPLETED, name ],
						[ loadedLibraryRecords ]
					)
				}

				if( loadingProcess.next ) {
					loadingProcess.next()
				}
			}
		}

		var onLoadCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath, loadedResource ) {
			if( !loadedResource ) {
				throw 'Error: Loading library file "' + libraryFilePath + '" from loading process "' + loadingProcess.id + '" returned a false value.'
			}

			cache[ libraryId ] = loadedResource

			updateProgress( eventManager, cache, loadingProcesses, loadingProcess )
		}

		var onErrorCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ) {
			throw 'Error: Loading library file "' + libraryFilePath + '" failed.'
		}

		var onTimedOutCallback = function( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ) {
			throw 'Error: Loading library file "' + libraryFilePath + '" timed out.'
		}

		var startLoadingProcess = function( cache, eventManager, resourceTypeToLoaderFactory, loadingProcesses, loadingProcess ) {
			var omitCache        = loadingProcess.omitCache,
				libraryFilePaths = loadingProcess.libraryFilePaths

			for( var libraryId in libraryFilePaths ) {
				var libraryFilePath = libraryFilePaths[ libraryId ]

				if( !omitCache ) {
					var cachedEntry = cache[ libraryId ]

					if( cachedEntry ) {
						onLoadCallback( eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath, cachedEntry )

						continue
					}
				}

				var loaderFactory = getLoaderFactory( resourceTypeToLoaderFactory, loadingProcess.type, libraryFilePath )

				if( !loaderFactory ) {
					throw 'Error: Unable to load resource of type "' + loadingProcess.type + '".'
				}

				var url = loadingProcess.libraryUrl ?
					loadingProcess.libraryUrl + '/' + libraryFilePath :
					libraryFilePath

				var loader = loaderFactory(
					loadingProcess.assetManager,
					libraryId,
					loadingProcess.invalidateCache ? createUrlWithCacheBreaker( url ) : url,
					_.bind( onLoadCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ),
					_.bind( onErrorCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath ),
					_.bind( onTimedOutCallback, null, eventManager, cache, loadingProcesses, loadingProcess, libraryId, libraryFilePath )
				)

				if( !loader ) {
					throw 'Could not create a loader for resource "' + libraryFilePath + '".'
				}

				loader.start()
			}
		}


		var LibraryManager = function( eventManager, libraryUrl, isModeDeployed ) {
			this.eventManager                = eventManager
			this.loadingProcesses            = {}
			this.libraryUrl                  = libraryUrl
			this.invalidateCache             = !isModeDeployed
			this.resourceTypeToLoaderFactory

			this.cache = {
				metaData : {},
				resource : {}
			}
		}

		LibraryManager.prototype = {
			get : function( libraryId ) {
				var cache = this.cache

				return cache.metaData[ libraryId ] || cache.resource[ libraryId ]
			},

			getMetaData : function( libraryId ) {
				return this.cache.metaData[ libraryId ]
			},

			getResource : function( libraryId ) {
				return this.cache.resource[ libraryId ]
			},

			getMetaDataRecordsByType : function( type ) {
				return _.reduce(
					this.cache.metaData,
					function( memo, metaDataRecord, libraryId ) {
						if( metaDataRecord.type === type ) {
							memo[ libraryId ] = metaDataRecord
						}

						return memo
					},
					{}
				)
			},

			addToCache : function( content ) {
				var tmp = _.reduce(
					content,
					function( memo, key, value ) {
						var extension = value.substr( value.lastIndexOf( '.' ) + 1, value.length ),
							isScript  = extension === 'js'

						memo[ isScript ? value : createIdFromLibraryFilePath( value ) ] = key

						return memo
					},
					{}
				)

				_.extend( this.cache.metaData, tmp )
				addNamespaceAndName( this.cache.metaData )
			},

			isAvailable : function( libraryIds ) {
				var cache = this.cache

				for( var i = 0, entry, libraryId, n = libraryIds.length; i < n; i++ ) {
					libraryId = libraryIds[ i ]
					entry = cache.metaData[ libraryId ]

					if( !entry ||
						( entry.file && !cache.resource[ libraryId ] ) ) {

						return false
					}
				}

				return true
			},

			free : function() {
				this.cache.resource = {}
			},

			load : function( libraryIdsToLibraryFilePaths, config, next ) {
				if( !this.resourceTypeToLoaderFactory ) {
					throw 'Error: Library manager is not properly initialized.'
				}

				if( _.size( libraryIdsToLibraryFilePaths ) === 0 ) {
					throw 'Error: No library file paths provided.'
				}

				var id = createLoadingProcessId()

				var loadingProcess = createLoadingProcess(
					id,
					libraryIdsToLibraryFilePaths,
					this.libraryUrl,
					this.invalidateCache,
					config || {},
					next
				)

				this.loadingProcesses[ id ] = loadingProcess

				startLoadingProcess(
					loadingProcess.isMetaDataLoad ? this.cache.metaData : this.cache.resource,
					this.eventManager,
					this.resourceTypeToLoaderFactory,
					this.loadingProcesses,
					loadingProcess
				)

				return id
			},

			init : function( audioContext, renderingContext ) {
				this.resourceTypeToLoaderFactory = createResourceTypeToLoaderFactory( renderingContext, audioContext )
			}
		}

		return LibraryManager
	}
)

/**
 * The InputManager provides handling of user input.
 *
 * @class spell.inputManager
 * @singleton
 */
define(
	'spell/InputManager',
	[
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/input/keyCodes',

		'spell/functions'
	],
	function(
		PlatformKit,
		keyCodes,

		_
	) {
		'use strict'


		var Command = function( id, isStart ) {
			this.id = id
			this.isStart = isStart
		}

		Command.prototype = {
			getEventName : function() {
				return this.getType() + this.id
			},
			getType : function() {
				return this.isStart ? 'start' : 'stop'
			}
		}

		var inputEvents               = [],
			commands                  = [],
			isKeyCodePressed          = {},
			inputEventTypeToListeners = {},
			inputContexts             = {}

		var processEvent = function( event ) {
			var type      = event.type,
				isKeyDown = type === 'keyDown',
				isKeyUp   = type === 'keyUp',
				isClick   = type === 'click'

			if( !isClick ) {
				//the click event can be only processed via addListener
				inputEvents.push( event )
			}

			if( isKeyDown || isKeyUp ) {
				var keyCode = event.keyCode,
					repeat  = isKeyCodePressed[ keyCode ] === isKeyDown

				if( repeat ) return

				isKeyCodePressed[ keyCode ] = isKeyDown

				// create command if it is mapped by an input context
				var command = createCommand( inputContexts, keyCode, isKeyDown )

				if( command ) {
					commands.push( command )
				}
			}

			// process registered input event listeners
			var registeredListeners = inputEventTypeToListeners[ type ]

			if( registeredListeners ) {
				for( var i = 0, n = registeredListeners.length; i < n; i++ ) {
					registeredListeners[ i ].call( null, event )
				}
			}
		}

		var createCommand = function( inputContexts, keyCode, isStart ) {
			for( var id in inputContexts ) {
				var inputContext = inputContexts[ id ]

				for( var mappedKeyCode in inputContext ) {
					if( mappedKeyCode == keyCode ) {
						var command = inputContext[ mappedKeyCode ]

						return new Command(
							command.substr( 0, 1 ).toUpperCase() + command.substr( 1, command.length ),
							isStart
						)
					}
				}
			}
		}

		var createKeyEvent = function( type, keyCode ) {
			return {
				type : type,
				keyCode : keyCode
			}
		}


		var InputManager = function( configurationManager, renderingContext ) {
			this.nativeInput = PlatformKit.createInput( configurationManager, renderingContext )
		}

		InputManager.prototype = {
			/**
			 * Initialize the InputManager and register all input binding.
			 * This function is being called by spellCore, don't call it yourself!
			 *
			 * @private
			 */
			init : function() {
				this.nativeInput.setInputEventListener( processEvent )
			},

			/**
			 * Destroys the InputManager and unregister all input bindings.
			 * This function is being called by spellCore, don't call it yourself!
			 *
			 * @private
			 */
			destroy : function() {
				this.nativeInput.removeInputEventListener()
			},

			/**
			 * Get the InputEvents queue
			 *
			 * @return {Array}
			 */
			getInputEvents : function() {
				return inputEvents
			},

			/**
			 * Clear the current input event queue.
			 */
			clearInputEvents : function() {
				inputEvents.length = 0
			},

			/**
			 * Returns true if the key with the given key code is currently pressed, false otherwise.
			 *
			 * Example:
			 *
			 *     var inputManager = spell.inputManager
			 *
			 *     if( inputManager.isKeyPressed( inputManager.KEY.SPACE ) ) {
			 *         // do stuff
			 *     }
			 *
			 * @param {String} keyCode
			 * @return {Boolean}
			 */
			isKeyPressed : function( keyCode ) {
				return isKeyCodePressed[ keyCode ]
			},

			/**
			 * Injects a key event into the input manager processing pipeline.
			 *
			 * @param {String} type the key event type (keyDown, keyUp)
			 * @param {String} keyCode the key code
			 */
			injectKeyEvent : function( type, keyCode ) {
				processEvent( createKeyEvent( type, keyCode ) )
			},

			/**
			 * Adds a listener for events of the type specified by eventType.
			 *
			 * Example:
			 *
			 *     var processSpaceDown = function( event ) {
			 *         if( event.keyCode === spell.inputManager.KEY.SPACE ) {
			 *             // do something clever
			 *         }
			 *     }
			 *
			 *     spell.inputManager.addListener( 'keyDown', processSpaceDown )
			 *
			 * @param {String} eventType can be any of the following values: keyDown, keyUp, pointerDown, pointerMove, pointerUp, pointerCancel
			 * @param {Function} listener
			 */
			addListener : function( eventType, listener ) {
				var registeredListeners = inputEventTypeToListeners[ eventType ] || ( inputEventTypeToListeners[ eventType ] = [] )

				registeredListeners.push( listener )
			},

			/**
			 * Removes a listener for events of the type specified by eventType
			 *
			 * Example:
			 *
			 *     var processSpaceDown = function( event ) {
			 *         if( event.keyCode === spell.inputManager.KEY.SPACE ) {
			 *             // do something clever
			 *         }
			 *     }
			 *
			 *     spell.inputManager.removeListener( 'keyDown', processSpaceDown )
			 *
			 * @param {String} eventType can be any of the following values: keyDown, keyUp, pointerDown, pointerMove, pointerUp, pointerCancel
			 * @param {Function} listener
			 */
			removeListener : function( eventType, listener ) {
				var registeredListeners = inputEventTypeToListeners[ eventType ]

				if( !registeredListeners ) return

				inputEventTypeToListeners[ eventType ] = _.filter(
					registeredListeners,
					function( registeredListener ) {
						return registeredListener !== listener
					}
				)
			},

			/**
			 * Adds an input context.
			 *
			 * Example:
			 *
			 *     spell.inputManager.addInputContext(
			 *         'myInputContext',
			 *         spell.assetManager.get( 'myGame.myInputMapAsset' )
			 *     )
			 *
			 * @param {String} id a unique string that identifies the input context
			 * @param {Object} inputMap the inputMap asset maps input to commands
			 */
			addInputContext : function( id, inputMap ) {
				inputContexts[ id ] = inputMap
			},

			/**
			 * Removes an input context.
			 *
			 * Example:
			 *
			 *     spell.inputManager.removeInputContext( 'myInputContext' )
			 *
			 * @param {String} id a unique string that identifies the input context
			 */
			removeInputContext : function( id ) {
				delete inputContexts[ id ]
			},

			/**
			 * Returns the list of queued commands.
			 *
			 * @return {Array}
			 */
			getCommands : function() {
				return commands
			},

			/**
			 * Clears the list of queued commands.
			 */
			clearCommands : function() {
				commands.length = 0
			},

			/**
			 * Map of supported keys.
			 */
			KEY : keyCodes
		}

		return InputManager
	}
)

define(
	'spell/data/forestMultiMap',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		function createNode() {
			return {
				subNodes: {},
				elements: []
			}
		}

		function getElements( node ) {
			if( !node ) {
				return []

			} else {
				return _.reduce(
					node.subNodes,
					function( elements, subNode ) {
						return elements.concat( getElements( subNode ) )
					},
					node.elements
				)
			}
		}

		function getNode( node, key, eachNode ) {
			return _.reduce(
				key,
				function( node, keyComponent ) {
					if( node === undefined ) return undefined

					if( eachNode !== undefined ) eachNode( node, keyComponent )

					return node.subNodes[ keyComponent ]
				},
				node
			)
		}


		return {
			create: function() {
				return createNode()
			},

			add: function(
				data,
				key,
				element
			) {
				var node = getNode(
					data,
					key,
					function( node, keyComponent ) {
						if ( !node.subNodes.hasOwnProperty( keyComponent ) ) {
							node.subNodes[ keyComponent ] = createNode()
						}
					}
				)

				node.elements.push( element )
			},

			remove: function(
				data,
				key,
				elementToRemove
			) {
				var node = getNode( data, key )

				if( elementToRemove === undefined ) {
					node.elements.length = 0

				} else {
					node.elements = _.filter( node.elements, function( element ) {
						return element !== elementToRemove
					} )
				}
			},

			get: function(
				data,
				key
			) {
				return getElements( getNode( data, key ) )
			}
		}
	}
)

/**
 * The EventManager offers access to the engine internal message bus. It can be used to implement observer behavior.
 *
 * @class spell.eventManager
 * @singleton
 */
define(
	'spell/EventManager',
	[
		'spell/data/forestMultiMap',

		'spell/functions'
	],
	function(
		forestMultiMap,

		_
	) {
		'use strict'


		var wrapArray = function( x ) {
			return _.isArray( x ) ? x : [ x ]
		}

		var waitForChainConfig = false

		var registerWaitForChain = function( eventManager, config ) {
			var callback = config.callback

			// the lock is released after the n-th call ( n := config.events.length )
			var lock = _.after(
				config.events.length,
				function() {
					callback()
				}
			)

			// wire up all events to probe the lock
			_.each(
				config.events,
				function( event ) {
					var handler = function( eventArgs ) {
						if( event.subscriber ) event.subscriber( eventArgs )

						eventManager.unsubscribe( event.scope, handler )

						lock()
					}

					eventManager.subscribe( event.scope, handler )
				}
			)
		}


		function EventManager() {
			this.subscribers = forestMultiMap.create()
		}

		EventManager.prototype = {
			/**
			 * Subscribes a subscriber to the specified event scope.
			 *
			 * Example:
			 *
			 *     var processTransformCreated = function( component, entityId ) {
			 *         ...
			 *     }
			 *
			 *     spell.eventManager.subscribe(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ],
			 *         processTransformCreated
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Function} subscriber the callback function
			 */
			subscribe : function( scope, subscriber ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.add(
					this.subscribers,
					wrappedScope,
					subscriber
				)

				this.publish( this.EVENT.SUBSCRIBE, [ wrappedScope, subscriber ] )
			},

			/**
			 * Unsubscribes a subscriber from the specified event scope.
			 *
			 * Example:
			 *
			 *     var processTransformCreated = function( component, entityId ) {
			 *         ...
			 *     }
			 *
			 *     spell.eventManager.unsubscribe(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ],
			 *         processTransformCreated
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Function} subscriber the callback function
			 */
			unsubscribe : function( scope, subscriber ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.remove( this.subscribers, wrappedScope, subscriber )

				this.publish( this.EVENT.UNSUBSCRIBE, [ wrappedScope, subscriber ] )
			},

			/**
			 * Unsubscribes all subscribers from the specified event scope.
			 *
			 * Example:
			 *
			 *     spell.eventManager.unsubscribeAll(
			 *         [ spell.eventManager.EVENT.COMPONENT_CREATED, 'spell.component.2d.transform' ]
			 *     )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 */
			unsubscribeAll : function( scope ) {
				var wrappedScope = wrapArray( scope )

				forestMultiMap.remove( this.subscribers, wrappedScope )

				this.publish( this.EVENT.UNSUBSCRIBE, [ wrappedScope ] )
			},

			/**
			 * Publishes the event to all subscribers which are subscribed to the specified event scope.
			 *
			 * Example:
			 *
			 *     spell.eventManager.publish( spell.eventManager.EVENT.SERVER_CONNECTION_ESTABLISHED, [ response.status ] )
			 *
			 * @param {String|String[]} scope can either be a string or an array of strings specifying the event scope
			 * @param {Array} eventArgs an array of event arguments
			 */
			publish : function( scope, eventArgs ) {
				var subscribersInScope = forestMultiMap.get( this.subscribers, wrapArray( scope ) ),
					wrappedEventArgs   = wrapArray( eventArgs )

				_.each( subscribersInScope, function( subscriber ) {
					subscriber.apply( undefined, wrappedEventArgs )
				} )

				return true
			},

			waitFor : function( scope, subscriber ) {
				waitForChainConfig = {
					events : [ {
						scope      : wrapArray( scope ),
						subscriber : subscriber
					} ]
				}

				return this
			},

			and : function( scope, subscriber ) {
				// check if pending chain call exists
				if( !waitForChainConfig ) throw 'A call to the method "and" must be chained to a previous call to "waitFor".'

				waitForChainConfig.events.push( {
					scope      : wrapArray( scope ),
					subscriber : subscriber
				} )

				return this
			},

			resume : function( callback ) {
				// check if pending chain call exists, return otherwise
				if( !waitForChainConfig ) throw 'A call to the method "resume" must be chained to a previous call to "waitFor" or "and".'

				waitForChainConfig.callback = callback

				registerWaitForChain( this, waitForChainConfig )

				waitForChainConfig = false
			},

			/**
			 * Map of supported events.
			 */
			EVENT : {
				SERVER_CONNECTION_ESTABLISHED : 0,
				MESSAGE_RECEIVED : 1,
				CLOCK_SYNC_ESTABLISHED : 2,
				COMPONENT_CREATED : 3,
				COMPONENT_REMOVED : 4,
				COMPONENT_UPDATED : 5,
				ENTITY_CREATED : 6,
				ENTITY_DESTROYED : 7, // skip sending all the component removal events and just destroy the entity
				ENTITY_REMOVED : 8, // perform an ordered removal of the entity, that is send component removal events
				ASSET_UPDATED : 9,
				SUBSCRIBE : 10,
				UNSUBSCRIBE : 11,
				RESOURCE_PROGRESS : 12,
				RESOURCE_LOADING_COMPLETED : 13,
				AVAILABLE_SCREEN_SIZE_CHANGED : 14,
				SCREEN_RESIZE : 15,
				DEVICE_ORIENTATION_CHANGED : 16,
				VISIBILITY_CHANGED : 17
			}
		}

		return EventManager
	}
)

/**
 * The ConfigurationManager offers access to various engine internal configuration options.
 *
 * Example:
 *     var screenSize = spell.configurationManager.getValue( 'currentScreenSize' )
 *
 *     spell.logger.debug( screenSize )
 *
 * @class spell.configurationManager
 * @singleton
 */
define(
	'spell/ConfigurationManager',
	[
		'spell/client/util/createIncludedRectangle',
		'spell/math/util',
		'spell/math/vec2',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		createIncludedRectangle,
		mathUtil,
		vec2,
		PlatformKit,

		_
	) {
		'use strict'


		var createScreenSize = function( availableScreenSize, aspectRatio ) {
			return aspectRatio ?
				createIncludedRectangle( availableScreenSize, aspectRatio, true ) :
				availableScreenSize
		}

		var extractDefault = function( validValues, value ) {
			return _.contains( validValues, value ) ? value : false
		}

		var extractVec2 =  function( validValues, v ) {
			var parts = _.isArray( v ) ?
				v :
				v.split( ',' )

			if( parts.length !== 2 ) {
				throw 'Could not create vec2 from string "' + v + '".'
			}

			var x = parseInt( parts[ 0 ], 10 ),
				y = parseInt( parts[ 1 ], 10 )

			if( _.isNaN( x ) || _.isNaN( y ) ) {
				throw 'Could not create vec2 from string "' + v + '".'
			}

			return [ x, y ]
		}

		// These are the platform agnostic options.
		//
		// The property "configurable" controls if the option can be overridden by the environment configuration set up by the stage-0-loader.
		var validOptions = _.extend(
			{
				// The screen mode which the user requested. Can be either "fit" or "fixed". If set to "fit" the maximum available screen area is used and the
				// option "screenSize" is ignored. If set to "fixed" the option "screenSize" is used to determine the used screen size. The default is "fit".
				screenMode : {
					validValues : [ 'fill', 'fit', 'fixed' ],
					configurable : true,
					extractor : extractDefault
				},
				// The screen size which the user requested.
				screenSize : {
					configurable : true,
					extractor : extractVec2
				},
				// The screen size which is currently used.
				currentScreenSize : {
					configurable : false
				},
				id : {
					configurable : true
				},
				mode : {
					validValues : [ 'deployed', 'development_embedded', 'development_standalone' ],
					configurable : true
				},
				projectId : {
					configurable : true
				},
				supportedLanguages : {
					configurable : true
				},
				defaultLanguage : {
					configurable : true
				},
				currentLanguage : {
					configurable : true
				},
				loadingScene : {
					configurable : true
				},
				quality : {
					configurable : true
				},
				qualityLevels : {
					configurable : true
				},
				currentQualityLevel : {
					configurable : true
				}
			},
			PlatformKit.configurationOptions.validOptions
		)

		// These options are used when they are not overridden by the environment configuration set up by the stage-0-loader.
		var defaultOptions = _.extend(
			{
				screenMode              : 'fixed',
				screenSize              : [ 300, 200 ],
				currentScreenSize       : [ 300, 200 ],
				quadTreeSize            : 1048576, // 2^20
				projectId               : '',
				id                      : 'spell', // dom node id
				'platform.id'           : PlatformKit.platformDetails.getPlatform(),
				'platform.hasPlentyRAM' : PlatformKit.platformDetails.hasPlentyRAM()
			},
			PlatformKit.configurationOptions.defaultOptions
		)

		var update = function( config, defaultOptions, validOptions, name, value ) {
			var option = validOptions[ name ]

			if( option ) {
				if( !option.configurable ) {
					return config
				}

				var result = option.extractor ?
					option.extractor( option.validValues, value ) :
					value

				config[ name ] = result === undefined ?
					( option.extractor ?
						option.extractor( option.validValues, defaultOptions[ name ] ) :
						result ) :
					result

			} else {
				config[ name ] = value
			}
		}


		var ConfigurationManager = function( eventManager ) {
			this.config       = defaultOptions
			this.eventManager = eventManager

			eventManager.subscribe(
				[ eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED ],
				_.bind(
					function( availableScreenSize ) {
						var config               = this.config,
							screenMode           = config.screenMode || 'fixed',
							aspectRatioOverwrite = config.screenAspectRatio > 0 ,
							screenSize           = config.screenSize

						if( aspectRatioOverwrite ) {
							config.currentScreenSize = createScreenSize( availableScreenSize, config.screenAspectRatio )

						} else if( screenMode === 'fit' ) {
							// set the screen size up to the limits provided by the "screenSize" configuration option
							var clampedAvailableScreenSize = [
								mathUtil.clamp( availableScreenSize[ 0 ], 1, screenSize[ 0 ] ),
								mathUtil.clamp( availableScreenSize[ 1 ], 1, screenSize[ 1 ] )
							]

							config.currentScreenSize = createScreenSize(
								clampedAvailableScreenSize,
								screenSize[ 0 ] / screenSize[ 1 ]
							)

						} else if( screenMode === 'fixed' ) {
							config.currentScreenSize = screenSize

						} else if( screenMode === 'fill' ) {
							config.currentScreenSize = [ availableScreenSize[ 0 ], availableScreenSize[ 1 ] ]

						} else {
							throw 'Error: Screen mode \'' + screenMode + '\' is not supported.'
						}

						eventManager.publish( eventManager.EVENT.SCREEN_RESIZE, [ config.currentScreenSize ] )
					},
					this
				)
			)
		}

		ConfigurationManager.prototype = {
			/**
			 * Sets the configuration option key to value.
			 *
			 * @private
			 * @param {String} key
			 * @param {String} value
			 */
			setValue : function( key, value ) {
				var config = this.config

				if( key === 'defaultLanguage' ) {
					config.currentLanguage = value

				} else if( key === 'currentLanguage' ) {
					if( _.contains( config.supportedLanguages, value ) ) {
						config.currentLanguage = value
					}

					return

				} else if( key === 'quality' &&
					config.qualityLevels ) {

					var qualityLevel = config.qualityLevels[ value ]

					if( qualityLevel ) {
						config.currentQualityLevel = qualityLevel
					}

					return
				}

				update( config, defaultOptions, validOptions, key, value )

				if( key === 'screenAspectRatio' ||
					key === 'screenMode' ) {

					this.eventManager.publish(
						this.eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED,
						[ PlatformKit.getAvailableScreenSize( this.getValue( 'id' ) ) ]
					)

				} else if( key === 'screenSize' ) {
					vec2.copy( config.currentScreenSize, config.screenSize )
				}
			},

			/**
			 * Returns the configuration option specified by key.
			 *
			 * @param {String} key
			 * @return {String}
			 */
			getValue : function( key ) {
				return this.config[ key ]
			},

			/**
			 * Sets mutliple configuration options at once.
			 *
			 * @private
			 * @param {Object} x the configuration
			 */
			setConfig : function( x ) {
				for( var key in x ) {
					if( key === 'supportedLanguages' ||
						key === 'defaultLanguage' ||
						key === 'currentLanguage' ||
						key === 'quality' ||
						key === 'qualityLevels' ||
						key === 'currentQualityLevel' ||
						key === 'screenSize' ||
						key === 'screenAspectRatio' ||
						key === 'screenMode' ) {

						continue
					}

					this.setValue( key, x[ key ] )
				}

				// HACK: these configuration options have dependencies amongst each other and must therefore be processed in the right order
				if( x.supportedLanguages ) this.setValue( 'supportedLanguages', x.supportedLanguages )
				if( x.defaultLanguage ) this.setValue( 'defaultLanguage', x.defaultLanguage )
				if( x.currentLanguage ) this.setValue( 'currentLanguage', x.currentLanguage )

				if( x.qualityLevels ) this.setValue( 'qualityLevels', x.qualityLevels )
				if( x.quality ) this.setValue( 'quality', x.quality )

				if( x.screenSize ) this.setValue( 'screenSize', x.screenSize )
				if( x.screenAspectRatio ) this.setValue( 'screenAspectRatio', x.screenAspectRatio )
				if( x.screenMode ) this.setValue( 'screenMode', x.screenMode )

				if( !this.config.currentQualityLevel ) {
					this.setValue( 'currentQualityLevel', 1 )
				}
			}
		}

		return ConfigurationManager
	}
)

/**
 * The AssetManager provides access to asset instances.
 *
 * Example:
 *
 *     spell.audioContext.play(
 *         spell.assetManager.get( 'sound:myGame.creakyNoise' ).resource,
 *         'creakyNoise',
 *         0.7,
 *         false
 *     )
 *
 * @class spell.assetManager
 * @singleton
 */
define(
	'spell/AssetManager',
	function() {
		'use strict'


		var AssetManager = function( libraryManager ) {
			this.assets         = {},
			this.libraryManager = libraryManager
		}

		AssetManager.prototype = {
			/**
			 * Adds an asset.
			 *
			 * @param {String} id
			 * @param {String} asset
			 */
			add : function( id, asset ) {
				this.assets[ id ] = asset
			},

			/**
			 * Gets an asset by id.
			 *
			 * @param {String} id
			 * @return {Object}
			 */
			get : function( id ) {
				return this.assets[ id ]
			},

			/**
			 * Returns true if an asset with the specified id exists.
			 *
			 * @param {String} id
			 * @return {Boolean}
			 */
			has : function( id ) {
				return !!this.assets[ id ]
			},

			/**
			 * Returns the library ids of all assets which reference a specific resource id.
			 *
			 * @private
			 * @param {String} resourceId
			 * @return {Array}
			 */
			getLibraryIdByResourceId : function( resourceId ) {
				var assets = this.assets,
					ids = []

				for( var id in assets ) {
					var asset = assets[ id ]

					if( asset.resourceId &&
						asset.resourceId === resourceId ) {

						ids.push( id.slice( id.indexOf( ':' ) + 1 ) )
					}
				}

				return ids
			},

			/**
			 * Inject the provided resources into asset instances where applicable.
			 *
			 * @private
			 * @param {Object} resources
			 */
			injectResources : function( resources ) {
				if( !resources ) return

				var assets         = this.assets,
					libraryManager = this.libraryManager

				for( var id in assets ) {
					var asset     = assets[ id ],
						libraryId = asset.resourceId || id.substr( id.indexOf( ':' ) + 1, id.length )

					if( !resources[ libraryId ] ) {
						continue
					}

					var resource = libraryManager.getResource( libraryId ) || libraryManager.getMetaData( libraryId )

					if( resource ) {
						asset.resource = resource
					}
				}
			},

			/**
			 * Frees all asset instances.
			 *
			 * @private
			 */
			free : function() {
				this.assets = {}
			}
		}

		return AssetManager
	}
)

define(
	'spell/data/SortedMap',
	[
		'spell/shared/util/arrayRemove'
	],
	function(
		arrayRemove
	) {
		'use strict'


		var SortedMap = function() {
		    this.keys = []
		    this.values = []
		}

		SortedMap.prototype = {
		    add : function( key, value ) {
				var keys   = this.keys,
					values = this.values,
					index  = keys.indexOf( key )

				if( index === -1 ) {
					keys.push( key )
					values.push( value )

				} else {
					values[ index ] = value
				}

				return this
		    },
		    insert : function( key, value, index ) {
				var foundIndex = this.keys.indexOf( key )

				if( foundIndex !== -1 ) {
					this.removeByIndex( foundIndex )
				}

		        this.keys.splice( index, 0, key )
		        this.values.splice( index, 0, value )

				return this
		    },
			getByIndex : function( index ) {
				return this.values[ index ]
			},
			getByKey : function( key ) {
				return this.getByIndex( this.keys.indexOf( key ) )
			},
			hasKey : function( key ) {
				return this.keys.indexOf( key ) !== -1
			},
		    removeByIndex : function( index ) {
		        arrayRemove( this.keys, index )
				arrayRemove( this.values, index )

				return this
		    },
		    removeByKey : function( key ) {
		        this.removeByIndex( this.keys.indexOf( key ) )

				return this
		    },
		    each : function( iter ) {
		        var keys   = this.keys,
		            values = this.values

		        for( var i = 0, numKeys = keys.length; i < numKeys; i++ ) {
		            var key   = keys[ i ],
						value = values[ i ]

		            iter( value, key )
		        }

				return this
		    },
			clear : function() {
				this.keys.length = 0
				this.values.length = 0

				return this
			},
		    size : function() {
		        return this.keys.length
		    }
		}

		return SortedMap
	}
)

define(
	'spell/data/entity/flatten',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var flattenEntityConfig = function( entityConfigs ) {
			return _.reduce(
				entityConfigs,
				function( memo, entityConfig ) {
					memo.push( entityConfig )

					return _.has( entityConfig, 'children' ) ?
						memo.concat( flattenEntityConfig( entityConfig.children ) ) :
						memo
				},
				[]
			)
		}

		return function( arg0 ) {
			var entityConfigs = _.isArray( arg0 ) ? arg0 : [ arg0 ]

			return flattenEntityConfig( entityConfigs )
		}
	}
)

define(
	'spell/shared/util/scene/Scene',
	[
		'spell/Defines',
		'spell/data/entity/flatten',
		'spell/data/SortedMap',
		'spell/shared/util/create',
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createLibraryFilePathsFromIds',
		'spell/shared/util/createModuleId',
		'spell/shared/util/deepClone',
		'spell/shared/util/StopWatch',
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/platform/Types',

		'spell/functions'
	],
	function(
		Defines,
		flattenEntityConfig,
		SortedMap,
		create,
		createId,
		createLibraryFilePathFromId,
		createLibraryFilePathsFromIds,
		createModuleId,
		deepClone,
		StopWatch,
		PlatformKit,
		Types,

		_
	) {
		'use strict'


		var CAMERA_COMPONENT_ID = Defines.CAMERA_COMPONENT_ID

		var stopWatch = new StopWatch()

		/*
		 * TODO: Remove this custom invoke that knows how to handle the borked instances produced by the "create" constructor wrapper function.
		 * Instances created by "create" for some unknown reason do not support prototype chain method look-up. See "Fix create"
		 */
		var invoke = function( sortedMap, functionName, statisticsManager, activeSystemsOnly, args ) {
			var systems = sortedMap.values

			for( var i = 0, numSystems = systems.length; i < numSystems; i++ ) {
				stopWatch.start()

				var system = systems[ i ]

				if( !activeSystemsOnly || system.config.active ) {
					system.prototype[ functionName ].apply( system, args )
				}

				statisticsManager.updateNode( sortedMap.keys[ i ], stopWatch.stop() )
			}
		}

		var createSystem = function( spell, entityManager, systemId, system, isModeDevelopment, systemConfig ) {
			var attributes = _.reduce(
				system.input,
				function( memo, inputDefinition ) {
					var componentMap = entityManager.getComponentMapById( inputDefinition.componentId )

					if( !componentMap ) {
						throw 'Error: No component list for component template id \'' + inputDefinition.componentId +  '\' available.'
					}

					if( inputDefinition.name === 'config' ) {
						throw 'Error: The system \'' + systemId + '\' uses the reserved keyword \'config\' as a local alias for its input.'
					}

					memo[ inputDefinition.name ] = componentMap

					return memo
				},
				{
					config : systemConfig
				}
			)

			var constructor = spell.moduleLoader.require( createModuleId( systemId ) )

			// TODO: Fix create. Returned instances do not support prototype chain method look-up. O_o
			return create( constructor, [ spell ], attributes )
		}

		var createConfigFromSystemTemplateConfig = function( config ) {
			return _.reduce(
				config,
				function( memo, record ) {
					memo[ record[ 'name' ] ] = deepClone( record[ 'default' ] )

					return memo
				},
				{}
			)
		}

		var createSystems = function( spell, entityManager, libraryManager, systems, isModeDevelopment ) {
			return _.reduce(
				systems,
				function( memo, system ) {
					var systemId       = system.id,
						systemTemplate = libraryManager.get( systemId )

					if( !systemTemplate ) {
						throw 'Error: Could not get template for id \'' + systemId + '\'.'
					}

					return memo.add(
						systemId,
						createSystem(
							spell,
							entityManager,
							systemId,
							systemTemplate,
							isModeDevelopment,
							_.defaults(
								deepClone( system.config ),
								createConfigFromSystemTemplateConfig( systemTemplate.config )
							)
						)
					)
				},
				new SortedMap()
			)
		}

		var hasActiveCamera = function( sceneConfig ) {
			return true

			return _.any(
				flattenEntityConfig( sceneConfig.entities ),
				function( entityConfig ) {
					if( !entityConfig.config ) {

						return false
					}

					var cameraComponent = entityConfig.config[ CAMERA_COMPONENT_ID ]

					if( !cameraComponent ) return false

					return cameraComponent.active
				}
			)
		}

		var getExecutionGroupIdBySystemId = function( executionGroups, systemId ) {
			for( var executionGroupId in executionGroups ) {
				var executionGroup = executionGroups[ executionGroupId ]

				if( executionGroup.hasKey( systemId ) ) {
					return executionGroupId
				}
			}
		}

		var addStatisticsSeries = function( statisticsManager, systems, parentNodeId ) {
			for( var i = 0, numSystems = systems.length; i < numSystems; i++ ) {
				var system = systems[ i ]

				statisticsManager.addNode( system.id, parentNodeId )
			}
		}


		var Scene = function( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneConfig, initialConfig ) {
			this.spell             = spell
			this.entityManager     = entityManager
			this.libraryManager    = libraryManager
			this.statisticsManager = statisticsManager
			this.isModeDevelopment = isModeDevelopment
			this.executionGroups   = { render : null, update : null }
			this.sceneConfig       = sceneConfig
			this.initialConfig     = initialConfig
			this.script            = null
		}

		Scene.prototype = {
			render: function( timeInMs, deltaTimeInMs ) {
				invoke( this.executionGroups.render, 'process', this.statisticsManager, true, [ this.spell, timeInMs, deltaTimeInMs ] )
			},
			update: function( timeInMs, deltaTimeInMs ) {
				invoke( this.executionGroups.update, 'process', this.statisticsManager, true, [ this.spell, timeInMs, deltaTimeInMs ] )
			},
			init: function() {
				var spell         = this.spell,
					sceneConfig   = this.sceneConfig,
					initialConfig = this.initialConfig

				this.statisticsManager.init()

				if( !hasActiveCamera( sceneConfig ) ) {
					spell.console.error( 'Could not start scene "' + sceneConfig.name + '" because no camera entity was found. A scene must have at least one active camera entity.' )

					return
				}

				var entityManager   = this.entityManager,
					libraryManager  = this.libraryManager,
					executionGroups = this.executionGroups

				entityManager.init()

				executionGroups.render = createSystems(
					spell,
					entityManager,
					libraryManager,
					sceneConfig.systems.render,
					this.isModeDevelopment
				)

				executionGroups.update = createSystems(
					spell,
					entityManager,
					libraryManager,
					sceneConfig.systems.update,
					this.isModeDevelopment
				)


				addStatisticsSeries( this.statisticsManager, sceneConfig.systems.render, 'render' )
				addStatisticsSeries( this.statisticsManager, sceneConfig.systems.update, 'update' )


				// initializing systems
				invoke( executionGroups.render, 'init', this.statisticsManager, false, [ spell, sceneConfig, initialConfig ] )
				invoke( executionGroups.update, 'init', this.statisticsManager, false, [ spell, sceneConfig, initialConfig ] )

				// creating entities from scene config
				entityManager.createEntities( sceneConfig.entities )

				// initializing scene
				var moduleId = createModuleId( createId( sceneConfig.namespace, sceneConfig.name ) )

				this.script = spell.moduleLoader.require( moduleId )
				this.script.init( spell, sceneConfig, initialConfig )

				// activating systems
				invoke( executionGroups.render, 'activate', this.statisticsManager, true, [ spell, sceneConfig, initialConfig ] )
				invoke( executionGroups.update, 'activate', this.statisticsManager, true, [ spell, sceneConfig, initialConfig ] )
			},
			destroy: function() {
				var executionGroups = this.executionGroups,
					spell           = this.spell,
					sceneConfig     = this.sceneConfig

				// deactivating systems
				invoke( executionGroups.render, 'deactivate', this.statisticsManager, true, [ spell, sceneConfig ] )
				invoke( executionGroups.update, 'deactivate', this.statisticsManager, true, [ spell, sceneConfig ] )

				// destroying scene
				this.script.destroy( this.spell, sceneConfig )

				// removing all entities
				this.entityManager.destroy()

				// destroying systems
				invoke( executionGroups.render, 'destroy', this.statisticsManager, false, [ spell, sceneConfig ] )
				invoke( executionGroups.update, 'destroy', this.statisticsManager, false, [ spell, sceneConfig ] )
			},
			restartSystem: function( systemId, executionGroupId, systemConfig ) {
				var executionGroups = this.executionGroups

				if( !executionGroupId ) {
					// figure out in which execution group the system is contained
					executionGroupId = getExecutionGroupIdBySystemId( executionGroups, systemId )
				}

				var executionGroup = executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var system = executionGroup.getByKey( systemId )
				if( !system ) return

				if( !systemConfig ) {
					// reusing the existing system config if none was provided
					systemConfig = system.config
				}

				// deactivating, destroying ye olde system
				var spell = this.spell

				if( system.config.active ) {
					system.prototype.deactivate.call( system, spell )
				}

				system.prototype.destroy.call( system, spell )

				// initializing and activating the new system instance
				var newSystem = createSystem(
					spell,
					this.entityManager,
					systemId,
					this.libraryManager.get( systemId ),
					this.isModeDevelopment,
					systemConfig
				)

				newSystem.prototype.init.call( newSystem, spell, this.sceneConfig, this.initialConfig )

				if( newSystem.config.active ) {
					newSystem.prototype.activate.call( newSystem, spell, this.sceneConfig, this.initialConfig )
				}

				executionGroup.add( systemId, newSystem )
			},
			addSystem: function( systemId, executionGroupId, index, systemConfig ) {
				var executionGroup = this.executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var spell             = this.spell,
					isModeDevelopment = this.isModeDevelopment,
					libraryManager    = this.libraryManager

				libraryManager.load(
					createLibraryFilePathsFromIds( [ systemId ] ),
					{
						assetManager : spell.assetManager
					},
					function() {
						var system = createSystem(
							spell,
							spell.entityManager,
							systemId,
							libraryManager.get( systemId ),
							isModeDevelopment,
							systemConfig
						)

						system.prototype.init.call( system, spell )

						if( system.config.active ) {
							system.prototype.activate.call( system, spell )
						}

						executionGroup.insert( systemId, system, index )
					}
				)
			},
			removeSystem: function( systemId, executionGroupId ) {
				var executionGroup = this.executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var spell  = this.spell,
					system = executionGroup.getByKey( systemId )

				if( system.config.active ) {
					system.prototype.deactivate.call( system, spell )
				}
				system.prototype.destroy.call( system, spell )

				executionGroup.removeByKey( systemId )
			},
			moveSystem: function( systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ) {
				var srcExecutionGroup = this.executionGroups[ srcExecutionGroupId ],
					dstExecutionGroup = this.executionGroups[ dstExecutionGroupId ]

				if( !srcExecutionGroup || !dstExecutionGroup ) return

				var system = srcExecutionGroup.getByKey( systemId )
				if( !system ) return

				srcExecutionGroup.removeByKey( systemId )
				dstExecutionGroup.insert( systemId, system, dstIndex )
			},
			updateSystem: function( systemId, executionGroupId, systemConfig ) {
				if( !systemConfig ) return

				var executionGroups = this.executionGroups

				if( !executionGroupId ) {
					// figure out in which execution group the system is contained
					executionGroupId = getExecutionGroupIdBySystemId( executionGroups, systemId )
				}

				var executionGroup = executionGroups[ executionGroupId ]
				if( !executionGroup ) return

				var system = executionGroup.getByKey( systemId )
				if( !system ) return

				var changedActive = systemConfig.active !== undefined &&
					system.config !== systemConfig.active

				_.extend(
					system.config,
					deepClone( systemConfig )
				)

				if( changedActive ) {
					if( systemConfig.active ) {
						system.prototype.activate.call( system, this.spell, this.sceneConfig, this.initialConfig )

					} else {
						system.prototype.deactivate.call( system, this.spell, this.sceneConfig )
					}
				}
			}
		}

		return Scene
	}
)

define(
	'spell/shared/util/createLibraryFilePathsFromIds',
	[
		'spell/shared/util/createLibraryFilePathFromId',

		'spell/functions'
	],
	function(
		createLibraryFilePathFromId,

		_
	) {
		'use strict'


		return function( libraryIds ) {
			return _.reduce(
				libraryIds,
				function( memo, libraryId ) {
					memo[ libraryId ] = createLibraryFilePathFromId( libraryId )

					return memo
				},
				{}
			)
		}
	}
)

define(
	'spell/client/loading/loadSceneResources',
	[
		'spell/client/util/updateAssets',
		'spell/client/loading/addNamespaceAndName',
		'spell/client/loading/createFilesToLoad',
		'spell/shared/util/createLibraryFilePathsFromIds',
		'spell/math/util',
		'spell/shared/util/createId',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		updateAssets,
		addNamespaceAndName,
		createFilesToLoad,
		createLibraryFilePathsFromIds,
		mathUtil,
		createId,
		PlatformKit,

		_
	) {
		'use strict'


		var groupByType = function( libraryRecords ) {
			return _.reduce(
				libraryRecords,
				function( memo, value, libraryId ) {
					var type = value.type

					if( !memo[ type ] ) {
						memo[ type ] = {}
					}

					memo[ type ][ libraryId ] = value

					return memo
				},
				{}
			)
		}

		var addIdAsKey = function( result, libraryRecords ) {
			for( var id in libraryRecords ) {
				var libraryRecord = libraryRecords[ id ]

				result[ createId( libraryRecord.namespace, libraryRecord.name ) ] = libraryRecord
			}
		}

		var createLoadingProgress = function( eventManager, progressCallback ) {
			if( !progressCallback ) progressCallback = function() {}

			var LoadingProgress = function( eventManager, progressCallback ) {
				this.bundles          = {}
				this.eventManager     = eventManager
				this.progressCallback = progressCallback
				this.progress         = 0
				this.lastSendProgress = 0
				this.progressHandler  = function( portion, progress, numCompleted, numTotal ) {
					this.progress += portion / numTotal

					var currentProgress = mathUtil.roundToResolution( this.progress, 0.01 )

					if( currentProgress <= this.lastSendProgress ) return

					this.lastSendProgress = currentProgress
					this.progressCallback( currentProgress )
				}
			}

			LoadingProgress.prototype = {
				addBundle : function( name, portion ) {
					var eventManager = this.eventManager

					// the loading interval is [ 0, 0.99 ], call "complete" to signal progress of 1
					var handler = _.bind( this.progressHandler, this, portion * 0.99 )

					this.bundles[ name ] = handler

					eventManager.subscribe( [ eventManager.EVENT.RESOURCE_PROGRESS, name ], handler )
				},
				complete : function() {
					this.progressCallback( 1 )
				},
				destroy : function() {
					var bundles      = this.bundles,
						eventManager = this.eventManager

					for( var name in bundles ) {
						var handler = bundles[ name ]

						eventManager.unsubscribe( [ eventManager.EVENT.RESOURCE_PROGRESS, name ], handler )
					}
				}
			}

			return new LoadingProgress( eventManager, progressCallback )
		}


		return function( spell, sceneId, next, progressCallback ) {
			var assetManager         = spell.assetManager,
				configurationManager = spell.configurationManager,
				eventManager         = spell.eventManager,
				EVENT                = eventManager.EVENT,
				libraryManager       = spell.libraryManager,
				resources            = spell.resources,
				entityManager        = spell.entityManager

			var libraryBundleName  = sceneId + '-library',
				resourceBundleName = sceneId + '-resources'

			var loadingProgress = createLoadingProgress( eventManager, progressCallback )

			loadingProgress.addBundle( sceneId, 0.1 )
			loadingProgress.addBundle( libraryBundleName, 0.1 )
			loadingProgress.addBundle( resourceBundleName, 0.8 )


			eventManager.waitFor(
				[ EVENT.RESOURCE_LOADING_COMPLETED, sceneId ],
				function( loadedRecords ) {
					addIdAsKey( spell.scenes, loadedRecords )
				}

			).resume( function() {
				eventManager.waitFor(
					[ EVENT.RESOURCE_LOADING_COMPLETED, libraryBundleName ],
					function( loadedRecords ) {
						var library = groupByType( loadedRecords )

						updateAssets( assetManager, library.asset )

						libraryManager.load(
							createFilesToLoad( configurationManager, library.asset ),
							{
								assetManager : spell.assetManager,
								name : resourceBundleName,
								isMetaDataLoad : false
							}
						)

						_.each(
							library.component,
							_.bind( entityManager.registerComponent, entityManager )
						)

						addIdAsKey( spell.scenes, library.scene )
					}

				).and(
					[ EVENT.RESOURCE_LOADING_COMPLETED, resourceBundleName ],
					_.bind( assetManager.injectResources, assetManager )

				).resume( function() {
					loadingProgress.complete()
					loadingProgress.destroy()

					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, sceneId ] )
					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, libraryBundleName ] )
					eventManager.unsubscribeAll( [ EVENT.RESOURCE_LOADING_COMPLETED, resourceBundleName ] )

					next()
				} )

				// start loading the required library records
				var scene = spell.scenes[ sceneId ]

				libraryManager.load(
					createLibraryFilePathsFromIds( scene.libraryIds ),
					{
						assetManager : spell.assetManager,
						name : libraryBundleName
					}
				)
			} )

			// load scene library record
			libraryManager.load(
				createLibraryFilePathsFromIds( [ sceneId ] ),
				{
					assetManager : spell.assetManager,
					name : sceneId
				}
			)
		}
	}
)

/**
 * The SceneManager enables controlling of the currently executed scene.
 *
 * @class spell.sceneManager
 * @singleton
 */
define(
	'spell/SceneManager',
	[
		'spell/client/loading/loadSceneResources',
		'spell/shared/util/scene/Scene',

		'spell/functions'
	],
	function(
		loadSceneResources,
		Scene,

		_
	) {
		'use strict'


		var update = function( entityManager, scene, timeInMs, deltaTimeInMs ) {
			entityManager.updateDeferredEvents( deltaTimeInMs )
			scene.update( timeInMs, deltaTimeInMs )
		}

		var postLoadedResources = function( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneId, initialConfig ) {
			var sceneConfig = spell.scenes[ sceneId ]

			if( !sceneConfig ) {
				throw 'Error: Could not find scene configuration for scene "' + sceneId + '".'
			}

			var scene = new Scene( spell, entityManager, libraryManager, statisticsManager, isModeDevelopment, sceneConfig, initialConfig )

			scene.init()

			this.mainLoop.setRenderCallback( _.bind( scene.render, scene ) )
			this.mainLoop.setUpdateCallback( _.bind( update, null, entityManager, scene ) )

			this.activeScene = scene

			this.loadingPending = false
			this.processCmdQueue()

			if( this.sendMessageToEditor ) {
				this.sendMessageToEditor( 'spelled.debug.application.sceneStarted', sceneId )
			}
		}

		var startScene = function( targetSceneId, initialConfig, showLoadingScene ) {
			var freeMemory = showLoadingScene

			var preNextFrameCallback = function() {
				var spell = this.spell

				if( this.activeScene ) {
					this.mainLoop.setRenderCallback()
					this.mainLoop.setUpdateCallback()
					this.activeScene.destroy()
					this.activeScene = undefined

					if( freeMemory &&
						!spell.configurationManager.getValue( 'platform.hasPlentyRAM' ) ) {

						spell.assetManager.free()
						spell.libraryManager.free()
					}

					spell.statisticsManager.reset()
				}

				var onProgress = this.sendMessageToEditor ?
					_.bind( this.sendMessageToEditor, null, 'spelled.loadingProgress' ) :
					undefined

				this.cmdQueue = []
				this.loadingPending = true


				// check if library dependencies of next scene are already available
				var nextScene = spell.scenes[ targetSceneId ]

				if( nextScene &&
					spell.libraryManager.isAvailable( nextScene.libraryIds ) ) {

					// perform direct transition
					postLoadedResources.call(
						this,
						spell,
						this.entityManager,
						this.libraryManager,
						this.statisticsManager,
						this.isModeDevelopment,
						targetSceneId,
						initialConfig
					)

				} else {
					var loadingSceneId = spell.configurationManager.getValue( 'loadingScene' )

					if( showLoadingScene &&
						loadingSceneId ) {

						loadSceneResources(
							spell,
							loadingSceneId,
							_.bind(
								postLoadedResources,
								this,
								spell,
								this.entityManager,
								this.libraryManager,
								this.statisticsManager,
								this.isModeDevelopment,
								loadingSceneId,
								{
									targetSceneId : targetSceneId,
									initialConfig : initialConfig
								}
							),
							onProgress
						)

					} else {
						// load library dependencies first
						loadSceneResources(
							spell,
							targetSceneId,
							_.bind(
								postLoadedResources,
								this,
								spell,
								this.entityManager,
								this.libraryManager,
								this.statisticsManager,
								this.isModeDevelopment,
								targetSceneId,
								initialConfig
							),
							onProgress
						)
					}
				}
			}

			this.mainLoop.setPreNextFrame( _.bind( preNextFrameCallback, this ) )
		}

		var SceneManager = function( spell, entityManager, statisticsManager, libraryManager, mainLoop, sendMessageToEditor, isModeDevelopment ) {
			this.activeScene
			this.entityManager       = entityManager
			this.mainLoop            = mainLoop
			this.sendMessageToEditor = sendMessageToEditor
			this.spell               = spell
			this.statisticsManager   = statisticsManager
			this.libraryManager      = libraryManager
			this.isModeDevelopment   = isModeDevelopment
			this.cmdQueue            = []
			this.loadingPending      = false
		}

		SceneManager.prototype = {
			/**
			 * Changes the currently executed scene to the scene specified by targetSceneId.
			 *
			 * @param {String} targetSceneId the library id of the scene to which to change
			 * @param {Object} initialConfig configuration passed to the target scene
			 * @param {Boolean} showLoadingScene if true the loading scene is displayed
			 */
			changeScene : function( targetSceneId, initialConfig, showLoadingScene ) {
				showLoadingScene = showLoadingScene || false

				if( !this.isModeDevelopment ) {
					startScene.call( this, targetSceneId, initialConfig, showLoadingScene )

				} else {
					this.spell.sendMessageToEditor(
						'spelled.debug.application.startScene',
						{
							targetSceneId : targetSceneId,
							initialConfig : initialConfig,
							showLoadingScene : showLoadingScene
						}
					)
				}
			},

			startScene : startScene,

			processCmdQueue : function() {
				if( this.loadingPending ) {
					return
				}

				var cmdQueue = this.cmdQueue

				for( var i = 0; i < cmdQueue.length; i++ ) {
					var cmd = cmdQueue[ i ]

					this.activeScene[ cmd.fn ].apply( this.activeScene, cmd.args )
				}

				cmdQueue.length = 0
			},

			addSystem : function( systemId, executionGroupId, index, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'addSystem',
					args : [ systemId, executionGroupId, index, systemConfig ]
				} )

				this.processCmdQueue()
			},

			moveSystem : function( systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ) {
				this.cmdQueue.push( {
					fn   : 'moveSystem',
					args : [ systemId, srcExecutionGroupId, dstExecutionGroupId, dstIndex ]
				} )

				this.processCmdQueue()
			},

			removeSystem : function( systemId, executionGroupId ) {
				this.cmdQueue.push( {
					fn   : 'removeSystem',
					args : [ systemId, executionGroupId ]
				} )

				this.processCmdQueue()
			},

			restartSystem : function( systemId, executionGroupId, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'restartSystem',
					args : [ systemId, executionGroupId, systemConfig ]
				} )

				this.processCmdQueue()
			},

			updateSystem : function( systemId, executionGroupId, systemConfig ) {
				this.cmdQueue.push( {
					fn   : 'updateSystem',
					args : [ systemId, executionGroupId, systemConfig ]
				} )

				this.processCmdQueue()
			}
		}

		return SceneManager
	}
)

define(
	'spell/data/component/init',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( componentInstance, componentDefinition ) {
			var attributes = componentDefinition.attributes

			for( var i = 0, n = attributes.length, attributeConfig; i < n; i++ ) {
				attributeConfig = attributes[ i ]

				componentInstance[ attributeConfig.name ] = _.clone( attributeConfig[ 'default' ] )
			}

			return componentInstance
		}
	}
)

define(
	'spell/data/entity/applyEntityConfig',
	[
		'spell/shared/util/deepClone',

		'spell/functions'
	],
	function(
		deepClone,

		_
	) {
		'use strict'


		/**
		 * Applies a an entity configuration to an entity and returns the updated entity. Attribute instances are copied by reference.
		 *
		 * @param entity
		 * @param entityConfig
		 * @return {*}
		 */
		var applyEntityConfig = function( entity, entityConfig ) {
			for( var componentId in entityConfig ) {
				entity[ componentId ] = _.extend(
					entity[ componentId ] || {},
					deepClone( entityConfig[ componentId ] )
				)
			}

			return entity
		}

		return applyEntityConfig
	}
)

define(
	'spell/shared/util/deepClone',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function deepClone( o ) {
			var isArray = _.isArray( o )

			if( isArray ||
				_.isObject( o ) ) {

				var clone = isArray ? [] : {}

				_.each( o, function( value, key ) {
					clone[ key ] = deepClone( value )
				} )

				return clone

			} else {
				return o
			}
		}
	}
)

define(
	'spell/shared/util/create',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var NO_CONSTRUCTOR_ERROR = 'The first argument for create must be a constructor. You passed in '


		/*
		 * public
		 */

		// TODO: Fix the issue that instances which where created with "create" do not support method look-up along the prototype chain.
		return function( constructor, constructorArguments, propertiesToInject ) {
			if ( constructor.prototype === undefined ) {
				throw NO_CONSTRUCTOR_ERROR + constructor
			}

			var object = {}

			if( !!propertiesToInject && _.isObject( propertiesToInject ) ) {
				_.extend( object, propertiesToInject )
			}

			object.prototype = constructor.prototype
			var returnedObject = constructor.apply( object, constructorArguments )
			return returnedObject || object
		}
	}
)

define(
	'spell/shared/util/arrayRemove',
	function() {
		'use strict'


		// Array Remove - By John Resig (MIT Licensed)
		return function( array, from, to ) {
			var rest = array.slice( ( to || from ) + 1 || array.length )

			array.length = from < 0 ? array.length + from : from

			return array.push.apply( array, rest )
		}
	}
)

define(
	'spell/Defines',
	function() {
		'use strict'


		return {
			INVALID_ENTITY_ID                         : '',
			ROOT_ENTITY_ID                            : '0',
			COMPOSITE_COMPONENT_ID                    : 'spell.component.composite',
			METADATA_COMPONENT_ID                     : 'spell.component.metaData',
			EVENT_HANDLERS_COMPONENT_ID               : 'spell.component.eventHandlers',
			TRANSFORM_COMPONENT_ID                    : 'spell.component.2d.transform',
			TEXTURE_MATRIX_COMPONENT_ID               : 'spell.component.2d.graphics.textureMatrix',
			CAMERA_COMPONENT_ID                       : 'spell.component.2d.graphics.camera',
			CAMERA_MOVEMENT_COMPONENT_ID              : 'spell.component.2d.graphics.cameraMovement',
			STATIC_APPEARANCE_COMPONENT_ID            : 'spell.component.2d.graphics.appearance',
			TEXT_APPEARANCE_COMPONENT_ID              : 'spell.component.2d.graphics.textAppearance',
			ANIMATED_APPEARANCE_COMPONENT_ID          : 'spell.component.2d.graphics.animatedAppearance',
			QUAD_GEOMETRY_COMPONENT_ID                : 'spell.component.2d.graphics.geometry.quad',
			TILEMAP_COMPONENT_ID                      : 'spell.component.2d.graphics.tilemap',
			PARALLAX_COMPONENT_ID                     : 'spell.component.2d.graphics.parallax',
			PHYSICS_BODY_COMPONENT_ID                 : 'spell.component.physics.body',
            PHYSICS_CONTACT_TRIGGER_COMPONENT_ID      : 'spell.component.physics.contactTrigger',
			PHYSICS_FIXTURE_COMPONENT_ID              : 'spell.component.physics.fixture',
			PHYSICS_BOX_SHAPE_COMPONENT_ID            : 'spell.component.physics.shape.box',
			PHYSICS_CIRCLE_SHAPE_COMPONENT_ID         : 'spell.component.physics.shape.circle',
			PHYSICS_CONVEX_POLYGON_SHAPE_COMPONENT_ID : 'spell.component.physics.shape.convexPolygon',
			PHYSICS_JNRPLAYER_SHAPE_COMPONENT_ID      : 'spell.component.physics.shape.jumpAndRunPlayer',
			KEY_FRAME_ANIMATION_COMPONENT_ID          : 'spell.component.animation.keyFrameAnimation',
			SOUND_EMITTER_COMPONENT_ID                : 'spell.component.audio.soundEmitter',
			VISUAL_OBJECT_COMPONENT_ID                : 'spell.component.visualObject',
			CONTROLLABLE_COMPONENT_ID                 : 'spell.component.controllable'
		}
	}
)

define(
	'spell/data/entity/recursiveFind',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var find = function( entityConfigs, iterator ) {
			var numEntityConfigs = entityConfigs.length,
				result

			for( var i = 0; i < numEntityConfigs; i++ ) {
				var entityConfig = entityConfigs[ i ]

				result = iterator( entityConfig )

				if( result ) {
					return result
				}

				var children = entityConfig.children

				if( children &&
					children.length > 0 ) {

					return find( children, iterator )
				}
			}
		}

		return function( arg0, iterator ) {
			var entityConfigs = _.isArray( arg0 ) ? arg0 : [ arg0 ]

			return find( entityConfigs, iterator )
		}
	}
)

define(
	'spell/data/entity/createAmbiguousSiblingName',
	function() {
		'use strict'


		return function( entityConfig ) {
			var children = entityConfig.children
			if( !children ) return false

			var names = {}

			for( var i = 0, n = children.length; i < n; i++ ) {
				var name = children[ i ].name

				if( name ) {
					if( !names[ name ] ) {
						names[ name ] = true

					} else {
						return name
					}
				}
			}

			return false
		}
	}
)

define(
	'spell/data/LinkedList',
	function() {
		'use strict'


		var Node = function() {
			this.data = undefined
			this.previous = undefined
			this.next = undefined
		}

		var Iterator = function( linkedList ) {
			this.linkedList = linkedList
			this.currentNode = linkedList.firstNode
		}

		Iterator.prototype = {
			next : function() {
				var node = this.currentNode
				if( !node ) return

				this.currentNode = node.next

				return node
			},
			remove : function() {
				var linkedList  = this.linkedList,
					currentNode = this.currentNode,
					removeNode  = currentNode ? currentNode.previous : linkedList.lastNode

				if( !removeNode ) return

				var previousNode = removeNode.previous,
					nextNode     = removeNode.next

				if( previousNode ) {
					previousNode.next = nextNode

				} else {
					linkedList.firstNode = nextNode
				}

				if( nextNode ) {
					nextNode.previous = previousNode

				} else {
					linkedList.lastNode = previousNode
				}

				this.currentNode = currentNode ?
					previousNode || nextNode :
					undefined

				linkedList.size--
			}
		}

		var LinkedList = function() {
			this.firstNode = undefined
			this.lastNode = undefined
			this.size = 0
		}

		LinkedList.prototype = {
			append : function( x ) {
				var node = new Node()

				node.data = x

				if( !this.firstNode ) {
					this.firstNode = node

				} else {
					this.lastNode.next = node
					node.previous = this.lastNode
				}

				this.lastNode = node
				this.size++
			},
			clear : function() {
				this.firstNode = undefined
				this.lastNode = undefined
				this.size = 0
			},
			createIterator : function() {
				return new Iterator( this )
			}
		}

		return LinkedList
	}
)

/**
 * The EntityManager offers methods for creating, updating and destroying entities as well as for querying and updating components and component attributes.
 *
 * @class spell.entityManager
 * @singleton
 */
define(
	'spell/EntityManager',
	[
		'spell/data/LinkedList',
		'spell/data/entity/createAmbiguousSiblingName',
		'spell/data/entity/recursiveFind',
		'spell/Defines',
		'spell/shared/util/arrayRemove',
		'spell/shared/util/create',
		'spell/shared/util/createId',
		'spell/shared/util/createModuleId',
		'spell/shared/util/deepClone',
		'spell/data/entity/applyEntityConfig',
		'spell/stringUtil',
		'spell/shared/util/platform/PlatformKit',
		'spell/data/component/init',

		'spell/math/util',
		'spell/math/mat3',
		'spell/math/vec2',

		'spell/functions'
	],
	function(
		LinkedList,
		createAmbiguousSiblingName,
		recursiveFind,
		Defines,
		arrayRemove,
		create,
		createId,
		createModuleId,
		deepClone,
		applyEntityConfig,
		stringUtil,
		PlatformKit,
		initComponent,

		mathUtil,
		mat3,
		vec2,

		_
	) {
		'use strict'


		var nextEntityId                     = 1,
			createComponentType              = PlatformKit.createComponentType,
			INVALID_ENTITY_ID                = Defines.INVALID_ENTITY_ID,
			ROOT_ENTITY_ID                   = Defines.ROOT_ENTITY_ID,
			COMPOSITE_COMPONENT_ID           = Defines.COMPOSITE_COMPONENT_ID,
			METADATA_COMPONENT_ID            = Defines.METADATA_COMPONENT_ID,
			TRANSFORM_COMPONENT_ID           = Defines.TRANSFORM_COMPONENT_ID,
			TEXTURE_MATRIX_COMPONENT_ID      = Defines.TEXTURE_MATRIX_COMPONENT_ID,
			EVENT_HANDLERS_COMPONENT_ID      = Defines.EVENT_HANDLERS_COMPONENT_ID,
			STATIC_APPEARANCE_COMPONENT_ID   = Defines.STATIC_APPEARANCE_COMPONENT_ID,
			ANIMATED_APPEARANCE_COMPONENT_ID = Defines.ANIMATED_APPEARANCE_COMPONENT_ID,
			QUAD_GEOMETRY_COMPONENT_ID       = Defines.QUAD_GEOMETRY_COMPONENT_ID,
			TILEMAP_COMPONENT_ID             = Defines.TILEMAP_COMPONENT_ID,
			VISUAL_OBJECT_COMPONENT_ID       = Defines.VISUAL_OBJECT_COMPONENT_ID

		var DeferredEvent = function( entityId, eventId, eventArguments, timerInMs, timerCondition ) {
			this.entityId       = entityId
			this.eventId        = eventId
			this.eventArguments = eventArguments
			this.timerInMs      = timerInMs
			this.timerCondition = timerCondition
		}

		DeferredEvent.prototype = {
			trigger : function( entityManager ) {
				entityManager.triggerEvent( this.entityId, this.eventId, this.eventArguments )
			},
			ready : function( deltaTimeInMs ) {
				var timerCondition = this.timerCondition

				if( timerCondition && !timerCondition() ) {
					return false
				}

				return ( this.timerInMs -= deltaTimeInMs ) <= 0
			}
		}

		var isValidComponentDefinition = function( template ) {
			// check for ambiguous attribute names
			var attributeNameCounts = _.reduce(
				template.attributes,
				function( memo, attributeConfig ) {
					var attributeName = attributeConfig.name

					memo[ attributeName ] = memo[ attributeName ] ?
						memo[ attributeName ] + 1 :
						1

					return memo
				},
				{}
			)

			return !_.any(
				attributeNameCounts,
				function( iter ) { return iter > 1 }
			)
		}


		/**
		 * Returns an entity id. If no entity id is provided a new one is generated.
		 *
		 * @private
		 * @param {Object} id
		 * @return {*}
		 */
		var getEntityId = function( id ) {
			if( !id ) {
				return '' + nextEntityId++
			}

			var number = parseInt( id )

			if( _.isNaN( number ) ) return id

			nextEntityId = Math.max( number + 1, nextEntityId )

			return '' + number
		}

		/**
		 * Returns the id of the nearest ancestor entity which has a specific component instance.
		 *
		 * @param compositeComponents
		 * @param components component map of the requested component type
		 * @param entityId the search begins at the entity with this id
		 * @return {*}
		 */
		var getAncestorId = function( compositeComponents, components, entityId ) {
			var compositeComponent

			while( entityId !== INVALID_ENTITY_ID ) {
				compositeComponent = compositeComponents[ entityId ]
				if( !compositeComponent ) return

				entityId = compositeComponent.parentId

				if( components[ entityId ] ) {
					return entityId
				}
			}
		}

		/**
		 * Returns the next available component from the path in the entity composite tree that spans from the current entity to the root entity.
		 *
		 * @param compositeComponents
		 * @param components
		 * @param entityId
		 * @param includeCurrentEntity
		 * @return {Object}
		 */
		var getNearestComponent = function( compositeComponents, components, entityId, includeCurrentEntity ) {
			var currentComponent

			if( includeCurrentEntity ) {
				currentComponent = components[ entityId ]

				if( currentComponent ) {
					return currentComponent
				}
			}

			while( entityId !== INVALID_ENTITY_ID ) {
				entityId = compositeComponents[ entityId ].parentId

				currentComponent = components[ entityId ]

				if( currentComponent ) {
					return currentComponent
				}
			}
		}

		/**
		 * Updates the world transformation from a local transformation
		 *
		 * @private
		 * @param componentMaps
		 * @param entityId
		 * @return {*}
		 */
		var updateWorldTransform = function( componentMaps, eventManager, entityId ) {
			var transformComponents = componentMaps[ TRANSFORM_COMPONENT_ID ],
				transform           = transformComponents[ entityId ]

			if( transform ) {
				var localMatrix = transform.localMatrix,
					worldMatrix = transform.worldMatrix

				// set new localToWorldMatrix
				mat3.identity( localMatrix )
				mat3.translate( localMatrix, localMatrix, transform.translation )
				mat3.rotate( localMatrix, localMatrix, transform.rotation )
				mat3.scale( localMatrix, localMatrix, transform.scale )

				// get nearest ancestor with a transform component
				var ancestorTransform = getNearestComponent( componentMaps[ COMPOSITE_COMPONENT_ID ], transformComponents, entityId, false )

				if( ancestorTransform ) {
					// multiply parent's localToWorldMatrix with ours
					mat3.multiply( worldMatrix, ancestorTransform.worldMatrix, localMatrix )

				} else {
					// if this entity has no parent, the localToWorld Matrix equals the localMatrix
					mat3.copy( worldMatrix, localMatrix )
				}

				transform.worldTranslation[ 0 ] = worldMatrix[ 6 ]
				transform.worldTranslation[ 1 ] = worldMatrix[ 7 ]
			}

			// update the children
			var compositeComponents = componentMaps[ COMPOSITE_COMPONENT_ID ],
				childrenIds         = compositeComponents[ entityId ].childrenIds

			for( var i = 0, n = childrenIds.length; i < n; i++ ) {
				updateWorldTransform( componentMaps, eventManager, childrenIds[ i ] )
			}
		}

		var updateTextureMatrix = function( textureMatrix ) {
			var matrix      = textureMatrix.matrix,
				translation = textureMatrix.translation,
				scale       = textureMatrix.scale

			mat3.identity( matrix )
			mat3.translate( matrix, matrix, translation )
			mat3.scale( matrix, matrix, scale )

			textureMatrix.isIdentity = (
				translation[ 0 ] === 0 &&
				translation[ 1 ] === 0 &&
				scale[ 0 ] === 1 &&
				scale[ 1 ] === 1
			)
		}

		var updateVisualObjectR = function( compositeComponents, visualObjectComponents, entityId, ancestorWorldOpacity, ancestorWorldLayer ) {
			var visualObjectComponent = visualObjectComponents[ entityId ],
				worldOpacity          = ancestorWorldOpacity,
				worldLayer            = ancestorWorldLayer

			if( visualObjectComponent ) {
				visualObjectComponent.worldOpacity = worldOpacity *= visualObjectComponent.opacity
				visualObjectComponent.worldLayer   = worldLayer   += visualObjectComponent.layer
			}

			var childrenIds = compositeComponents[ entityId ].childrenIds

			for( var i = 0, n = childrenIds.length; i < n; i++ ) {
				updateVisualObjectR( compositeComponents, visualObjectComponents, childrenIds[ i ], worldOpacity, worldLayer )
			}
		}

		var updateVisualObject = function( componentMaps, entityId ) {
			var compositeComponents  = componentMaps[ COMPOSITE_COMPONENT_ID ],
				visualObjects        = componentMaps[ VISUAL_OBJECT_COMPONENT_ID ],
				ancestorVisualObject = getNearestComponent( compositeComponents, visualObjects, entityId, false )

			updateVisualObjectR(
				compositeComponents,
				visualObjects,
				entityId,
				ancestorVisualObject ? ancestorVisualObject.worldOpacity : 1.0,
				ancestorVisualObject ? ancestorVisualObject.worldLayer : 0
			)
		}

		var addComponents = function( componentMaps, eventManager, entityId, entityComponents ) {
			for( var componentId in entityComponents ) {
				var components = componentMaps[ componentId ]

				if( components[ entityId ] ) {
					throw 'Error: Adding a component to the entity with id "' + entityId + '" failed because the entity already has a component named "' + componentId + '". Check with hasComponent first if this entity already has this component.'
				}

				var component = components[ entityId ] = entityComponents[ componentId ]

				if( componentId === COMPOSITE_COMPONENT_ID ) {
					addToParentEntity( components, entityId, component.parentId )

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					updateTextureMatrix( component )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					updateWorldTransform( componentMaps, eventManager, entityId )

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish(
					[ eventManager.EVENT.COMPONENT_CREATED, componentId ],
					[ component, entityId ]
				)
			}
		}

		var entityExists = function( componentMaps, entityId ) {
			for( var componentId in componentMaps ) {
				var componentMap = componentMaps[ componentId ]

				if( componentMap[ entityId ] ) return true
			}

			return false
		}

		/**
		 * Removes the specified component from the entity.
		 *
		 * @param eventManager
		 * @param componentMaps
		 * @param componentId
		 * @param entityId
		 * @return
		 */
		var removeComponent = function( eventManager, componentMaps, componentId, entityId ) {
			var components = componentMaps[ componentId ],
				component  = components[ entityId ]

			if( !component ) return

			delete components[ entityId ]

			if( componentId === COMPOSITE_COMPONENT_ID ) {
				removeFromParentEntity( components, entityId, component.parentId )

			} else if( componentId === TRANSFORM_COMPONENT_ID ) {
				updateWorldTransform( componentMaps, eventManager, entityId )

			} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
				updateVisualObject( componentMaps, entityId )
			}

			eventManager.publish( [ eventManager.EVENT.COMPONENT_REMOVED, componentId ], entityId )
		}

		var removeEntity = function( eventManager, componentMaps, entityId ) {
			var compositeComponent = componentMaps[ COMPOSITE_COMPONENT_ID ][ entityId ]
			if( !compositeComponent ) return

			var childrenIds = compositeComponent.childrenIds

			while( childrenIds.length > 0 ) {
				removeEntity( eventManager, componentMaps, childrenIds[ 0 ] )
			}

			// remove all components, that is "remove the entity"
			// TODO: use some kind of ordered map here, the current approach is bad
			for( var componentId in componentMaps ) {
				if( componentId === COMPOSITE_COMPONENT_ID ) continue

				removeComponent( eventManager, componentMaps, componentId, entityId )
			}

			removeComponent( eventManager, componentMaps, COMPOSITE_COMPONENT_ID, entityId )

			eventManager.publish( eventManager.EVENT.ENTITY_REMOVED, entityId )
		}

		/**
		 * Applies the overloaded children config to the children config defined in a template.
		 *
		 * @private
		 * @param entityTemplateChildrenConfig
		 * @param overloadedChildrenConfig
		 * @return {*}
		 */
		var applyOverloadedChildrenConfig = function( entityTemplateChildrenConfig, overloadedChildrenConfig ) {
			return _.reduce(
				overloadedChildrenConfig,
				function( memo, overloadedChildConfig ) {
					var entityTemplateChildConfig = _.find(
						memo,
						function( entityTemplateChildConfig ) {
							return overloadedChildConfig.name === entityTemplateChildConfig.name
						}
					)

					if( entityTemplateChildConfig ) {
						entityTemplateChildConfig.children = mergeOverloadedChildren( entityTemplateChildConfig.children, overloadedChildConfig.children )
						entityTemplateChildConfig.id       = overloadedChildConfig.id

						if( !entityTemplateChildConfig.config ) {
							entityTemplateChildConfig.config = {}
						}

						applyEntityConfig( entityTemplateChildConfig.config, overloadedChildConfig.config )

					} else {
						memo.push( overloadedChildConfig )
					}

					return memo
				},
				deepClone( entityTemplateChildrenConfig )
			)
		}

		var mergeOverloadedChildren = function( entityTemplateChildren, overloadedChildren ) {
			if( !overloadedChildren || overloadedChildren.length === 0 ) {
				return entityTemplateChildren
			}

			if( !entityTemplateChildren || entityTemplateChildren.length === 0 ) {
				return overloadedChildren
			}

			var result = deepClone( entityTemplateChildren )

			for( var i = 0; i < overloadedChildren.length; i++ ) {
				var overloadedChild = overloadedChildren[ i ]

				var entityTemplateChild = _.find(
					result,
					function( tmp ) {
						return tmp.name === overloadedChild.name
					}
				)

				if( !entityTemplateChild ) {
					result.push( deepClone( overloadedChild ) )
					continue
				}

				if( !entityTemplateChild.config ) {
					entityTemplateChild.config = {}
				}

				applyEntityConfig( entityTemplateChild.config, overloadedChild.config )

				if( overloadedChild.id ) {
					entityTemplateChild.id = overloadedChild.id
				}

				entityTemplateChild.children = applyOverloadedChildrenConfig( entityTemplateChild.children, overloadedChild.children )
			}

			return result
		}

		var addToParentEntity = function( compositeComponents, entityId, parentEntityId ) {
			var parentCompositeComponent = compositeComponents[ parentEntityId ]
			if( !parentCompositeComponent ) return

			parentCompositeComponent.childrenIds.push( entityId )
		}

		var removeFromParentEntity = function( compositeComponents, entityId, parentEntityId ) {
			var parentCompositeComponent = compositeComponents[ parentEntityId ]
			if( !parentCompositeComponent ) return

			var parentChildrenIds = parentCompositeComponent.childrenIds

			// forcing entityId to type string because indexOf performs a type-safe comparison, entityId can be a number on the flash target
			var index = parentChildrenIds.indexOf( '' + entityId )

			if( index >= 0 ) {
				arrayRemove( parentChildrenIds, index )
			}
		}


		/**
		 * Normalizes the provided entity config
		 *
		 * @private
		 * @param libraryManager
		 * @param arg1 can be either an entity template id or a entity config
		 * @private
		 * @return {*}
		 */
		var normalizeEntityConfig = function( libraryManager, arg1 ) {
			if( !arg1 ) return

			var entityTemplateId = _.isString( arg1 ) ? arg1 : arg1.entityTemplateId

			var entityConfig = {
				children         : arg1.children || [],
				config           : arg1.config || {},
				id               : arg1.id,
				parentId         : arg1.parentId !== undefined ? arg1.parentId : ROOT_ENTITY_ID,
				name             : arg1.name,
				entityTemplateId : entityTemplateId
			}

			// check for ambiguous sibling names
			var ambiguousName = recursiveFind( entityConfig, createAmbiguousSiblingName )

			if( ambiguousName ) {
				throw 'Error: The entity configuration contains the ambiguous sibling name "' + ambiguousName + '". Entity siblings must have unique names.'
			}

			if( entityTemplateId ) {
				var entityTemplate = libraryManager.get( entityTemplateId )

				if( !entityTemplate ) {
					throw 'Error: Unknown entity template "' + entityTemplateId + '". Could not create entity.'
				}

				entityConfig.children = applyOverloadedChildrenConfig( entityTemplate.children, entityConfig.children )
			}

			return entityConfig
		}

		var createBaseComponents = function( spell, libraryManager, moduleLoader, parentId, name, entityTemplateId ) {
			var result = {},
				component

			// COMPOSITE_COMPONENT_ID
			result[ COMPOSITE_COMPONENT_ID ] = component = createComponent(
				spell,
				moduleLoader,
				libraryManager.get( COMPOSITE_COMPONENT_ID ),
				COMPOSITE_COMPONENT_ID
			)

			component.parentId = parentId

			// METADATA_COMPONENT_ID
			result[ METADATA_COMPONENT_ID ] = component = createComponent(
				spell,
				moduleLoader,
				libraryManager.get( METADATA_COMPONENT_ID ),
				METADATA_COMPONENT_ID
			)

			if( name ) {
				component.name = name
			}

			if( entityTemplateId ) {
				component.entityTemplateId = entityTemplateId
			}

			return result
		}

		var isAmbiguousSiblingName = function( componentMaps, ids, entityId, name ) {
			var metaDataComponents = componentMaps[ METADATA_COMPONENT_ID ]

			for( var i = 0, id, n = ids.length; i < n; i++ ) {
				id = ids[ i ]

				if( entityId != id &&
					metaDataComponents[ id ].name === name ) {

					return true
				}
			}

			return false
		}

		var createComponent = function( spell, moduleLoader, componentDefinition, componentId ) {
			// try component type first
			var component = createComponentType( moduleLoader, spell, componentId )

			// fall back to regular object component when no component type is available
			return initComponent( component || {}, componentDefinition )
		}

		var updateComponent = function( component, attributeConfig ) {
			if( attributeConfig === undefined ) {
				return component

			} else {
				return _.extend( component, attributeConfig )
			}
		}

		var hasAssetIdAttribute = function( attributeConfig ) {
			return !!_.find(
				attributeConfig,
				function( attribute ) {
					var type = attribute.type

					if( !_.isString( type ) ) return false

					return attribute.type.indexOf( 'assetId:' ) === 0
				}
			)
		}

		/**
		 * This function dereferences asset ids. If a component with an asset id attribute is found the reference is resolved and a additional asset attribute
		 * is added to the component instance.
		 *
		 * @private
		 * @param assetManager
		 * @param component
		 * @return {*}
		 */
		var injectAsset = function( assetManager, moduleLoader, component ) {
			var assetId = component.assetId

			if( assetId ) {
				var asset = assetManager.get( assetId )

				if( !asset &&
					stringUtil.startsWith( assetId, 'script:' ) ) {

					var libraryId = assetId.substr( 7 )

					asset = moduleLoader.require( createModuleId( libraryId ) )
				}

				if( !asset ) {
					throw 'Error: Could not resolve asset id "' + assetId + '" to asset instance. Please make sure that the asset id is valid.'
				}

				component.asset = asset
			}

			return component
		}

		var createComponents = function( spell, assetManager, libraryManager, moduleLoader, componentConfig, entityTemplateId, injectAssets ) {
			if( injectAssets === undefined ) injectAssets = true

			if( entityTemplateId ) {
				var entityTemplate = libraryManager.get( entityTemplateId )

				if( !entityTemplate ) {
					throw 'Error: Unknown entity template "' + entityTemplateId + '". Could not create entity.'
				}
			}

			var entity = applyEntityConfig(
				entityTemplate ? deepClone( entityTemplate.config ) : {},
				componentConfig
			)

			_.each(
				entity,
				function( attributeConfig, componentId ) {
					var componentDefinition = libraryManager.get( componentId )

					if( !componentDefinition ) {
						throw 'Error: Could not find component definition "' + componentId +
							entityTemplateId ?
								'" referenced in entity template "' + entityTemplateId + '".' :
								'".'
					}

					var updatedComponent = updateComponent(
						createComponent( spell, moduleLoader, componentDefinition, componentId ),
						attributeConfig
					)

					entity[ componentId ] = hasAssetIdAttribute( componentDefinition.attributes ) && injectAssets ?
						injectAsset( assetManager, moduleLoader, updatedComponent ) :
						updatedComponent
				}
			)

			return entity
		}

		var createEntity = function( spell, assetManager, eventManager, libraryManager, moduleLoader, componentMaps, entityConfig ) {
			entityConfig = normalizeEntityConfig( libraryManager, entityConfig )

			if( !entityConfig ) throw 'Error: Supplied invalid arguments.'

			var entityTemplateId = entityConfig.entityTemplateId,
				config           = entityConfig.config,
				parentId         = entityConfig.parentId

			if( !entityTemplateId && !config ) {
				throw 'Error: Supplied invalid arguments.'
			}

			var entityId = getEntityId( entityConfig.id )

			// creating base components which the engine requires
			var baseComponents = createBaseComponents( spell, libraryManager, moduleLoader, parentId, entityConfig.name, entityTemplateId )

			addComponents( componentMaps, eventManager, entityId, baseComponents )

			// creating the entity
			var entityComponents = createComponents( spell, assetManager, libraryManager, moduleLoader, config, entityTemplateId )

			addComponents( componentMaps, eventManager, entityId, entityComponents )

			// creating child entities
			var children = entityConfig.children

			for( var i = 0, childEntityConfig, n = children.length; i < n; i++ ) {
				childEntityConfig = children[ i ]
				childEntityConfig.parentId = entityId

				createEntity( spell, assetManager, eventManager, libraryManager, moduleLoader, componentMaps, childEntityConfig )
			}

			// check for validity: is the name unique?
			if( entityConfig.name ) {
				var parentCompositeComponent = componentMaps[ COMPOSITE_COMPONENT_ID ][ parentId ]

				if( isAmbiguousSiblingName( componentMaps, parentCompositeComponent.childrenIds, entityId, entityConfig.name ) ) {
					throw 'Error: The name "' + entityConfig.name + '" of entity ' + entityId + ' collides with one if its siblings. Entity siblings must have unique names.'
				}
			}

			_.extend( entityComponents, baseComponents )
			eventManager.publish( eventManager.EVENT.ENTITY_CREATED, [ entityId, entityComponents ] )

			return entityId
		}

		var assembleEntityInstance = function( componentMaps, id ) {
			return _.reduce(
				componentMaps,
				function( memo, componentMap, componentId ) {
					var component = componentMap[ id ]

					if( component ) {
						memo[ componentId ] = component
					}

					return memo
				},
				{}
			)
		}

		var getEntityCompositeIds = function( compositeComponents, entityId, resultIds ) {
			resultIds.push( entityId )

			var childrenIds = compositeComponents[ entityId ].childrenIds

			for( var i = 0, numChildrenIds = childrenIds.length; i < numChildrenIds; i++ ) {
				getEntityCompositeIds( compositeComponents, childrenIds[ i ], resultIds )
			}

			return resultIds
		}

		var getEntityDimensions = function( componentMaps, entityId ) {
			var staticAppearances   = componentMaps[ STATIC_APPEARANCE_COMPONENT_ID ],
				animatedAppearances = componentMaps[ ANIMATED_APPEARANCE_COMPONENT_ID ],
				transforms          = componentMaps[ TRANSFORM_COMPONENT_ID ],
				quadGeometries      = componentMaps[ QUAD_GEOMETRY_COMPONENT_ID ],
				tilemaps            = componentMaps[ TILEMAP_COMPONENT_ID ],
				dimensions          = vec2.create()

			if( quadGeometries &&
				quadGeometries[ entityId ] &&
				quadGeometries[ entityId ].dimensions ) {

				// if a quadGeometry is specified, always take this
				vec2.copy( dimensions, quadGeometries[ entityId ].dimensions )

			} else if( staticAppearances && staticAppearances[ entityId ] &&
				staticAppearances[ entityId ].asset &&
				staticAppearances[ entityId ].asset.resource &&
				staticAppearances[ entityId ].asset.resource.dimensions ) {

				// entity has a static appearance
				vec2.copy( dimensions, staticAppearances[ entityId ].asset.resource.dimensions )

			} else if( animatedAppearances &&
				animatedAppearances[ entityId ] &&
				animatedAppearances[ entityId ].asset &&
				animatedAppearances[ entityId ].asset.frameDimensions ) {

				// entity has an animated appearance
				vec2.copy( dimensions, animatedAppearances[ entityId ].asset.frameDimensions )

			} else if( tilemaps &&
				tilemaps[ entityId ] &&
				tilemaps[ entityId ].asset ) {

				// entity is a tilemap
				vec2.copy( dimensions, tilemaps[ entityId ].asset.tilemapDimensions )
				vec2.multiply( dimensions, dimensions, tilemaps[ entityId ].asset.spriteSheet.frameDimensions )

			} else {
				return [ 100, 100 ]
			}

			// apply scale factor
			if( transforms && transforms[ entityId ] ) {

                // TODO: using the worldScale would be more correct here, but as we don't want to calculate it
                // only for this test, use the local scale
				// vec2.multiply( dimensions, dimensions, transforms[ entityId ].scale )
			}

			return dimensions
		}

		/**
		 * Sets the attribute of a component to the specified value.
		 *
		 * @private
		 * @param component
		 * @param attributeId
		 * @param value
		 */
		var setAttribute = function( component, attributeId, value ) {
			// TODO: Unfortunately there is no generic copy operator in javascript.
			if( _.isObject( value ) ||
				_.isArray( value ) ) {
				_.extend( component[ attributeId ], value )

			} else {
				component[ attributeId ] = value
			}
		}

		var updateComponentAttributeTM = function( assetManager, moduleLoader, componentsWithAssets, componentId, attributeId, component, value ) {
			setAttribute( component, attributeId, value )

			if( componentsWithAssets[ componentId ] ) {
				var assetIdChanged = attributeId === 'assetId'

				if( assetIdChanged ) {
					injectAsset( assetManager, moduleLoader, component )
				}
			}
		}

		var updateComponentTM = function( assetManager, moduleLoader, componentsWithAssets, componentId, component, attributeConfig ) {
			for( var attributeId in attributeConfig ) {
				setAttribute( component, attributeId, attributeConfig[ attributeId ] )
			}

			if( componentsWithAssets[ componentId ] ) {
				var assetIdChanged = !!attributeConfig[ 'assetId' ]

				if( assetIdChanged ) {
					injectAsset( assetManager, moduleLoader, component )
				}
			}
		}

		var bubbleEventR = function( spell, compositeComponents, eventHandlersComponents, entityId, eventId, eventArguments ) {
			var eventHandlersComponent = eventHandlersComponents[ entityId ]

			if( eventHandlersComponent ) {
				var scriptInstance = eventHandlersComponent.asset

				if( scriptInstance ) {
					var eventHandler = eventHandlersComponent.asset[ eventId ]

					if( eventHandler ) {
						eventHandler.apply( null, [ spell, entityId ].concat( eventArguments ) )

						return
					}
				}
			}

			var nearestEntityId = getAncestorId( compositeComponents, eventHandlersComponents, entityId )
			if( !nearestEntityId ) return

			bubbleEventR( spell, compositeComponents, eventHandlersComponents, nearestEntityId, eventId, eventArguments )
		}

		var EntityManager = function( spell, configurationManager, assetManager, eventManager, libraryManager, moduleLoader ) {
			this.configurationManager = configurationManager
			this.componentMaps        = {}
			this.assetManager         = assetManager
			this.eventManager         = eventManager
			this.libraryManager       = libraryManager
			this.moduleLoader         = moduleLoader
			this.spell                = spell
			this.componentsWithAssets = {}
			this.deferredEvents       = new LinkedList()
		}

		EntityManager.prototype = {
			/**
			 * Creates an entity using the given configuration object.
			 *
			 * Available configuration options are:
			 *
			 * * **entityTemplateId** [String] - if the entity should be constructed using an entity template you can specify the library path to the entity template here
			 * * **config** [Object] - component configuration for this entity. It can also be used to partially override an entity template config
			 * * **children** [Array] - if this entity has children, an array of nested config objects can be specified here
			 * * **id** [String] - if specified the entity will be created using this id. Please note: you should not use this function unless you know what you're doing. Normally the engine assigns entityIds automatically.
			 * * **name** [String] - a name for this entity. If specified, you can use the {@link #getEntityIdsByName} function to lookup named entities to their entityIds
			 *
			 * Example:
			 *
			 *     // create a new entity with the given components
			 *     var entityId = spell.entityManager.createEntity({
			 *         config: {
			 *             "spell.component.2d.transform": {
			 *                 "translation": [ 100, 200 ]
			 *             },
			 *             "spell.component.visualObject": {
			 *               // if no configuration is specified the default values of this component will be used
			 *             },
			 *             "spell.component.2d.graphics.appearance": {
			 *                 "assetId": "appearance:library.identifier.of.my.static.appearance"
			 *             }
			 *         }
			 *     })
			 *
			 *     // create a new entity with child entities
			 *     var entityId = spell.entityManager.createEntity({
			 *         config: {
			 *             "spell.component.2d.transform": {
			 *                 "translation": [ 100, 200 ]
			 *             },
			 *             "spell.component.visualObject": {
			 *               // if no configuration is specified the default values of this component will be used
			 *             },
			 *             "spell.component.2d.graphics.appearance": {
			 *                 "assetId": "appearance:library.identifier.of.my.static.appearance"
			 *             }
			 *         },
			 *         children: [
			 *             {
			 *                 config: {
			 *                     "spell.component.2d.transform": {
			 *                         "translation": [ -15, 20 ] // translation is relative to the parent
			 *                     },
			 *                     "spell.component.visualObject": {
			 *                       // if no configuration is specified the default values of this component will be used
			 *                     },
			 *                     "spell.component.2d.graphics.appearance": {
			 *                         "assetId": "appearance:library.identifier.of.my.other.static.appearance"
			 *                     }
			 *                 }
			 *             }
			 *         ]
			 *     })
			 *
			 *     // create a new entity from an entity template
			 *     var entityId = spell.entityManager.createEntity({
			 *         entityTemplateId: 'library.identifier.of.my.template'
			 *     })
			 *
			 *     // create a new entity from an entity template and override values from the template
			 *     var entityId = spell.entityManager.createEntity({
			 *         entityTemplateId: 'library.identifier.of.my.template',
			 *         config: {
			 *             "test.simpleBox": {
			 *                 "dimensions": [ 100, 100 ]
			 *              },
			 *              "spell.component.2d.transform": {
			 *                  "translation": [ 150, 50 ]
			 *               }
			 *         }
			 *     })
			 *
			 * @param {Object} entityConfig an entity configuration object
			 * @return {String} the entity id of the newly created entity
			 */
			createEntity : function( entityConfig ) {
				return createEntity(
					this.spell,
					this.assetManager,
					this.eventManager,
					this.libraryManager,
					this.moduleLoader,
					this.componentMaps,
					entityConfig
				)
			},

			/**
			 * Creates entities from a list of entity configs.
			 *
			 * See {@link #createEntity} function for a documentation of the entity config object.
			 *
			 * @param {Array} entityConfigs
			 */
			createEntities : function( entityConfigs ) {
				for( var i = 0, n = entityConfigs.length; i < n; i++ ) {
					this.createEntity( entityConfigs[ i ] )
				}
			},

			/**
			 * Removes an entity
			 *
			 * @param {String} entityId the id of the entity to remove
			 */
			removeEntity : function( entityId ) {
				if( !entityId ) {
					return false
				}

				removeEntity( this.eventManager, this.componentMaps, entityId )

				return true
			},

			/**
			 * Creates an exact copy of the given entityId
			 * @param entityId
			 */
			cloneEntity: function( entityId ) {
				var entityConfig = {
					config : assembleEntityInstance( this.componentMaps, entityId )
				}

				return createEntity( this.spell, this.assetManager, this.eventManager, this.libraryManager, this.moduleLoader, this.componentMaps, entityConfig )
			},


			/**
			 * Returns the width and height for a given entity
			 * @param entityId
			 * @return vec2 2d-vector containing the dimension
			 */
			getEntityDimensions: function( entityId ) {
				return getEntityDimensions( this.componentMaps, entityId )
			},


			/**
			 * Returns an array of ids of entities which have the requested name.
			 *
			 * @param {String} name the name of the entity
			 * @param {String} scopeEntityId the scope of the search is limited to this entity and its descendants
			 * @return {Array}
			 */
			getEntityIdsByName : function( name, scopeEntityId ) {
				var componentMaps      = this.componentMaps,
					metaDataComponents = componentMaps[ METADATA_COMPONENT_ID ],
					resultIds          = []

				var ids = scopeEntityId ?
					getEntityCompositeIds( componentMaps[ COMPOSITE_COMPONENT_ID ], scopeEntityId, [] ) :
					_.keys( metaDataComponents )

				for( var i = 0, n = ids.length; i < n; i++ ) {
					var nameComponentId = ids[ i ]

					if( metaDataComponents[ nameComponentId ] && metaDataComponents[ nameComponentId ][ 'name' ] === name ) {
						resultIds.push( nameComponentId )
					}
				}

				return resultIds
			},

			/**
			 * Initializes the entity manager.
			 */
			init : function() {
				// create root entity
				var entityConfig = {
					id : ROOT_ENTITY_ID,
					parentId : INVALID_ENTITY_ID
				}

				createEntity( this.spell, this.assetManager, this.eventManager, this.libraryManager, this.moduleLoader, this.componentMaps, entityConfig )
            },

			/**
			 * Destroys the entity manager. Frees all internal resources.
			 */
			destroy : function() {
				this.removeEntity( ROOT_ENTITY_ID )
				this.deferredEvents.clear()
			},

			/**
			 * Changes the parent of the specified entity.
			 *
			 * Example:
			 *
			 *     // make entity A the child of entity B
			 *     spell.entityManager.changeParentEntity( aId, bId )
			 *
			 *     // make entity A a root entity, that is it has no parent
			 *     spell.entityManager.changeParentEntity( aId )
			 *
			 * @param entityId the id of the entity which gets reassigned
			 * @param newParentEntityId the id of the entity which will be the parent entity
			 */
			changeParentEntity : function( entityId, newParentEntityId ) {
				if( !entityId ) throw 'Error: Missing entity id.'

				this.updateComponent( entityId, COMPOSITE_COMPONENT_ID, { parentId : newParentEntityId } )
			},

			/**
			 * Check if an entity already has a specific component
			 *
			 * @param {String} entityId of the entity that the component belongs to
			 * @param {String} componentId the library path of the component
			 * @return {Boolean}
			 */
			hasComponent : function( entityId, componentId ) {
				var componentMap = this.componentMaps[ componentId ]
				if( !componentMap ) return false

				return !!componentMap[ entityId ]
			},

			/**
			 * Adds a component to an entity.
			 *
			 * Example:
			 *
			 *     // add a component with it's default configuration to this entity
			 *     spell.entityManager.addComponent( entityId, "spell.component.2d.graphics.shape.rectangle" )
			 *
			 *     // add a component to this entity and override a default value
			 *     spell.entityManager.addComponent(
			 *         entityId,
			 *         "spell.component.2d.graphics.textApperance",
			 *         {
			 *             "text": "Hello World"
			 *         }
			 *     )
			 *
			 * @param {String} entityId of the entity that the component belongs to
			 * @param {String} componentId the library path of the component to add
			 * @param {Object} attributeConfig the attribute configuration of the component
			 */
			addComponent : function( entityId, componentId, attributeConfig ) {
				if( !entityId ) throw 'Error: Missing entity id.'
				if( !componentId ) throw 'Error: Missing component id.'

				var componentConfigs = {}
				componentConfigs[ componentId ] = attributeConfig || {}

				addComponents(
					this.componentMaps,
					this.eventManager,
					entityId,
					createComponents( this.spell, this.assetManager, this.libraryManager, this.moduleLoader, componentConfigs )
				)
			},

			/**
			 * Removes a component from an entity.
			 *
			 * @param {String} entityId the id of the entity that the component belongs to
			 * @param {String} componentId the library path of the component to remove
			 */
			removeComponent : function( entityId, componentId ) {
				if( !entityId ) throw 'Error: Missing entity id.'

				var eventManager  = this.eventManager,
					componentMaps = this.componentMaps

				removeComponent( eventManager, componentMaps, componentId, entityId )

				if( !entityExists( componentMaps, entityId ) ) {
					eventManager.publish( eventManager.EVENT.ENTITY_REMOVED, entityId )
				}
			},

			/**
			 * Returns a component from a specific entity.
			 *
			 * @param {String} entityId the id of the requested entity
			 * @param {String} componentId the requested component id
			 * @return {Object}
			 */
			getComponentById : function( entityId, componentId ) {
				var componentMap = this.componentMaps[ componentId ]

				return componentMap ? componentMap[ entityId ] : undefined
			},

			/**
			 * Returns a collection of components which have the requested component id and belong to entities which have the requested name.
			 *
			 * @param {String} componentId the requested component id
			 * @param {String} name the requested entity name
			 * @param {String} scopeEntityId the scope of the search is limited to this entity and its descendants
			 * @return {Object}
			 */
			getComponentsByName : function( componentId, name, scopeEntityId ) {
				var componentMap = this.getComponentMapById( componentId ),
					ids          = this.getEntityIdsByName( name, scopeEntityId )

				if( ids.length === 0 ||
					!componentMap ) {

					return []
				}

				return _.pick( componentMap, ids )
			},

			/**
			 * Updates the attributes of a component. Returns true when successful, false otherwise.
			 *
			 * Example:
			 *     // update a component of an entity
			 *     spell.entityManager.updateComponent(
			 *         entityId,
			 *         "spell.component.2d.graphics.appearance",
			 *         {
			 *             assetId : "appearance:library.identifier.of.my.static.appearance"
			 *         }
			 *     )
			 *
			 * @param {String} entityId the id of the entity which the component belongs to
			 * @param {String} componentId the library path of the component
			 * @param {Object} attributeConfig the attribute configuration change of the component
			 * @return {Boolean} true if the component could be found, false otherwise
			 */
			updateComponent : function( entityId, componentId, attributeConfig ) {
				var componentMaps = this.componentMaps,
					components    = componentMaps[ componentId ],
					component     = components[ entityId ]

				if( !component ) return false

				// HACK: create a partial clone of the component
				var oldComponentState = {}

				for( var attributeId in attributeConfig ) {
					oldComponentState[ attributeId ] = deepClone( component[ attributeId ] )
				}

				updateComponentTM( this.assetManager, this.moduleLoader, this.componentsWithAssets, componentId, component, attributeConfig )

				var eventManager  = this.eventManager

				if( componentId === COMPOSITE_COMPONENT_ID ) {
					removeFromParentEntity( components, entityId, oldComponentState.parentId )
					addToParentEntity( components, entityId, component.parentId )
					updateWorldTransform( componentMaps, eventManager, entityId )
					updateVisualObject( componentMaps, entityId )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					if( attributeConfig.translation ||
						attributeConfig.scale ||
						attributeConfig.rotation !== undefined ) {

						updateWorldTransform( componentMaps, eventManager, entityId )
					}

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					if( attributeConfig.translation ||
						attributeConfig.scale ||
						attributeConfig.rotation ) {

						updateTextureMatrix( componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
					}

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish( [ eventManager.EVENT.COMPONENT_UPDATED, componentId ], [ component, entityId ] )

				return true
			},

			/**
			 * Updates one attribute of a component. Returns true when successful, false otherwise.
			 *
			 * Example:
			 *     // update a specific attribute of a component of an entity
			 *     spell.entityManager.updateComponentAttribute(
			 *         entityId,
			 *         "spell.component.2d.transform",
			 *         "translation",
			 *         [ 10, 10 ]
			 *     )
			 *
			 * @param {String} entityId the id of the entity which the component belongs to
			 * @param {String} componentId the library path of the component
			 * @param {String} attributeId the id of the attribute
			 * @param {Object} value the value of the attribute
			 * @return {Boolean} true if the component could be found, false otherwise
			 */
			updateComponentAttribute : function( entityId, componentId, attributeId, value ) {
				var componentMaps = this.componentMaps,
					components    = componentMaps[ componentId ],
					component     = components[ entityId ]

				if( !component ) return false

				var oldAttributeValue = component[ attributeId ]
				if( oldAttributeValue === undefined ) return false

				updateComponentAttributeTM( this.assetManager, this.moduleLoader, this.componentsWithAssets, componentId, attributeId, component, value )

				var eventManager  = this.eventManager

				if( componentId === COMPOSITE_COMPONENT_ID &&
					attributeId === 'parentId' ) {

					removeFromParentEntity( components, entityId, oldAttributeValue )
					addToParentEntity( components, entityId, value )
					updateWorldTransform( componentMaps, eventManager, entityId )
					updateVisualObject( componentMaps, entityId )

				} else if( componentId === TRANSFORM_COMPONENT_ID ) {
					if( attributeId === 'translation' ||
						attributeId === 'scale' ||
						attributeId === 'rotation' ) {

						updateWorldTransform( componentMaps, eventManager, entityId )
					}

				} else if( componentId === TEXTURE_MATRIX_COMPONENT_ID ) {
					if( attributeId === 'translation' ||
						attributeId === 'scale' ||
						attributeId === 'rotation' ) {

						updateTextureMatrix( componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
					}

				} else if( componentId === VISUAL_OBJECT_COMPONENT_ID ) {
					updateVisualObject( componentMaps, entityId )
				}

				eventManager.publish( [ eventManager.EVENT.COMPONENT_UPDATED, componentId ], [ component, entityId ] )

				return true
			},

			/**
			 * Returns a component map of a specific type.
			 *
			 * @param {String} componentId the requested component type / id
			 * @return {*}
			 */
			getComponentMapById : function( componentId ) {
				return this.componentMaps[ componentId ]
			},

			updateWorldTransform : function( entityId ) {
				updateWorldTransform( this.componentMaps, this.eventManager, entityId )
				this.spell.visibilityManager.updateEntity( entityId )
			},

			updateTextureMatrix : function( entityId ) {
				updateTextureMatrix( this.componentMaps[ TEXTURE_MATRIX_COMPONENT_ID ][ entityId ] )
			},

			/**
			 * Updates all components which reference the asset with the updated asset instance.
			 *
			 * @param assetId
			 * @param asset
			 * @private
			 */
			updateAssetReferences : function( assetId, asset ) {
				var componentMaps = this.componentMaps

				for( var componentId in this.componentsWithAssets ) {
					var componentMap = componentMaps[ componentId ]

					for( var id in componentMap ) {
						var component = componentMap[ id ]

						if( component.assetId === assetId ) {
							component.asset = asset
						}
					}
				}
			},

			/**
			 * Refreshes all references to assets that components hold
			 *
			 * @private
			 * @param assetManager
			 */
			refreshAssetReferences : function( assetManager ) {
				var componentMaps = this.componentMaps

				for( var componentId in this.componentsWithAssets ) {
					var componentMap = componentMaps[ componentId ]

					for( var id in componentMap ) {
						var component = componentMap[ id ]

						if( component.assetId.slice( 0, component.assetId.indexOf( ':' ) ) === 'script' ) {
							continue
						}

						component.asset = assetManager.get( component.assetId )
					}
				}
			},

			/**
			 * Triggers an event on the specified entity.
			 *
			 * @param entityId
			 * @param eventId
			 * @param eventArguments
			 * @param timerInMs
			 * @param timerCondition
			 */
			triggerEvent : function( entityId, eventId, eventArguments, timerInMs, timerCondition ) {
				if( timerInMs ) {
					this.deferredEvents.append( new DeferredEvent( entityId, eventId, eventArguments, timerInMs, timerCondition ) )

				} else {
					var componentMaps = this.componentMaps

					bubbleEventR(
						this.spell,
						componentMaps[ COMPOSITE_COMPONENT_ID ],
						componentMaps[ EVENT_HANDLERS_COMPONENT_ID ],
						entityId,
						eventId,
						eventArguments
					)
				}
			},

			updateEntityTemplate : function( entityDefinition ) {
				var entityTemplateId = createId( entityDefinition.namespace, entityDefinition.name )

				// get ids of entities which are based on this entity template
				var ids = _.reduce(
					this.componentMaps[ METADATA_COMPONENT_ID ],
					function( memo, component, entityId ) {
						if( component.entityTemplateId === entityTemplateId ) {
							memo.push( entityId )
						}

						return memo
					},
					[]
				)

				for( var i = 0, id, n = ids.length; i < n; i++ ) {
					id = ids[ i ]

					// remove entities
					this.removeEntity( id )

					// recreate entities while using old ids
					this.createEntity( {
						entityTemplateId : entityTemplateId,
						id : id
					} )
				}
			},

			/**
			 * Registers the component specified by componentDefition. Components must be registered with this method before they can be used.
			 *
			 * @private
			 * @param componentDefinition
			 */
			registerComponent : function( componentDefinition ) {
				var componentId = createId( componentDefinition.namespace, componentDefinition.name )

				if( !isValidComponentDefinition( componentDefinition ) ) {
					throw 'Error: The format of the supplied component definition "' + componentId + '" is invalid.'
				}

				if( !this.componentMaps[ componentId ] ) {
					this.componentMaps[ componentId ] = {}
				}

				if( hasAssetIdAttribute( componentDefinition.attributes ) ) {
					this.componentsWithAssets[ componentId ] = true

				} else {
					delete this.componentsWithAssets[ componentId ]
				}
			},

			updateDeferredEvents : function( deltaTimeInMs ) {
				var deferredEvents = this.deferredEvents,
					iterator       = deferredEvents.createIterator(),
					node,
					deferredEvent

				while( node = iterator.next() ) {
					deferredEvent = node.data

					if( deferredEvent.ready( deltaTimeInMs ) ) {
						iterator.remove()
						deferredEvent.trigger( this )
					}
				}

			}
		}

		return EntityManager
	}
)

define(
	'spell/shared/util/Timer',
	[
		'spell/shared/util/platform/Types',

		'spell/functions'
	],
	function(
		Types,

		_
	) {
		'use strict'


		/*
		 * private
		 */

//		var checkTimeWarp = function( newRemoteTime, updatedRemoteTime ) {
//			if( updatedRemoteTime > newRemoteTime ) return
//
//			var tmp = newRemoteTime - updatedRemoteTime
//			console.log( 'WARNING: clock reset into past by ' + tmp + ' ms' )
//		}

		var getCurrentTimeInMs = Types.Time.getCurrentInMs

		/*
		 * public
		 */

		var Timer = function( eventManager, statisticsManager, initialTime ) {
			this.newRemoteTime        = initialTime
			this.remoteTime           = initialTime
			this.newRemoteTimPending  = false
			this.localTime            = initialTime
			this.previousSystemTime   = getCurrentTimeInMs()
			this.elapsedTime          = 0
			this.deltaLocalRemoteTime = 0
			this.statisticsManager    = statisticsManager

			eventManager.subscribe(
				[ 'clockSyncUpdate' ],
				_.bind(
					function( updatedRemoteTime ) {
//						checkTimeWarp( newRemoteTime, updatedRemoteTime )

						this.newRemoteTime = updatedRemoteTime
						this.newRemoteTimPending = true
					},
					this
				)
			)

			eventManager.subscribe(
				eventManager.EVENT.CLOCK_SYNC_ESTABLISHED,
				_.bind(
					function( initialRemoteGameTimeInMs ) {
						this.newRemoteTime = this.remoteTime = this.localTime = initialRemoteGameTimeInMs
						this.newRemoteTimPending = false
					},
					this
				)
			)

			// setting up statistics
//			statisticsManager.addSeries( 'remoteTime', '' )
//			statisticsManager.addSeries( 'localTime', '' )
//			statisticsManager.addSeries( 'deltaLocalRemoteTime', '' )
//			statisticsManager.addSeries( 'relativeClockSkew', '' )
//			statisticsManager.addSeries( 'newRemoteTimeTransfered', '' )
		}

		Timer.prototype = {
			update : function() {
				// TODO: think about incorporating the new value 'softly' instead of directly replacing the old one
				if( this.newRemoteTimPending ) {
					this.remoteTime          = this.newRemoteTime
					this.newRemoteTimPending = false
				}

				// measuring time
				var systemTime            = getCurrentTimeInMs()
				this.elapsedTime          = Math.max( systemTime - this.previousSystemTime, 0 ) // it must never be smaller than 0
				this.previousSystemTime   = systemTime

				this.localTime            += this.elapsedTime
				this.remoteTime           += this.elapsedTime
				this.deltaLocalRemoteTime = this.localTime - this.remoteTime

				// relative clock skew
				var factor = 1000000000
				this.relativeClockSkew = ( ( this.localTime / this.remoteTime * factor ) - factor ) * 2 + 1

				// updating statistics
//				this.statisticsManager.updateSeries( 'remoteTime', this.remoteTime % 2000 )
//				this.statisticsManager.updateSeries( 'localTime', this.localTime % 2000 )
//				this.statisticsManager.updateSeries( 'deltaLocalRemoteTime', this.deltaLocalRemoteTime + 250 )
//				this.statisticsManager.updateSeries( 'relativeClockSkew', this.relativeClockSkew )
			},
			getLocalTime : function() {
				return this.localTime
			},
			getElapsedTime : function() {
				return this.elapsedTime
			},
			getRemoteTime : function() {
				return this.remoteTime
			}//,
//			getDeltaLocalRemoteTime : function() {
//				return deltaRemoteLocalTime
//			},
//			getRelativeClockSkew : function() {
//				return relativeClockSkew
//			}
		}

		return Timer
	}
)

define(
	'spell/shared/util/StopWatch',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		var getCurrentTimeInMs = Types.Time.getCurrentInMs

		var StopWatch = function() {
			this.value = 0
		}

		StopWatch.prototype = {
			start : function() {
				this.value = getCurrentTimeInMs()
			},
			stop : function() {
				return getCurrentTimeInMs() - this.value
			}
		}

		return StopWatch
	}
)

define(
	'spell/data/Tree',
	function() {
		'use strict'


		var getNode = function( currentNode, parentId ) {
			var children = currentNode.children

			if( currentNode.id === parentId ) {
				return currentNode

			} else {
				for( var i = 0, numChildren = children.length; i < numChildren; i++ ) {
					var node = getNode( children[ i ], parentId )

					if( node ) return node
				}
			}
		}

		var addNode = function( currentNode, parentId, newNode ) {
			var parentNode = getNode( currentNode, parentId )

			if( parentNode ) {
				parentNode.children.push( newNode )

				return true
			}

			return false
		}

		var eachNode = function( currentNode, iter, depth ) {
			if( !currentNode ) return
			if( !depth ) depth = 0

			iter( currentNode, depth )

			var children = currentNode.children

			for( var i = 0, numChildren = children.length, nextDepth = depth + 1; i < numChildren; i++ ) {
				eachNode( children[ i ], iter, nextDepth )
			}
		}

		return {
			addNode : addNode,
			getNode : getNode,
			eachNode : eachNode
		}
	}
)

define(
	'spell/shared/util/createMainLoop',
	[
		'spell/data/Tree',
		'spell/shared/util/StopWatch',
		'spell/shared/util/Timer',
		'spell/shared/util/platform/Types',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		Tree,
		StopWatch,
		Timer,
		Types,
		PlatformKit,

		_
	) {
		'use strict'


		var UPDATE_INTERVAL_IN_MS  = 32,
			MAX_ELAPSED_TIME_IN_MS = 100,
			PERFORMANCE_PRINT_INTERVAL_IN_MS = 10000

		var eachNode = Tree.eachNode

		var indent = function( n ) {
			var result = ''

			while( n-- ) {
				result += ' '
			}

			return result
		}

		var createMetricsMessage = function( tree ) {
			var message = ''

			eachNode(
				tree,
				function( node, depth ) {
					var metrics = node.metrics

					message += indent( depth ) + node.id + ': ' + metrics[ 0 ] + '/' + metrics[ 1 ] + '/' + metrics[ 2 ] + '/' + metrics[ 3 ] + '\n'
				}
			)

			return message
		}

		var callEveryFrameRelease = function( currentTimeInMs ) {
			if( this.preNextFrame.length > 0 ) {
				this.preNextFrame.pop()()
			}

			var timer = this.timer

			timer.update()

			var updateIntervalInMs = this.updateIntervalInMs,
				localTimeInMs      = timer.getLocalTime(),
				elapsedTimeInMs    = Math.min( timer.getElapsedTime(), MAX_ELAPSED_TIME_IN_MS )

			if( this.update ) {
				var accumulatedTimeInMs = this.accumulatedTimeInMs + elapsedTimeInMs

				while( accumulatedTimeInMs >= updateIntervalInMs ) {
					this.update( localTimeInMs, updateIntervalInMs )

					accumulatedTimeInMs -= updateIntervalInMs
				}

				this.accumulatedTimeInMs = accumulatedTimeInMs
			}

			if( this.render ) {
				this.render( localTimeInMs, elapsedTimeInMs )
			}

			PlatformKit.callNextFrame( this.callEveryFramePartial )
		}

		var callEveryFrameDebug = function( currentTimeInMs ) {
			if( this.isPaused ) return

			if( this.preNextFrame.length > 0 ) {
				this.preNextFrame.pop()()
			}

			var statisticsManager = this.statisticsManager,
				timer             = this.timer

			timer.update()

			var updateIntervalInMs = this.updateIntervalInMs,
				localTimeInMs      = timer.getLocalTime(),
				elapsedTimeInMs    = Math.min( timer.getElapsedTime(), MAX_ELAPSED_TIME_IN_MS )

			this.totalStopWatch.start()
			statisticsManager.startTick( localTimeInMs, elapsedTimeInMs )

			if( this.update ) {
				this.stopWatch.start()

				var accumulatedTimeInMs = this.accumulatedTimeInMs + elapsedTimeInMs

				while( accumulatedTimeInMs >= updateIntervalInMs ) {
					this.update( localTimeInMs, updateIntervalInMs )

					accumulatedTimeInMs -= updateIntervalInMs
				}

				this.accumulatedTimeInMs = accumulatedTimeInMs

				statisticsManager.updateNode( 'update', this.stopWatch.stop() )
			}

			if( this.render ) {
				this.stopWatch.start()

				this.render( localTimeInMs, elapsedTimeInMs )

				statisticsManager.updateNode( 'render', this.stopWatch.stop() )
			}

			statisticsManager.updateNode( 'total', this.totalStopWatch.stop() )

			// print performance statistics
			if( this.timeSinceLastPerfPrintInMs > PERFORMANCE_PRINT_INTERVAL_IN_MS ) {
				this.timeSinceLastPerfPrintInMs -= PERFORMANCE_PRINT_INTERVAL_IN_MS

//				console.log(
//					createMetricsMessage( statisticsManager.getMetrics( PERFORMANCE_PRINT_INTERVAL_IN_MS ) )
//				)
			}

			this.timeSinceLastPerfPrintInMs += elapsedTimeInMs

			PlatformKit.callNextFrame( this.callEveryFramePartial )
		}


		var MainLoop = function( eventManager, statisticsManager, isDebug, updateIntervalInMs ) {
			this.isDebug             = isDebug
			this.updateIntervalInMs  = updateIntervalInMs || UPDATE_INTERVAL_IN_MS
			this.render              = null
			this.update              = null
			this.preNextFrame        = []
			this.accumulatedTimeInMs = this.updateIntervalInMs

			// Until the proper remote game time is computed local time will have to do.
			var initialLocalGameTimeInMs = Types.Time.getCurrentInMs()
			this.timer = new Timer( eventManager, statisticsManager, initialLocalGameTimeInMs )

			this.timeSinceLastPerfPrintInMs = 0
			this.statisticsManager = statisticsManager
			this.stopWatch         = new StopWatch()
			this.totalStopWatch    = new StopWatch()
			this.isPaused          = false
		}

		MainLoop.prototype = {
			setRenderCallback : function( f ) {
				this.render = f
			},
			setUpdateCallback : function( f ) {
				this.update = f
			},
			setPreNextFrame: function( f ) {
				this.preNextFrame.push( f )
			},
			run : function() {
				this.callEveryFramePartial = _.bind( this.isDebug ? callEveryFrameDebug : callEveryFrameRelease, this )
				this.callEveryFramePartial( Types.Time.getCurrentInMs() )
			},
			pause : function() {
				this.isPaused = true
			},
			resume : function() {
				this.isPaused = false
			}
		}

		return function( eventManager, statisticsManager, isDebug, updateInterval ) {
			return new MainLoop( eventManager, statisticsManager, isDebug, updateInterval )
		}
	}
)

define(
	'spell/client/showSplashScreen',
	[
		'spell/math/mat3',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec4',
		'spell/shared/util/platform/PlatformKit'
	],
	function(
		mat3,
		mathUtil,
		vec2,
		vec4,
		PlatformKit
	) {
		'use strict'


		var createRGB = function( dataRGBA ) {
			var numPixels = dataRGBA.length / 4,
				dataRGB   = new Array( numPixels * 3 )

			for( var i = 0, srcOffset, dstOffset, n = numPixels; i < n; i ++ ) {
				srcOffset = i * 4
				dstOffset = i * 3

				dataRGB[ dstOffset ]     = dataRGBA[ srcOffset ]
				dataRGB[ dstOffset + 1 ] = dataRGBA[ srcOffset + 1 ]
				dataRGB[ dstOffset + 2 ] = dataRGBA[ srcOffset + 2 ]
			}

			return dataRGB
		}

		return function( spell, next ) {
			var splashScreenImage = PlatformKit.createSplashScreenImage()

			if( splashScreenImage ) {
				var splashTexture = spell.renderingContext.createTexture( splashScreenImage ),
					screenSize    = spell.configurationManager.getValue( 'currentScreenSize' )

				var position = vec2.fromValues(
					Math.round( screenSize[ 0 ] * 0.5 - splashTexture.dimensions[ 0 ] * 0.5 ),
					Math.round( screenSize[ 1 ] * 0.5 - splashTexture.dimensions[ 1 ] * 0.5 )
				)

				var context    = spell.renderingContext,
					tmpMat3    = mat3.create(),
					clearColor = vec4.fromValues( 0, 0, 0, 1 )

				mathUtil.mat3Ortho( tmpMat3, 0.0, screenSize[ 0 ], 0.0, screenSize[ 1 ] )

				context.setViewMatrix( tmpMat3 )
				context.setClearColor( clearColor )
				context.resizeColorBuffer( screenSize[ 0 ], screenSize[ 1 ] )
				context.viewport( 0, 0, screenSize[ 0 ], screenSize [ 1 ] )

				context.drawTexture( splashTexture, position, splashTexture.dimensions, null )

				PlatformKit.registerTimer( next, 3000 )

			} else {
				next()
			}
		}
	}
)

/**
 * @class spell.stringUtil
 * @singleton
 */
define(
	'spell/stringUtil',
	function() {
		'use strict'


		var stringUtil = {}

		stringUtil.startsWith = function( x, prefix ) {
			if( prefix === '' ) return true
			if( !x || !prefix ) return false

			return String( x ).lastIndexOf( String( prefix ), 0 ) === 0
		}

		return stringUtil
	}
)

/**
 * @class spell.recurisveFunctions
 * @singleton
 */
define(
	'spell/recursiveFunctions',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		/**
		 * Performs a recursive walk over all properties of the supplied object. The "object" argument can be either of type object or array. The iterator
		 * argument is called with the arguments "value" and "key" for every property that is encountered on the walk.
		 *
		 * @param {*} object data structure to work on
		 * @param {Function} iterator
		 */
		var walk = function( object, iterator ) {
			for( var key in object ) {
				var value = object[ key ]

				if( _.isObject( value ) ) {
					walk( value, iterator )

				} else {
					iterator( value, key )
				}
			}
		}

		var reduce = function( object, iterator, memo ) {
			var wrapper = function( value, key ) {
				memo = iterator( memo, value, key )
			}

			walk( object, wrapper )

			return memo
		}

		/**
		 * Performs a recursive pluck. All keys of the supplied object argument which are encountered during a recursive walk are checked for their existence
		 * in the properties argument array. If a match is found it is stored in the result array.
		 *
		 * @param {*} object data structure to work on
		 * @param {Array} properties array of strings
		 * @return {Array}
		 */
		var pluck = function( object, properties ) {
			var result = []

			walk(
				object,
				function( key, value ) {
					if( !_.contains( properties, key ) ) return

					result.push( value )
				}
			)

			return result
		}

		return {
			pluck  : pluck,
			reduce : reduce,
			walk   : walk
		}
	}
)

define(
	'spell/client/util/createComprisedRectangle',
	function() {
		'use strict'


		/**
		 * Returns a screen size that has the supplied aspect ratio and comprises the supplied screen dimensions.
		 *
		 * For example:
		 *
		 *   createComprisedRectangle( [ 120, 90 ], 16/9 )
		 *   => [ 160, 90 ]
		 */
		return function( dimensions, requestedAspectRatio, round ) {
			var width              = dimensions[ 0 ],
				height             = dimensions[ 1 ],
				currentAspectRatio = width / height

			if( requestedAspectRatio >= currentAspectRatio ) {
				// screen has additional space left horizontally
				width = requestedAspectRatio * height

			} else {
				// screen has additional space left vertically
				height = width / requestedAspectRatio
			}

			if( round ) {
				width  = Math.round( width )
				height = Math.round( height )
			}

			return [ width, height ]
		}
	}
)

define(
	'spell/client/util/createEffectiveCameraDimensions',
	[
		'spell/client/util/createComprisedRectangle',

		'spell/math/vec2'
	],
	function(
		createComprisedRectangle,

		vec2
	) {
		'use strict'


		return function( cameraWidth, cameraHeight, cameraScale, aspectRatio ) {
			var tmpVec2 = vec2.fromValues( cameraWidth, cameraHeight )

			return vec2.multiply(
				tmpVec2,
				cameraScale,
				createComprisedRectangle( tmpVec2, aspectRatio )
			)
		}
	}
)

define(
	'spell/shared/util/translate',
	function() {
		'use strict'


		return function( assetManager, currentLanguage, translationAssetId, text ) {
			if( !translationAssetId ) return

			var translation = assetManager.get( translationAssetId )
			if( !translation ) return

			var translatedText = translation.config[ text ]
			if( !translatedText ) return

			return translatedText[ currentLanguage ]
		}
	}
)

define(
	'spell/shared/util/createEntityEach',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( primaryComponents, argumentComponents, iterator ) {
			if( !_.isArray( argumentComponents ) ) {
				argumentComponents = [ argumentComponents ]
			}

			return function() {
				var ids    = _.keys( primaryComponents ),
					numIds = ids.length

				for( var i = 0; i < numIds; i++ ) {
					var id = ids[ i ],
						primaryComponent = [ primaryComponents[ id ] ],
						numArgumentComponentsList = argumentComponents.length,
						args = ( arguments ? _.toArray( arguments ).concat( primaryComponent ) : [ primaryComponent ] )

					for( var j = 0; j < numArgumentComponentsList; j++ ) {
						args.push( argumentComponents[ j ][ id ] )
					}

					iterator.apply( null, args )
				}
			}
		}
	}
)

/**
 * @license
 * @preserve
 *
 * The MIT License
 *
 * Copyright (c) 2010-2012 Tween.js authors.
 *
 * Easing equations Copyright (c) 2001 Robert Penner http://robertpenner.com/easing/
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

define(
	'spell/shared/Easing',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var none = function( k ) {
			return k < 1.0 ? 0.0 : 1.0
		}

		var Easing = {
			// None
			None : none,

			// Linear
			Linear : _.identity,

			// Quadratic
			QuadraticIn : function( k ) {
				return k * k
			},
			QuadraticOut : function( k ) {
				return k * ( 2 - k )
			},
			QuadraticInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k
				return - 0.5 * ( --k * ( k - 2 ) - 1 )
			},

			// Cubic
			CubicIn : function( k ) {
				return k * k * k
			},
			CubicOut : function( k ) {
				return --k * k * k + 1
			},
			CubicInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k
				return 0.5 * ( ( k -= 2 ) * k * k + 2 )
			},

			// Quartic
			QuarticIn : function( k ) {
				return k * k * k * k
			},
			QuarticOut : function( k ) {
				return 1 - --k * k * k * k
			},
			QuarticInOut : function( k ) {
				if ( ( k *= 2 ) < 1) return 0.5 * k * k * k * k
				return - 0.5 * ( ( k -= 2 ) * k * k * k - 2 )
			},

			// Quintic
			QuinticIn : function( k ) {
				return k * k * k * k * k
			},
			QuinticOut : function( k ) {
				return --k * k * k * k * k + 1
			},
			QuinticInOut : function( k ) {
				if ( ( k *= 2 ) < 1 ) return 0.5 * k * k * k * k * k
				return 0.5 * ( ( k -= 2 ) * k * k * k * k + 2 )
			},

			// Sinusoidal
			SinusoidalIn : function( k ) {
				return 1 - Math.cos( k * Math.PI / 2 )
			},
			SinusoidalOut : function( k ) {
				return Math.sin( k * Math.PI / 2 )
			},
			SinusoidalInOut : function( k ) {
				return 0.5 * ( 1 - Math.cos( Math.PI * k ) )
			},

			// Exponential
			ExponentialIn : function( k ) {
				return k === 0 ? 0 : Math.pow( 1024, k - 1 )
			},
			ExponentialOut : function( k ) {
				return k === 1 ? 1 : 1 - Math.pow( 2, - 10 * k )
			},
			ExponentialInOut : function( k ) {
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( ( k *= 2 ) < 1 ) return 0.5 * Math.pow( 1024, k - 1 )
				return 0.5 * ( - Math.pow( 2, - 10 * ( k - 1 ) ) + 2 )
			},

			// Circular
			CircularIn : function( k ) {
				return 1 - Math.sqrt( 1 - k * k )
			},
			CircularOut : function( k ) {
				return Math.sqrt( 1 - --k * k )
			},
			CircularInOut : function( k ) {
				if ( ( k *= 2 ) < 1) return - 0.5 * ( Math.sqrt( 1 - k * k) - 1)
				return 0.5 * ( Math.sqrt( 1 - ( k -= 2) * k) + 1)
			},

			// Elastic
			ElasticIn : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				return - ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) )
			},
			ElasticOut : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				return ( a * Math.pow( 2, - 10 * k) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) + 1 )
			},
			ElasticInOut : function( k ) {
				var s, a = 0.1, p = 0.4
				if ( k === 0 ) return 0
				if ( k === 1 ) return 1
				if ( !a || a < 1 ) { a = 1; s = p / 4; }
				else s = p * Math.asin( 1 / a ) / ( 2 * Math.PI )
				if ( ( k *= 2 ) < 1 ) return - 0.5 * ( a * Math.pow( 2, 10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) )
				return a * Math.pow( 2, -10 * ( k -= 1 ) ) * Math.sin( ( k - s ) * ( 2 * Math.PI ) / p ) * 0.5 + 1
			},

			// Back
			BackIn : function( k ) {
				var s = 1.70158
				return k * k * ( ( s + 1 ) * k - s )
			},
			BackOut : function( k ) {
				var s = 1.70158
				return --k * k * ( ( s + 1 ) * k + s ) + 1
			},
			BackInOut : function( k ) {
				var s = 1.70158 * 1.525
				if ( ( k *= 2 ) < 1 ) return 0.5 * ( k * k * ( ( s + 1 ) * k - s ) )
				return 0.5 * ( ( k -= 2 ) * k * ( ( s + 1 ) * k + s ) + 2 )
			},

			// Bounce
			BounceIn : function( k ) {
				return 1 - Easing.BounceOut( 1 - k )
			},
			BounceOut : function( k ) {
				if ( k < ( 1 / 2.75 ) ) {
					return 7.5625 * k * k

				} else if ( k < ( 2 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 1.5 / 2.75 ) ) * k + 0.75

				} else if ( k < ( 2.5 / 2.75 ) ) {
					return 7.5625 * ( k -= ( 2.25 / 2.75 ) ) * k + 0.9375

				} else {
					return 7.5625 * ( k -= ( 2.625 / 2.75 ) ) * k + 0.984375
				}
			},
			BounceInOut : function( k ) {
				if ( k < 0.5 ) return Easing.BounceIn( k * 2 ) * 0.5
				return Easing.BounceOut( k * 2 - 1 ) * 0.5 + 0.5
			}
		}

		return Easing
	}
)

/**
 * UUID.core.js: The minimal subset of the RFC-compliant UUID generator UUID.js.
 *
 * author:  LiosK
 * version: core-1.0
 * license: The MIT License: Copyright (c) 2012 LiosK.
 *
 * @private
 */
define(
	'spell/math/random/UUID',
	function() {
		'use strict'


		/**
		 * Returns an unsigned x-bit random integer (0 <= f(x) < 2^x).
		 *
		 * @private
		 * @param {Number} x A positive integer ranging from 0 to 53, inclusive.
		 * @returns {Number}
		 */
		var getRandomInt = function(x) {
			if (x <   0) return NaN;
			if (x <= 30) return (0 | Math.random() * (1 <<      x));
			if (x <= 53) return (0 | Math.random() * (1 <<     30))
				+ (0 | Math.random() * (1 << x - 30)) * (1 << 30);
			return NaN;
		};

		/**
		 * Converts an integer to a zero-filled hexadecimal string.
		 *
		 * @private
		 * @param {Number} num
		 * @param {Number} length
		 * @returns {String}
		 */
		var hex = function(num, length) {
			var str = num.toString(16), i = length - str.length, z = "0";
			for (; i > 0; i >>>= 1, z += z) { if (i & 1) { str = z + str; } }
			return str;
		};


		/**
		 * Enables the generation of UUIDs. See http://en.wikipedia.org/wiki/Universally_unique_identifier.
		 *
		 * @class spell.math.random.UUID
		 * @constructor
		 */
		var UUID = function() {}

		/**
		 * Generates an UUID string.
		 *
		 * @returns {String}
		 */
		UUID.generate = function() {
			return  hex(getRandomInt(32), 8)        // time_low
				+ "-"
				+ hex(getRandomInt(16), 4)          // time_mid
				+ "-"
				+ hex(0x4000 | getRandomInt(12), 4) // time_hi_and_version
				+ "-"
				+ hex(0x8000 | getRandomInt(14), 4) // clock_seq_hi_and_reserved clock_seq_low
				+ "-"
				+ hex(getRandomInt(48), 12);        // node
		};

		return UUID
	}
)

define(
	'spell/math/random/ShuffledSet',
	function() {
		'use strict'


		var swap = function( values, i, j ) {
		    var x = values[ j ]

		    values[ j ] = values[ i ]
		    values[ i ] = x
		}

		/**
		 * Shuffles the supplied values. Uses the Fisher-Yates shuffling algorithm.
		 *
		 * @param prng the pseudo random number generator to use
		 * @param values the values to shuffle
		 * @constructor
		 */
		var ShuffledSet = function( prng, values ) {
		    this.prng = prng
		    this.values = values.slice()
		    this.lastNotYetChosenIndex = this.values.length - 1
		}

		ShuffledSet.prototype = {
		    next : function() {
		        var lastNotYetChosenIndex = this.lastNotYetChosenIndex
		        if( lastNotYetChosenIndex < 0 ) return

		        var values = this.values,
		            index  = Math.floor( this.prng.nextBetween( 0, lastNotYetChosenIndex ) ),
		            x      = values[ index ]

		        swap( values, index, lastNotYetChosenIndex )

		        this.lastNotYetChosenIndex--

		        return x
		    }
		}

		return ShuffledSet
	}
)

define(
	'spell/client/util/createIncludedRectangle',
	function() {
		'use strict'


		/**
		 * Returns a screen size that has the supplied aspect ratio and includes the supplied screen dimensions.
		 *
		 * For example:
		 *
		 *   createIncludedRectangle( [ 120, 90 ], 16/9 )
		 *   => [ 120, 67.5 ]
		 */
		return function( dimensions, requestedAspectRatio, round ) {
			var width              = dimensions[ 0 ],
				height             = dimensions[ 1 ],
				currentAspectRatio = width / height

			if( requestedAspectRatio <= currentAspectRatio ) {
				// screen has additional space left horizontally
				width = requestedAspectRatio * height

			} else {
				// screen has additional space left vertically
				height = width / requestedAspectRatio
			}

			if( round ) {
				width  = Math.round( width )
				height = Math.round( height )
			}

			return [ width, height ]
		}
	}
)

define(
	'spell/client/2d/graphics/drawTitleSafeOutline',
	[
		'spell/client/util/createIncludedRectangle',

		'spell/math/util',
		'spell/math/mat3',
		'spell/math/vec2'
	],
	function(
		createIncludedRectangle,


		mathUtil,
		mat3,
		vec2
	) {
		'use strict'


		var tmpMat3 = mat3.identity( mat3.create() ),
			tmp     = vec2.create()

		var drawRect = function( context, dx, dy, width, height, lineWidth ) {
			if( !lineWidth || lineWidth < 0 ) {
				lineWidth = 1
			}

			var doubledLineWidth = lineWidth * 2

			context.save()
			{
				// horizontal
				context.fillRect( dx, dy, width, lineWidth )
				context.fillRect( dx, dy + height - lineWidth, width, lineWidth )

				// vertical
				context.fillRect( dx, dy + lineWidth, lineWidth, height - doubledLineWidth )
				context.fillRect( dx + width - lineWidth, dy + lineWidth, lineWidth, height - doubledLineWidth )
			}
			context.restore()
		}


		return function( context, screenSize, cameraDimensions, cameraTransform ) {
			var scale                     = cameraTransform.scale,
				color                     = [ 1, 0, 1, 1 ],
				scaledCameraDimensions    = vec2.multiply( tmp, cameraDimensions, scale ),
				cameraAspectRatio         = scaledCameraDimensions[ 0 ] / scaledCameraDimensions[ 1 ],
				effectiveCameraDimensions = createIncludedRectangle( screenSize, cameraAspectRatio )

			var translation = vec2.scale(
				tmp,
				vec2.subtract( tmp, screenSize, effectiveCameraDimensions ),
				0.5
			)

			context.save()
			{
				// world to view matrix
				mathUtil.mat3Ortho( tmpMat3, 0, screenSize[ 0 ], 0, screenSize[ 1 ] )
				mat3.translate( tmpMat3, tmpMat3, translation )

				context.setViewMatrix( tmpMat3 )

				context.setColor( color )
				drawRect( context, 0, 0, effectiveCameraDimensions[ 0 ], effectiveCameraDimensions[ 1 ], 2 )
			}
			context.restore()
		}
	}
)

define(
	'spell/client/2d/graphics/drawText',
	[
		'spell/math/vec2'
	],
	function(
		vec2
	) {
		'use strict'


		var sourcePosition      = vec2.create(),
			destinationPosition = vec2.create(),
			dimensions          = vec2.create()

		/**
		 * Draws a character on a context.
		 *
		 * @param context
		 * @param texture
		 * @param charData
		 * @param dx
		 * @param dy
		 * @param spacing the actual spacing to be used
		 * @param fontMapHSpacing the fake horizontal spacing introduced by the font map
		 * @param fontMapVSpacing the fake vertical spacing introduced by the font map
		 */
		var drawCharacter = function( context, texture, charData, dx, dy, spacing, fontMapHSpacing, fontMapVSpacing ) {
			sourcePosition[ 0 ] = charData.x - fontMapHSpacing
			sourcePosition[ 1 ] = charData.y

			destinationPosition[ 0 ] = dx - fontMapHSpacing
			destinationPosition[ 1 ] = dy - fontMapVSpacing

			dimensions[ 0 ] = charData.width + fontMapHSpacing * 2
			dimensions[ 1 ] = charData.height + fontMapVSpacing * 2

			context.drawSubTexture(
				texture,
				sourcePosition,
				dimensions,
				destinationPosition,
				dimensions
			)

			return charData.width + spacing + fontMapHSpacing
		}

		var calculateAlignPosition = function( text, fontAsset, align, spacing ) {
			spacing = fontAsset.config.hSpacing + spacing
			if( !align ) return 0

			var width         = 0,
				numCharacters = text.length,
				charset       = fontAsset.config.charset

			if( align === 'left' ) return width
			if( align === 'right' ) return width

			if( align === 'center' ) {
				for( var i = 0; i < numCharacters; i++ ) {
					var charData = charset[ text.charAt( i ) ]

					// in case of unsupported character perform a fallback
					if( !charData ) {
						charData = charset[ ' ' ]
					}

					width += charData.width + spacing
				}

				return width * 0.5
			}
		}

		return function( context, fontAsset, fontTexture, dx, dy, text, spacing, align ) {
			spacing = spacing || 0
			text    = text.toString()
			dx      = dx - calculateAlignPosition( text, fontAsset, align, spacing )

			var numCharacters   = text.length,
				charset         = fontAsset.config.charset,
				fontMapHSpacing = fontAsset.config.hSpacing,
				fontMapVSpacing = fontAsset.config.vSpacing

			for( var i = 0; i < numCharacters; i++ ) {
				var charData = charset[ text.charAt( i ) ]

				// in case of unsupported character perform a fallback
				if( !charData ) {
					charData = charset[ ' ' ]
				}

				dx += drawCharacter( context, fontTexture, charData, dx, dy, spacing, fontMapHSpacing, fontMapVSpacing )
			}
		}
    }
)

define(
	'spell/client/2d/graphics/drawCoordinateGrid',
	[
		'spell/client/2d/graphics/drawText',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec4',
		'spell/math/mat3'
	],
	function(
		drawText,

		mathUtil,
		vec2,
		vec4,
		mat3
	) {
		'use strict'


		var tmpMat3         = mat3.identity( mat3.create() ),
			invScale        = vec2.create(),
			lineOpacity     = 0.5,
			paleLineColor   = vec4.fromValues( 0.4, 0.4, 0.4, lineOpacity ),
			brightLineColor = vec4.fromValues( 0.7, 0.7, 0.7, lineOpacity ),
			XAxisColor      = vec4.fromValues( 0.0, 0.0, 0.7, lineOpacity ),
			YAxisColor      = vec4.fromValues( 0.0, 0.7, 0.0, lineOpacity )

		var computeGridLineStepSize = function( s ) {
		    var log = Math.log( s ) / Math.log( 10 )
		    var exp = Math.round( log )

		    return Math.pow( 10, exp - 1 )
		}

		var computeGridStart = function( value, stepSize ) {
			var rest = value % stepSize

			return ( rest !== 0 ?
				( value > 0 ?
					value - rest + stepSize :
					value - rest
				) :
				value
			)
		}

		var computeNumLines = function( range, stepSize ) {
			return Math.floor( range / stepSize )
		}

		var drawGridLinesY = function( context, fontAsset, fontTexture, height, stepSize, startX, y, invScale, worldToScreenTranslation, numLines ) {
			var nextStepSize = stepSize * 10,
				scaledY = Math.round( ( y + worldToScreenTranslation[ 1 ] ) * invScale ),
				scaledX,
				x

			for( var i = 0; i <= numLines; i++ ) {
				x = ( startX + i * stepSize )
				scaledX = Math.round( ( x + worldToScreenTranslation[ 0 ] ) * invScale )

				// determining the color
				context.setColor(
					( x === 0 ?
						YAxisColor :
						( x % nextStepSize === 0 ?
							brightLineColor :
							paleLineColor
						)
					)
				)

				// draw line
				context.fillRect( scaledX, scaledY, 1, height )

				// draw label
				drawText( context, fontAsset, fontTexture, scaledX + 3, scaledY, x )
			}
		}

		var drawGridLinesX = function( context, fontAsset, fontTexture, width, stepSize, startY, x, invScale, worldToScreenTranslation, numLines ) {
			var nextStepSize = stepSize * 10,
				scaledX = Math.round( ( x + worldToScreenTranslation[ 0 ] ) * invScale ),
				scaledY,
				y

			for( var i = 0; i <= numLines; i++ ) {
				y = ( startY + i * stepSize )
				scaledY = Math.round( ( y + worldToScreenTranslation[ 1 ] ) * invScale )

				// determining the color
				context.setColor(
					( y === 0 ?
						XAxisColor :
						( y % nextStepSize === 0 ?
							brightLineColor :
							paleLineColor
						)
					)
				)

				// draw line
				context.fillRect( scaledX, scaledY, width, 1 )

				// draw label
				drawText( context, fontAsset, fontTexture, scaledX + 3, scaledY, y )
			}
		}

		return function( context, fontAsset, screenSize, cameraDimensions, cameraTransform ) {
			var position     = cameraTransform.translation,
				cameraWidth  = cameraDimensions[ 0 ],
				cameraHeight = cameraDimensions[ 1 ],
				minX         = position[ 0 ] - cameraWidth / 2,
				minY         = position[ 1 ] - cameraHeight / 2,
				maxX         = minX + cameraWidth,
				maxY         = minY + cameraHeight,
				stepSize     = computeGridLineStepSize( cameraWidth ),
				worldToScreenTranslation = [ -minX, -minY ],
				fontTexture  = fontAsset.resource

			vec2.divide( invScale, screenSize, cameraDimensions )

			context.save()
			{
				// world to view matrix
				mathUtil.mat3Ortho( tmpMat3, 0, screenSize[ 0 ], 0, screenSize[ 1 ] )

				context.setViewMatrix( tmpMat3 )

				// grid lines parallel to y-axis
				drawGridLinesY(
					context,
					fontAsset,
					fontTexture,
					screenSize[ 1 ],
					stepSize,
					computeGridStart( minX, stepSize ),
					minY,
					invScale[ 1 ],
					worldToScreenTranslation,
					computeNumLines( cameraWidth, stepSize )
				)

				// grid lines parallel to x-axis
				drawGridLinesX(
					context,
					fontAsset,
					fontTexture,
					screenSize[ 0 ],
					stepSize,
					computeGridStart( minY, stepSize ),
					minX,
					invScale[ 0 ],
					worldToScreenTranslation,
					computeNumLines( cameraHeight, stepSize )
				)
			}
			context.restore()
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawOrigin',
	function() {
		'use strict'


		return function( context, scale ) {
			if( !scale ) scale = 1

			context.drawLine( -scale, -scale, scale, scale )
			context.drawLine( -scale, scale, scale, -scale )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawPoint',
	function() {
		'use strict'


		return function( context, scale ) {
			if( !scale ) scale = 1

			var a = 2 * scale,
				halfA = a * 0.5

			context.fillRect( -halfA, -halfA, a, a )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawCircle',
	function() {
		'use strict'


		return function( context, radius, color, lineWidth ) {
			var negHalfRadius = radius * -0.5

			context.setLineColor( color )
			context.drawCircle( 0, 0, radius, lineWidth )
			context.drawLine( radius, 0, radius * 0.618, 0, lineWidth )
		}
	}
)

define(
	'spell/client/2d/graphics/physics/drawBox',
	function() {
		'use strict'


		return function( context, width, height, color, lineWidth ) {
			var halfWidth  = width * 0.5,
				halfHeight = height * 0.5

			context.setLineColor( color )
			context.drawRect( -halfWidth, -halfHeight, width, height, lineWidth )
			context.drawLine( halfWidth * 0.618, 0, halfWidth, 0, lineWidth )
		}
	}
)

define(
	'spell/client/2d/graphics/drawShape',
	function() {
		'use strict'


		return {
			rectangle : function( context, shape ) {
				var width         = shape.width,
					height        = shape.height,
					negHalfWidth  = width * -0.5,
					negHalfHeight = height * -0.5

				if( shape.fill ) {
					context.setColor( shape.fillColor )
					context.fillRect( negHalfWidth, negHalfHeight, width, height )
				}

				context.setLineColor( shape.lineColor )
				context.drawRect( negHalfWidth, negHalfHeight, width, height, shape.lineWidth )
			}
		}
	}
)

/**
 * This module acts as a static include list for modules that must be included in the engine library even though they are not used by the engine itself. This is
 * the case for certain math modules or similar modules which are useful for end users/developers.
 */

define(
	'spell/client/staticInclude',
	[
		'spell/client/2d/graphics/drawShape',
		'spell/client/2d/graphics/physics/drawBox',
		'spell/client/2d/graphics/physics/drawCircle',
		'spell/client/2d/graphics/physics/drawPoint',
		'spell/client/2d/graphics/physics/drawOrigin',
		'spell/client/2d/graphics/drawCoordinateGrid',
		'spell/client/2d/graphics/drawTitleSafeOutline',
		'spell/math/mat2',
		'spell/math/mat2d',
		'spell/math/mat3',
		'spell/math/mat4',
		'spell/math/quat',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/random/ShuffledSet',
		'spell/math/random/UUID',
		'spell/math/random/XorShift32',
		'spell/shared/Easing',
		'spell/shared/util/createEntityEach',
		'spell/shared/util/input/keyCodes',
		'spell/shared/util/translate',
		'spell/client/util/createEffectiveCameraDimensions',
		'spell/client/util/createIncludedRectangle',
		'spell/recursiveFunctions',
		'spell/stringUtil'
	],
	function() {
		return undefined
	}
)

/**
 * This module is overwritten during the debug build process.
 */

define(
	'spell/client/isDebug',
	function() {
		'use strict'


		return false
	}
)

define(
	'spell/client/development/createSystemMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/shared/util/createId'
	],
	function(
		createMessageDispatcher,
		createId
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				add : function( payload ) {
					spell.sceneManager.addSystem( payload.systemId, payload.executionGroupId, payload.index, payload.systemConfig )
				},
				move : function( payload ) {
					spell.sceneManager.moveSystem( payload.systemId, payload.srcExecutionGroupId, payload.dstExecutionGroupId, payload.dstIndex )
				},
				remove : function( payload ) {
					spell.sceneManager.removeSystem( payload.systemId, payload.executionGroupId )
				},
				update : function( payload ) {
					var definition = payload.definition

					if( !definition.namespace || !definition.name ) {
						throw 'Error: System definition is missing namespace and or name attribute.'
					}

					var libraryId = createId( definition.namespace, definition.name )

					var metaDataCache = {}

					metaDataCache[ libraryId ] = definition

					spell.libraryManager.addToCache( metaDataCache )

					spell.sceneManager.restartSystem( libraryId, payload.executionGroupId, payload.systemConfig )
				}
			} )
		}
	}
)

define(
	'spell/client/development/createSettingsMessageHandler',
	[
		'spell/client/development/createMessageDispatcher'
	],
	function(
		createMessageDispatcher
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				drawCoordinateGrid : function( payload ) {
					spell.configurationManager.setValue( 'drawCoordinateGrid', payload )
				},
				drawTitleSafeOutline : function( payload ) {
					spell.configurationManager.setValue( 'drawTitleSafeOutline', payload )
				},
				setScreenMode : function( payload ) {
					spell.configurationManager.setValue( 'screenMode', payload )
				},
				simulateScreenAspectRatio : function( payload ) {
					spell.configurationManager.setValue( 'screenAspectRatio', payload.aspectRatio )
				}
			} )
		}
	}
)

define(
	'spell/client/setApplicationModule',
    [
        'spell/functions'
    ],
	function(
        _
    ) {
		'use strict'


		return function( spell, configurationManager, target, applicationModule, loaderConfig ) {
			if( !applicationModule ) {
				throw 'Error: Missing application module. Please provide a application module.'
			}

			var applicationConfig = applicationModule.config,
				targetConfig      = applicationConfig[ target ]

			if( !targetConfig ) {
				throw 'Error: The application config does not include configuration for the target "' + target + '".'
			}

			spell.applicationModule = applicationModule

			// TODO: move all general configuration options below a common parent attribute (i.e. "general") in the project.json
			var generalConfig = _.pick(
				applicationModule.config,
				'screenSize',
				'screenMode',
				'orientation',
				'loadingScene',
				'projectId',
				'version',
				'defaultLanguage',
				'qualityLevels',
				'supportedLanguages'
			)

            // config precedence: loader config > target config > general config
			configurationManager.setConfig( _.extend( generalConfig, targetConfig, loaderConfig ) )
		}
	}
)

define(
	'spell/client/development/createApplicationMessageHandler',
	[
		'spell/client/setApplicationModule',
		'spell/client/development/createMessageDispatcher'
	],
	function(
		setApplicationModule,
		createMessageDispatcher
	) {
		'use strict'


		return function( spell, startEngine ) {
			return createMessageDispatcher( {
				/**
				 * Starts the application module. Used in standalone development mode.
				 *
				 * @param payload
				 */
				startApplicationModule : function( payload ) {
					startEngine( payload.applicationModule )
				},

				/**
				 * Sets the application module. Used in embedded development mode.
				 *
				 * @param payload
				 */
				setApplicationModule : function( payload ) {
                    setApplicationModule(
                        spell,
                        spell.configurationManager,
                        payload.applicationModule,
                        payload.applicationModule.config,
                        spell.loaderConfig
                    )
				},

				/**
				 * Adds entries to the library cache. Used in embedded development mode.
				 *
				 * @param payload
				 */
				addToCache : function( payload ) {
					spell.libraryManager.addToCache( payload.cacheContent )
				},

				/**
				 * Starts a scene. Used in embedded development mode.
				 *
				 * @param payload
				 */
				startScene : function( payload ) {
					spell.sceneManager.startScene( payload.targetSceneId, payload.initialConfig, payload.showLoadingScene )
				}
			} )
		}
	}
)

/*
 * @class spell.shared.util.platform.PlatformKit
 * @singleton
 */
define(
	'spell/shared/util/platform/PlatformKit',
	[
		'spell/shared/util/createAssetId',
		'spell/shared/util/platform/private/Application',
		'spell/shared/util/platform/private/callNextFrame',
		'spell/shared/util/platform/private/createHost',
		'spell/shared/util/platform/private/jsonCoder',
		'spell/shared/util/platform/private/network/createSocket',
		'spell/shared/util/platform/private/network/performHttpRequest',
		'spell/shared/util/platform/private/getAvailableScreenSize',
		'spell/shared/util/platform/private/ModuleLoader',
		'spell/shared/util/platform/private/graphics/RenderingFactory',
		'spell/shared/util/platform/private/graphics/createSplashScreenImage',
		'spell/shared/util/platform/private/sound/AudioFactory',
		'spell/shared/util/platform/private/registerTimer',
		'spell/shared/util/platform/private/loader/ImageLoader',
		'spell/shared/util/platform/private/loader/SoundLoader',
		'spell/shared/util/platform/private/loader/TextLoader',
		'spell/shared/util/platform/private/input/support',
		'spell/shared/util/platform/private/Input',
		'spell/shared/util/platform/private/Environment',
		'spell/shared/util/platform/private/configurationOptions',
		'spell/shared/util/platform/private/storage/PersistentStorage',
		'spell/shared/util/platform/private/openURL',
		'spell/shared/util/platform/private/platformDetails',
		'spell/shared/util/platform/private/graphics/initViewport',
		'spell/shared/util/platform/private/advertisement',
		'spell/shared/util/platform/private/flurry',
		'spell/shared/util/platform/private/createComponentType',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/functions'
	],
	function(
		createAssetId,
		Application,
		callNextFrame,
		createHost,
		jsonCoder,
		createSocket,
		performHttpRequest,
		getAvailableScreenSize,
		ModuleLoader,
		RenderingFactory,
		createSplashScreenImage,
		AudioFactory,
		registerTimer,
		ImageLoader,
		SoundLoader,
		TextLoader,
		support,
		Input,
		Environment,
		configurationOptions,
		PersistentStorage,
		openURL,
		platformDetails,
		initViewport,
		advertisement,
		flurry,
		createComponentType,
		isHtml5Ejecta,
		isHtml5TeaLeaf,
		_
	) {
		'use strict'


		var getHost = function() {
			return createHost()
		}

		var createInput = function( configurationManager, renderingContext ) {
			return new Input( configurationManager, renderingContext )
		}

		var createEnvironment = function( configurationManager, eventManager ) {
			var environment = new Environment( configurationManager, eventManager )

			environment.init()

			return environment
		}

		return {
			/*
			 *
			 */
			callNextFrame : callNextFrame,

			/*
			 *
			 */
			registerTimer : registerTimer,

			/*
			 *
			 */
			network : {
				createSocket : createSocket,
				performHttpRequest : performHttpRequest
			},

			/*
			 *
			 */
			AudioFactory : AudioFactory,

			/*
			 *
			 */
			RenderingFactory : RenderingFactory,

			/*
			 *
			 */
			getHost : getHost,

			/*
			 *
			 */
			ModuleLoader : ModuleLoader,

			/*
			 *
			 */
			configurationOptions : configurationOptions,

			/*
			 *
			 */
			platformDetails : platformDetails,

			/*
			 *
			 */
			jsonCoder : jsonCoder,

			/*
			 *
			 */
			createInput : createInput,

			/*
			 *
			 */
			createEnvironment : createEnvironment,

			/*
			 *
			 */
			getAvailableScreenSize : getAvailableScreenSize,

			openURL : openURL,

			createPersistentStorage : function() {
				return new PersistentStorage()
			},

			createImageLoader : function( renderingContext, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				return new ImageLoader( renderingContext, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			createSoundLoader : function( audioContext, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				var asset = assetManager.get( createAssetId( 'sound', libraryId ) )

				return new SoundLoader( audioContext, asset, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			createTextLoader : function( postProcess, assetManager, libraryId, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
				return new TextLoader( postProcess, url, onLoadCallback, onErrorCallback, onTimedOutCallback )
			},

			flurry : flurry,

			createComponentType : createComponentType,

			Application : Application,

			createSplashScreenImage : createSplashScreenImage,

			init : function( spell, next ) {
				initViewport(
					spell.eventManager,
					spell.configurationManager.getValue( 'id' ),
					spell.configurationManager.getValue( 'currentScreenSize' )
				)

				support.init(
					spell,
					_.bind( advertisement.init, advertisement, spell, next )
				)
			},

			getPlugins : function() {
				if( isHtml5Ejecta ||
					isHtml5TeaLeaf ) {

					return {
						admob : advertisement,
						admobWithChartboost : advertisement
					}

				} else {
					return {}
				}
			}
		}
	}
)

define(
	'spell/shared/util/createModuleId',
	function() {
		'use strict'


		return function( scriptId ) {
			return scriptId.replace( /\./g, '/' )
		}
	}
)

define(
	'spell/client/development/library/updateScript',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createModuleId',
		'spell/shared/util/platform/PlatformKit',

		'spell/functions'
	],
	function(
		createId,
		createModuleId,
		PlatformKit,

		_
	) {
		'use strict'


		var createAffectedSystems = function( libraryManager, dependentModules ) {
			return _.reduce(
				libraryManager.getMetaDataRecordsByType( 'system' ),
				function( memo, system ) {
					var systemId       = createId( system.namespace, system.name ),
						systemModuleId = createModuleId( systemId )

					if( _.contains( dependentModules, systemModuleId ) ) {
						memo.push( systemId )
					}

					return memo
				},
				[]
			)
		}

		return function( spell, payload ) {
			var libraryId = payload.id,
				moduleId  = createModuleId( libraryId )

			// reload amd module
			PlatformKit.ModuleLoader.define( moduleId, payload.moduleSource )

			var dependentModules = PlatformKit.ModuleLoader.createDependentModules( moduleId ).concat( moduleId )

			// restart affected systems
			var sceneManager = spell.sceneManager,
				systemIds    = createAffectedSystems( spell.libraryManager, dependentModules )

			_.each(
				systemIds,
				function( systemId ) {
					sceneManager.restartSystem( systemId )
				}
			)

			// refresh references in component instances
			spell.entityManager.updateAssetReferences(
				'script:' + libraryId,
				spell.moduleLoader.require( moduleId )
			)
		}
	}
)

define(
	'spell/client/development/library/updateEntityTemplate',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePathFromId'
	],
	function(
		createId,
		createLibraryFilePathFromId
	) {
		'use strict'


		return function( spell, payload ) {
			var cacheContent    = {},
				definition      = payload.definition,
				libraryFilePath = createLibraryFilePathFromId( createId( definition.namespace, definition.name ) )

			cacheContent[ libraryFilePath ] = definition

			spell.libraryManager.addToCache( cacheContent )
			spell.entityManager.updateEntityTemplate( definition )
		}
	}
)

define(
	'spell/client/loading/addNamespaceAndName',
	function() {
		'use strict'


		/**
		 * Adds the namespace and name attribute to library records.
		 *
		 * @param records
		 */
		var addNamespaceAndName = function( records ) {
			for( var key in records ) {
				var value = records[ key ]

				var splitOffset = key.lastIndexOf( '.' )

				value.name      = key.substr( splitOffset + 1, key.length )
				value.namespace = key.substr( 0, splitOffset )
			}
		}

		return addNamespaceAndName
	}
)

define(
	'spell/client/development/library/updateAsset',
	[
		'spell/client/development/library/loadAsset',
		'spell/client/loading/addNamespaceAndName',
		'spell/client/loading/createFilesToLoad',
		'spell/client/util/updateAssets',
		'spell/shared/util/createAssetId',
		'spell/shared/util/createId',
		'spell/shared/util/createLibraryFilePath',
		'spell/shared/util/createLibraryFilePathFromId',
		'spell/shared/util/createLibraryIdFromAssetId',

		'spell/functions'
	],
	function(
		loadAsset,
		addNamespaceAndName,
		createFilesToLoad,
		updateAssets,
		createAssetId,
		createId,
		createLibraryFilePath,
		createLibraryFilePathFromId,
		createLibraryIdFromAssetId,

		_
	) {
		'use strict'


		return function( spell, payload ) {
			var assetManager         = spell.assetManager,
				eventManager         = spell.eventManager,
				configurationManager = spell.configurationManager,
				definition           = payload.definition,
				id                   = createId( definition.namespace, definition.name ),
				typedId              = createAssetId( definition.subtype, id )

			var loadedAssets = [ definition ]

			// The current state of asset update handling needs to be improved. In order to do that dependencies between assets must be accessible in a
			// normalized fashion.

			if( !definition.file &&
				!definition.assetId ) {

				updateAssets( assetManager, loadedAssets, true )

				eventManager.publish(
					[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
					[ typedId ]
				)
			}

			if( definition.file ) {
				spell.libraryManager.load(
					createFilesToLoad( configurationManager, loadedAssets ),
					{
						assetManager       : spell.assetManager,
						isMetaDataLoad     : false,
						omitCache          : true,
						onLoadingCompleted : function( loadedFiles ) {
							updateAssets( assetManager, loadedAssets, true )

							spell.libraryManager.addToCache( loadedAssets )

							var libraryIds = assetManager.getLibraryIdByResourceId( createLibraryFilePath( definition.namespace, definition.file ) )

							var assetsToUpdate = _.reduce(
								libraryIds,
								function( memo, libraryId ) {
									var libraryPathJson = createLibraryFilePathFromId( libraryId )

									memo[ libraryPathJson ] = spell.libraryManager.get( libraryPathJson )

									return memo
								},
								{}
							)

							updateAssets( assetManager, assetsToUpdate, true )

							assetManager.injectResources( loadedFiles )

							spell.entityManager.refreshAssetReferences( assetManager )

							eventManager.publish(
								[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
								[ typedId ]
							)
						}
					}
				)
			}

			var assetId = definition.assetId

			if( assetId ) {
				// load referenced asset first
				loadAsset(
					spell,
					createLibraryIdFromAssetId( assetId ),
					function( loadedFiles ) {
						// now update referencing asset (-> updated definition) and inject referenced asset
						updateAssets( assetManager, loadedAssets, true )

						assetManager.injectResources( loadedFiles )

						spell.entityManager.updateAssetReferences( typedId, assetManager.get( typedId ) )

						eventManager.publish(
							[ eventManager.EVENT.ASSET_UPDATED, definition.subtype ],
							[ typedId ]
						)
					}
				)
			}
		}
	}
)

define(
	'spell/client/development/createLibraryMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/library/updateAsset',
		'spell/client/development/library/updateEntityTemplate',
		'spell/client/development/library/updateScript',

		'spell/functions'
	],
	function(
		createMessageDispatcher,
		updateAsset,
		updateEntityTemplate,
		updateScript,

		_
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				updateAsset : _.bind( updateAsset, null, spell ),
				updateEntityTemplate : _.bind( updateEntityTemplate, null, spell ),
				updateScript : _.bind( updateScript, null, spell )
			} )
		}
	}
)

define(
	'spell/client/development/createEntityMessageHandler',
	[
		'spell/client/development/createMessageDispatcher'
	],
	function(
		createMessageDispatcher
	) {
		'use strict'


		return function( spell ) {
			return createMessageDispatcher( {
				create : function( payload ) {
					spell.entityManager.createEntity( payload.entityConfig )
				},
				remove : function( payload ) {
					spell.entityManager.removeEntity( payload.entityId )
				}
			} )
		}
	}
)

define(
	'spell/shared/util/createLibraryIdFromAssetId',
	function() {
		'use strict'


		return function( assetId ) {
			return assetId ?
				assetId.slice( assetId.indexOf( ':' ) + 1 ) :
				undefined
		}
	}
)

define(
	'spell/shared/util/createLibraryFilePathFromId',
	function() {
		'use strict'


		return function( id ) {
			return id.replace( /\./g, '/' ) + '.json'
		}
	}
)

define(
	"spell/shared/util/input/keyCodes",
	function() {
		return {
		    "BACKSPACE": 8,
		    "TAB": 9,
		    "ENTER": 13,
		    "SHIFT": 16,
		    "CTRL": 17,
		    "ALT": 18,
		    "PAUSE": 19,
		    "CAPS_LOCK": 20,
		    "ESCAPE": 27,
		    "SPACE": 32,
		    "PAGE_UP": 33,
		    "PAGE_DOWN": 34,
		    "END": 35,
		    "HOME": 36,
		    "LEFT_ARROW": 37,
		    "UP_ARROW": 38,
		    "RIGHT_ARROW": 39,
		    "DOWN_ARROW": 40,
		    "INSERT": 45,
		    "DELETE": 46,
		    "0": 48,
		    "1": 49,
		    "2": 50,
		    "3": 51,
		    "4": 52,
		    "5": 53,
		    "6": 54,
		    "7": 55,
		    "8": 56,
		    "9": 57,
		    "A": 65,
		    "B": 66,
		    "C": 67,
		    "D": 68,
		    "E": 69,
		    "F": 70,
		    "G": 71,
		    "H": 72,
		    "I": 73,
		    "J": 74,
		    "K": 75,
		    "L": 76,
		    "M": 77,
		    "N": 78,
		    "O": 79,
		    "P": 80,
		    "Q": 81,
		    "R": 82,
		    "S": 83,
		    "T": 84,
		    "U": 85,
		    "V": 86,
		    "W": 87,
		    "X": 88,
		    "Y": 89,
		    "Z": 90,
		    "LEFT_WINDOW_KEY": 91,
		    "RIGHT_WINDOW_KEY": 92,
		    "SELECT_KEY": 93,
		    "NUMPAD_0": 96,
		    "NUMPAD_1": 97,
		    "NUMPAD_2": 98,
		    "NUMPAD_3": 99,
		    "NUMPAD_4": 100,
		    "NUMPAD_5": 101,
		    "NUMPAD_6": 102,
		    "NUMPAD_7": 103,
		    "NUMPAD_8": 104,
		    "NUMPAD_9": 105,
		    "MULTIPLY": 106,
		    "ADD": 107,
		    "SUBTRACT": 109,
		    "DECIMAL_POINT": 110,
		    "DIVIDE": 111,
		    "F1": 112,
		    "F2": 113,
		    "F3": 114,
		    "F4": 115,
		    "F5": 116,
		    "F6": 117,
		    "F7": 118,
		    "F8": 119,
		    "F9": 120,
		    "F10": 121,
		    "F11": 122,
		    "F12": 123,
		    "NUM_LOCK": 144,
		    "SCROLL_LOCK": 145,
		    "SEMI-COLON": 186,
		    "EQUAL_SIGN": 187,
		    "COMMA": 188,
		    "DASH": 189,
		    "PERIOD": 190,
		    "FORWARD_SLASH": 191,
		    "GRAVE_ACCENT": 192,
		    "OPEN_BRACKET": 219,
		    "BACK_SLASH": 220,
		    "CLOSE_BRACKET": 221,
		    "SINGLE_QUOTE": 222,

			/**
			 * Hardware buttons. The key codes are arbitrarily choosen.
			 */
			"BACK": 230,
			"MENU": 231,
			"POWER": 232,
			"HOME": 233
		}
	}
)

define(
	'spell/shared/util/createAssetId',
	[
		'spell/shared/util/createId',

		'spell/functions'
	],
	function(
		createId,

		_
	) {
		'use strict'


		return function( scheme ) {
			if( !scheme ) throw 'Error: Missing argument \'scheme\'.'

			return scheme + ':' + createId(
				_.toArray( arguments ).slice( 1 )
			)
		}
	}
)

define(
	'spell/shared/util/createId',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( args ) {
			var numArgs = arguments.length

			if( numArgs === 1 ) {
				if( !_.isArray( args ) ) {
					args = [ args ]
				}

			} else if( numArgs > 1 ) {
				args = _.toArray( arguments )
			}

			if( !args || args.length === 0 ) throw 'Error: Missing name and or namespace.'

			return _.reduce(
				args,
				function( memo, argument ) {
					if( argument === '' ) return memo

					return memo + ( memo !== '' ? '.' : '' )  + argument
				},
				''
			)
		}
	}
)

define(
	'spell/client/util/updateAssets',
	[
		'spell/shared/util/createId',
		'spell/shared/util/createAssetId',
		'spell/shared/util/input/keyCodes',

		'spell/functions'
	],
	function(
		createId,
		createAssetId,
		keyCodes,

		_
	) {
		'use strict'


		var createFrameOffset = function( frameWidth, frameHeight, numX, numY, frameId, innerPadding ) {
			if( !innerPadding ) innerPadding = 0

			frameWidth  += innerPadding * 2
			frameHeight += innerPadding * 2

			return [
				( frameId % numX ) * frameWidth + innerPadding,
				Math.floor( frameId / numX ) * frameHeight + innerPadding
			]
		}

		var createTilemapAsset = function( assetManager, asset ) {
			var spriteSheetAssetId = asset.assetId,
				spriteSheetAsset   = assetManager.get( spriteSheetAssetId )

			if( !spriteSheetAsset ) {
				return
			}

			return {
				type                : asset.subtype,
				resourceId          : spriteSheetAsset.resourceId,
				spriteSheet         : spriteSheetAsset,
				config              : asset.config,
				tilemapDimensions   : [ asset.config.width, asset.config.height ],
				tilemapData         : asset.config.tileLayerData
			}
		}

		var createAnimationAsset = function( assetManager, asset ) {
			var spriteSheetAssetId = asset.assetId,
				spriteSheetAsset   = assetManager.get( spriteSheetAssetId )

			if( !spriteSheetAsset ) {
				return
			}

			var frameWidth      = spriteSheetAsset.config.frameWidth,
				frameHeight     = spriteSheetAsset.config.frameHeight,
				innerPadding    = spriteSheetAsset.config.innerPadding || 0,
				numX            = Math.floor( spriteSheetAsset.config.textureWidth / ( frameWidth + innerPadding * 2 ) ),
				numY            = Math.floor( spriteSheetAsset.config.textureHeight / ( frameHeight + innerPadding * 2 ) ),
				numFrames       = _.size( asset.config.frameIds ),
				createFrameOffsetPartial = _.bind( createFrameOffset, null, frameWidth, frameHeight )

			return {
				type            : asset.subtype,
				resourceId      : spriteSheetAsset.resourceId,
				frameDimensions : [ frameWidth, frameHeight ],
				frameDuration   : asset.config.duration / numFrames,
				frameOffsets    : _.map( asset.config.frameIds, function( frameId ) { return createFrameOffsetPartial( numX, numY, frameId, innerPadding ) } ),
				numFrames       : numFrames
			}
		}

		var createInputMapAsset = function( asset ) {
			return _.reduce(
				asset.config,
				function( memo, action, key ) {
					memo[ keyCodes[ key ] ] = action

					return memo
				},
				{}
			)
		}

		var eachAnimatedAttribute = function( animate, iterator ) {
			return _.each(
				animate,
				function( attributes ) {
					_.each( attributes, iterator )
				}
			)
		}

		var createKeyFrameAnimationAsset = function( asset ) {
			var config = asset.config

			// determine and add length of attribute animations
			eachAnimatedAttribute(
				config.animate,
				function( attribute ) {
					attribute.length = _.last( attribute.keyFrames ).time
				}
			)

			return {
				animate : config.animate,
				type    : asset.subtype,
				length  : config.length
			}
		}

		var createSpriteSheetAsset = function( asset ) {
			var frameWidth      = asset.config.frameWidth || 1,
				frameHeight     = asset.config.frameHeight || 1,
				innerPadding    = asset.config.innerPadding || 0,
				numX            = Math.floor( asset.config.textureWidth / ( frameWidth + innerPadding * 2 ) ),
				numY            = Math.floor( asset.config.textureHeight / ( frameHeight + innerPadding * 2 ) ),
				numFrames       = numX * numY

			// create a lookup table to lookup the subtextures
			var frameOffsets = []

			for( var i = 0; i < numFrames; i++ ) {
				frameOffsets.push( createFrameOffset( frameWidth, frameHeight, numX, numY, i, innerPadding ) )
			}

			return {
				frameDimensions : [ frameWidth, frameHeight ],
				frameOffsets    : frameOffsets,
				frameMaxX       : numX,
				frameMaxY       : numY,
				config          : asset.config,
				type            : asset.subtype
			}
		}

		var addResourceId = function( asset, assetDefinition ) {
			var file = assetDefinition.file

			if( !file ) {
				return
			}

			asset.resourceId = createId( assetDefinition.namespace, assetDefinition.name )
		}


		return function( assetManager, newAssetDefinitions, overwriteExisting ) {
			var filteredAssetDefinitions = overwriteExisting ?
				newAssetDefinitions :
				_.filter(
					newAssetDefinitions,
					function( assetDefinition ) {
						return !assetManager.has( createAssetId( assetDefinition.subtype, assetDefinition.namespace, assetDefinition.name ) )
					}
				)

			// in a first pass all assets which do not depend on other assets are created
			_.each(
				filteredAssetDefinitions,
				function( assetDefinition ) {
					var asset,
						type    = assetDefinition.subtype,
						assetId = createAssetId( type, assetDefinition.namespace, assetDefinition.name )

					if( type === 'appearance' ) {
						asset = {
							type : type
						}

					} else if( type === 'sound' ) {
						asset = {
							type : type,
							isMusic : !!assetDefinition.config.isMusic
						}

					} else if( type === 'spriteSheet' ) {
						asset = createSpriteSheetAsset( assetDefinition )

					} else if( type === 'font') {

						asset = {
							config : assetDefinition.config,
							type : type
						}

					} else if( type === 'inputMap' ) {
						asset = createInputMapAsset( assetDefinition )

					} else if( type === 'keyFrameAnimation' ) {
						asset = createKeyFrameAnimationAsset( assetDefinition )

					} else if( type === 'translation' ) {
						asset = {
							config : assetDefinition.config,
							type : type
						}
					}

					addResourceId( asset, assetDefinition )

					if( asset ) {
						asset.assetId = assetId
					}

					assetManager.add( assetId, asset )
				}
			)

			// in a second pass all assets that reference other assets are created
			_.each(
				newAssetDefinitions,
				function( assetDefinition ) {
					var type = assetDefinition.subtype

					if( type === 'animation' ) {
						var animationAsset = createAnimationAsset( assetManager, assetDefinition )

						if( animationAsset ) {
							assetManager.add(
								createAssetId(
									type,
									assetDefinition.namespace,
									assetDefinition.name
								),
								animationAsset
							)
						}

					} else if ( type === '2dTileMap') {
						var tileMapAsset = createTilemapAsset( assetManager, assetDefinition )

						if( tileMapAsset ) {
							assetManager.add(
								createAssetId(
									type,
									assetDefinition.namespace,
									assetDefinition.name
								),
								tileMapAsset
							)
						}
					}
				}
			)
		}
	}
)

define(
	'spell/shared/util/createLibraryFilePath',
	function() {
		'use strict'


		return function( namespace, fileName ) {
			return namespace.replace( /\./g, '/' ) + '/' + fileName
		}
	}
)

define(
	'spell/client/loading/createFilesToLoad',
	[
		'spell/shared/util/createLibraryFilePath',

		'spell/functions'
	],
	function(
		createLibraryFilePath,

		_
	) {
		'use strict'


		return function( configurationManager, assets ) {
			var currentLanguage     = configurationManager.getValue( 'currentLanguage' ),
				currentQualityLevel = configurationManager.getValue( 'currentQualityLevel' )

			return _.reduce(
				assets,
				function( memo, asset, libraryId ) {
					var config          = asset.config,
						subtype         = asset.subtype,
						isSound         = subtype === 'sound',
						isAppearance    = subtype === 'appearance',
						isFont          = subtype === 'font',
						isSpriteSheet   = subtype === 'spriteSheet',
						libraryFilePath

					if( config &&
						( isSound || isAppearance || isFont || isSpriteSheet ) ) {

						if( isFont || isSpriteSheet ) {
							libraryFilePath = createLibraryFilePath( asset.namespace, asset.file )

						} else {
							var isLocalized        = config.localized,
								qualityLevelSuffix = config.qualityLevels ? '.' + currentQualityLevel : ''

							if( isLocalized ) {
								var languageToExtension = config.localization,
									fileExtension       = isSound ? 'mp3' : languageToExtension[ currentLanguage ],
									localizedFileName   = asset.name + '.' + currentLanguage + qualityLevelSuffix + '.' + fileExtension

								libraryFilePath = createLibraryFilePath( asset.namespace, localizedFileName )

							} else {
								libraryFilePath = createLibraryFilePath(
									asset.namespace,
									asset.name + qualityLevelSuffix + ( isSound ? '.mp3' : '.' + config.extension )
								)
							}
						}

						memo[ libraryId ] = libraryFilePath
					}

					return memo
				},
				{}
			)
		}
	}
)

define(
	'spell/client/development/library/loadAsset',
	[
		'spell/client/loading/createFilesToLoad',
		'spell/client/util/updateAssets',
		'spell/shared/util/createLibraryFilePathFromId'
	],
	function(
		createFilesToLoad,
		updateAssets,
		createLibraryFilePathFromId
	) {
		'use strict'


		return function( spell, libraryId, next ) {
			// load meta data record
			spell.libraryManager.load(
				[ createLibraryFilePathFromId( libraryId ) ],
				{
					assetManager       : spell.assetManager,
					omitCache          : true,
					onLoadingCompleted : function( loadedLibraryRecords ) {
						updateAssets( spell.assetManager, loadedLibraryRecords )

						var filesToLoad = createFilesToLoad( spell.configurationManager, loadedLibraryRecords )

						if( filesToLoad.length > 0 ) {
							spell.libraryManager.load(
								filesToLoad,
								{
									assetManager       : spell.assetManager,
									isMetaDataLoad     : false,
									omitCache          : true,
									onLoadingCompleted : next
								}
							)

						} else {
							next()
						}
					}
				}
			)
		}
	}
)

define(
	'spell/client/development/createComponentMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/library/loadAsset',
		'spell/shared/util/createLibraryIdFromAssetId'
	],
	function(
		createMessageDispatcher,
		loadAsset,
		createLibraryIdFromAssetId
	) {
		'use strict'


		return function( spell ) {
			var updateComponent = function( payload ) {
				var success = spell.entityManager.updateComponent( payload.entityId, payload.componentId, payload.config )

				if( !success ) {
					spell.console.error( 'Could not update component "' + payload.componentId + '" in entity ' + payload.entityId + '.' )
				}
			}

			return createMessageDispatcher( {
				add : function( payload ) {
					spell.entityManager.addComponent( payload.entityId, payload.componentId )
				},
				remove : function( payload ) {
					spell.entityManager.removeComponent( payload.entityId, payload.componentId )
				},
				update : function( payload ) {
					var assetId = payload.config.assetId

					if( assetId ) {
						loadAsset(
							spell,
							createLibraryIdFromAssetId( assetId ),
							function( loadedFiles ) {
								spell.assetManager.injectResources( loadedFiles )

								spell.entityManager.updateAssetReferences( assetId, spell.assetManager.get( assetId ) )

								updateComponent( payload )
							}
						)

					} else {
						updateComponent( payload )
					}
				}
			} )
		}
	}
)

define(
	'spell/shared/util/platform/functions',
	[
		'spell/shared/util/platform/private/functions'
	],
	function(
		functions
	) {
		return functions
	}
)

/*
 * This class is derived from the library "Underscore" which original license follows:
 *
 * Licence Notice Underscore.js 1.3.3:
 *
 * Copyright (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/**
 * *spell.functions* is a collection of utility functions akin to [underscore.js](http://underscorejs.org).
 *
 * @class spell.functions
 * @singleton
 * @license
 * @preserve
 */

define(
	'spell/functions',
	[
		'spell/shared/util/platform/functions'
	],
	function(
		platformImpl
	) {
		'use strict'


		var _ = {};

		/**
		 * Returns *true* if **object** is an Array.
		 *
		 * Examples:
		 *
		 *     (function(){ return _.isArray(arguments); })();
		 *     //=> false
		 *     _.isArray([1,2,3]);
		 *     => true
		 *
		 * @param {Object} object
		 * @returns {Boolean}
		 */
		_.isArray = platformImpl.isArray;

		/**
		 * Returns *true* if **value** is an Object.
		 *
		 * Examples:
		 *
		 *     _.isObject({});
		 *     //=> true
		 *     _.isObject(1);
		 *     //=> false
		 *
		 * @param {Object} value
		 * @return {Boolean}
		 */
		_.isObject = platformImpl.isObject;

		/**
		 * Return the number of values in the **list**.
		 *
		 * Example:
		 *
		 *     _.size({one : 1, two : 2, three : 3})
		 *     //=> 3
		 *
		 * @param {Object} list
		 * @return {Number}
		 */
		_.size = platformImpl.size;

		/**
		 * Converts the **list** (anything that can be iterated over), into a real Array.
		 * Useful for transmuting the arguments object.
		 *
		 * Example:
		 *
		 *     (function(){ return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
		 *     //=> [2, 3, 4]
		 *
		 * @param {Object} list
		 * @return {Array}
		 */
		_.toArray = platformImpl.toArray;


		/**
		 * Iterates over a **list** of elements, yielding each in turn to an **iterator** function.
		 * The **iterator** is bound to the **context** object, if one is passed.
		 * Each invocation of **iterator** is called with three arguments:
		 * *(element, index, list)*. If **list** is a JavaScript object,
		 * **iterator**'s arguments will be *(value, key, list)*.
		 *
		 * Example:
		 *     _.each([1, 2, 3], function(num){ alert(num) })
		 *     //=> alerts each number in turn...
		 *     _.each({one : 1, two : 2, three : 3}, function(num, key){ alert(num) })
		 *     //=> alerts each number in turn...
		 *
		 * @param {Array|Object} list An Array or an Object with key/value pairs
		 * @param {Function} iterator Iterator function. The arguments for this function will be *(element, index, list)*
		 * if object is an Array and *(value, key, list)* if it's an Object
		 * @param {Object} [context] The context in which the iterator should be bound to
		 * @returns {void}
		 */
		_.each = platformImpl.each;

		/**
		 * Produces a new array of values by mapping each value in **list** through a
		 * transformation function (**iterator**). If **list** is a JavaScript object, **iterator**'s
		 * arguments will be *(value, key, list)*.
		 *
		 * Example:
		 *
		 *     _.map([1, 2, 3], function(num){ return num * 3 })
		 *     //=> [3, 6, 9]
		 *
		 *     _.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3 })
		 *     //=> [3, 6, 9]
		 *
		 * @param {Array|Object} list An Array or an Object with key/value pairs
		 * @param {Function} iterator Iterator function. The arguments for this function will be *(element, index, list)*
		 * if object is an Array and *(value, key, list)* if it's an Object
		 * @param {Object} [context] The context in which the iterator should be bound to
		 * @returns {Array} Array with the values of **list** mapped through the **iterator** transformation function
		 */
		_.map = platformImpl.map;

		/**
		 * Returns the last element of an **array**. Passing **n** will return the last n elements of the array.
		 *
		 * Example:
		 *
		 *     _.last([5, 4, 3, 2, 1]);
		 *     //=> 1
		 *
		 * @param {Array} array
		 * @param {Number} [n]
		 * @return {Array|Object}
		 */
		_.last = platformImpl.last;

		/**
		 * Looks through each value in the **list**, returning an array of all the values that pass a
		 * truth test (**iterator**).
		 *
		 * Example:
		 *
		 *     var evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
		 *     //=> [2, 4, 6]
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Array}
		 */
		_.filter = platformImpl.filter;

		/**
		 * Does the object contain the given key?
		 *
		 * Example:
		 *
		 *     _.has({a: 1, b: 2, c: 3}, "b");
		 *     //=> true
		 *
		 * @param {Object} object
		 * @param {String} key
		 * @return {Boolean}
		 */
		_.has = platformImpl.has;

		/**
		 * Returns *true* if any of the values in the **list** pass the **iterator** truth test.
		 * Short-circuits and stops traversing the list if a *true* element is found.
		 *
		 * Example:
		 *
		 *     _.any([null, 0, 'yes', false], function(value) { return value; });
		 *     //=> true
		 *
		 * @param {Array} object
		 * @param {Function} iterator
		 * @param [context]
		 * @return {Boolean}
		 */
		_.any = platformImpl.any;

		/**
		 * Looks through each value in the **list**, returning the first one that passes a truth test (**iterator**).
		 * The function returns as soon as it finds an acceptable element, and doesn't traverse the entire list.
		 *
		 * Example:
		 *
		 *     var even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0 })
		 *     //=> 2
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Object}
		 */
		_.find = platformImpl.find;

		/**
		 * Invokes the given **iterator** function *n* times.
		 *
		 * Example:
		 *
		 *     _.times(3, function(){ genie.grantWish(); });
		 *
		 * @param {Number} n
		 * @param {Function} iterator
		 * @param {Object} [context]
		 */
		_.times = platformImpl.times;

		/**
		 * Copy all of the properties in the **source** objects over to the **destination** object,
		 * and return the **destination** object. It's in-order, so the last source will override
		 * properties of the same name in previous arguments.
		 *
		 * Example:
		 *
		 *     _.extend({name : 'moe'}, {age : 50});
		 *     //=> {name : 'moe', age : 50}
		 *
		 * @param {Object} destination
		 * @param {Object...} sources
		 * @return {Object}
		 */
		_.extend = platformImpl.extend;

		/**
		 * Returns *true* if all of the values in the **list** pass the **iterator** truth test.
		 *
		 * Example:
		 *
		 *     _.all([true, 1, null, 'yes'], function(value) { return value; });
		 *     //=> false
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @returns {Boolean}
		 */
		_.all = platformImpl.all;

		/**
		 * A function to create flexibly-numbered lists of integers, handy for each and map loops.
		 * Returns a list of integers from **start** to **stop**, incremented (or decremented) by **step**.
		 *
		 * Examples:
		 *
		 *     _.range(10);
		 *     //=> [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
		 *     _.range(1, 11);
		 *     //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
		 *     _.range(0, 30, 5);
		 *     //=> [0, 5, 10, 15, 20, 25]
		 *     _.range(0, -10, -1);
		 *     //=> [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
		 *     _.range(0, 0);
		 *     => []
		 *
		 * @param {Number} start
		 * @param {Number} stop
		 * @param {Number} [step] defaults to 1 of omitted
		 * @return {Array}
		 */
		_.range = platformImpl.range;

		/**
		 * **reduce** boils down a list of values into a single value.
		 * **memo** is the initial state of the reduction, and each successive step of it should be returned by iterator.
		 *
		 * Example:
		 *
		 *     var sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num }, 0)
		 *     //=> 6
		 *
		 * @param {Array} list An array holding the values over which this functions iterates. Each value will be
		 * passed to the iterator function.
		 * @param {Function} iterator Iterator function which is called with the arguments **(memo, value, index, list)**
		 * @param {Object} [memo] Any object (e.g. a String or Number) that should be passed as initial value
		 * to the iterator function
		 * @param {Object} [context] Context in which the iterator should be called
		 * @return {Object}
		 */
		_.reduce = platformImpl.reduce;

		/**
		 * Bind a **function** to an **object**, meaning that whenever the function is called,
		 * the value of *this* will be the **object**. Optionally, bind **arguments** to the **function**
		 * to pre-fill them, also known as partial application.
		 *
		 * Example:
		 *
		 *     var func = function(greeting){ return greeting + ': ' + this.name };
		 *     func = _.bind(func, {name : 'moe'}, 'hi');
		 *     func();
		 *     //=> 'hi: moe'
		 *
		 * @param {Function} function
		 * @param {Object} object
		 * @param {Object...} [arguments]
		 * @return {Function}
		 */
		_.bind = platformImpl.bind;

		/**
		 * Returns the values in **list** without the elements that the truth test (**iterator**) passes.
		 * The opposite of {@link #filter}.
		 *
		 * Example:
		 *
		 *     var odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });
		 *     //=> [1, 3, 5]
		 *
		 * @param {Array} list
		 * @param {Function} iterator
		 * @param {Object} [context]
		 * @return {Array}
		 */
		_.reject = platformImpl.reject;

		/**
		 * Create a shallow-copied clone of the **object**. Any nested objects or arrays will be
		 * copied by reference, not duplicated.
		 *
		 * Example:
		 *
		 *     _.clone({name : 'moe'});
		 *     //=> {name : 'moe'};
		 *
		 * @param {Object} object
		 * @return {Object}
		 */
		_.clone = platformImpl.clone;

		/**
		 * Fill in missing properties in **object** with default values from the **defaults** objects,
		 * and return the object. As soon as the property is filled, further defaults will have no effect.
		 *
		 * Example:
		 *
		 *     var iceCream = {flavor : "chocolate"};
		 *     _.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});
		 *     //=> {flavor : "chocolate", sprinkles : "lots"}
		 *
		 *
		 * @param {Object} object
		 * @param {Object...} defaults
		 * @return {Object}
		 */
		_.defaults = platformImpl.defaults;

		/**
		 * Returns the index at which **value** can be found in the **array**, or -1 if value is not present
		 * in the **array**.  If you're working with a large array, and you know that the array is already
		 * sorted, pass *true* for **isSorted** to use a faster binary search.
		 *
		 * Example:
		 *
		 *     _.indexOf([1, 2, 3], 2);
		 *     //=> 1
		 *
		 * @param {Array} array
		 * @param {Object} value
		 * @param {Boolean} [isSorted]
		 * @return {Number}
		 */
		_.indexOf = platformImpl.indexOf;

		/**
		 * Returns true if object is a String.
		 *
		 *     _.isString("moe");
		 *     //=> true
		 *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isString = platformImpl.isString;

		/**
		 * Returns *true* if **object** contains no values.
		 *
		 * Example:
		 *
		 *     _.isEmpty([1, 2, 3]);
		 *     //=> false
		 *     _.isEmpty({});
		 *     //=> true
         *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isEmpty = platformImpl.isEmpty;

		/**
		 * Retrieve all the names of the **object**'s properties.
		 *
		 * Example:
		 *
		 *     _.keys({one : 1, two : 2, three : 3});
		 *     //=> ["one", "two", "three"]
		 *
		 * @param {Object} object
		 * @returns {Array}
		 */
		_.keys = platformImpl.keys;

		/**
		 * Returns true if object is a Function.
		 *
		 * Example:
		 *
		 *     _.isFunction(alert);
		 *     //=> true
		 *
		 * @param {Object} object
		 * @return {Boolean}
		 */
		_.isFunction = platformImpl.isFunction;

		/**
		 * Returns *true* if the **value** is present in the **list**, using === to test equality.
		 *
		 * Example:
		 *
		 *     _.contains([1, 2, 3], 3);
		 *     //=> true
		 *
		 * @param {Array} list
		 * @param {Object} value
		 * @return {Boolean}
		 */
		_.contains = platformImpl.contains;

		/**
		 * Calls the method named by **methodName** on each value in the list. Any extra **arguments**
		 * passed to invoke will be forwarded on to the method invocation.
		 *
		 * Example:
		 *
		 *     _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
		 *     //=> [[1, 5, 7], [1, 2, 3]]
		 *
		 * @param {Array} list
		 * @param {String} methodName
		 * @param {Object...} arguments
		 * @return {Array}
		 */
		_.invoke = platformImpl.invoke;

		/**
		 * Flattens a nested **array** (the nesting can be to any depth). If you pass **shallow**,
		 * the array will only be flattened a single level.
		 *
		 * Examples:
		 *
		 *     _.flatten([1, [2], [3, [[4]]]]);
		 *     //=> [1, 2, 3, 4];
		 *
		 *     _.flatten([1, [2], [3, [[4]]]], true);
		 *     //=> [1, 2, 3, [[4]]];
		 *
		 * @param {Array} array
		 * @param {Boolean} shallow
		 * @return {Array}
		 */
		_.flatten = platformImpl.flatten;

		/**
		 * Return a copy of the **object**, filtered to only have values for the whitelisted keys specified in **keys**.
		 *
		 * Example:
		 *
		 *     _.pick({name : 'moe', age: 50, userid : 'moe1'}, ['name', 'age']);
		 *     //=> {name : 'moe', age : 50}
		 *
		 * @param {Object} object
		 * @param {Array} keys Array containing the keys for the whitelist in **object**
		 * @return {Object}
		 */
		_.pick = platformImpl.pick;

		/**
		 * Computes the union of the passed-in **arrays**: the list of unique items, in order,
		 * that are present in one or more of the **arrays**.
		 *
		 * Example:
		 *
		 *     _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
		 *     //=> [1, 2, 3, 101, 10]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.union = platformImpl.union;

		/**
		 * Returns the values from **array** that are not present in the **other** arrays.
		 *
		 * Example:
		 *
		 *     _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
		 *     //=> [1, 3, 4]
		 *
		 * @param {Array} array
		 * @param {Array...} others
		 * @return {Array}
		 */
		_.difference = platformImpl.difference;

		/**
		 * Return all of the values of the **object**'s properties.
		 *
		 * Example:
		 *
		 *     _.values({one : 1, two : 2, three : 3});
		 *     //=> [1, 2, 3]
		 *
		 * @param {Object} object
		 * @return {Array}
		 */
		_.values = platformImpl.values;

		/**
		 * Produces a duplicate-free version of the **array**, using === to test object equality.
		 * If you know in advance that the array is sorted, passing *true* for **isSorted** will run a much faster
		 * algorithm.
		 *
		 * Example:
		 *     _.uniq([1, 2, 1, 3, 1, 4]);
		 *     //=> [1, 2, 3, 4]
		 *
		 * @param {Array} array
		 * @param {Boolean} [isSorted]
		 * @return {Array}
		 */
		_.unique = platformImpl.unique;

		/**
		 * Returns everything but the last entry of the **array**.
		 * Especially useful on the arguments object. Pass **n** to exclude the last n elements from the result.
		 *
		 * Example:
		 *
		 *     _.initial([5, 4, 3, 2, 1]);
		 *     //=> [5, 4, 3, 2]
		 *
		 * @param {Array} array
		 * @param {Number} [n] Exclude the last n elments from the result
		 * @return {Array}
		 */
		_.initial = platformImpl.initial;

		/**
		 * A convenient version of what is perhaps the most common use-case for {@link #map}:
		 * extracting a list of property values.
		 *
		 * Example:
		 *
		 *     var stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];
		 *     _.pluck(stooges, 'name');
		 *     //=> ["moe", "larry", "curly"]
		 *
		 * @param {Array} list Array with associative arrays in it
		 * @param {String|Number} propertyName key that will be used to lookup the value in the elements of **list**
		 * @return {Array}
		 */
		_.pluck = platformImpl.pluck;

		/**
		 * Merges together the values of each of the **arrays** with the values at the corresponding position.
		 * Useful when you have separate data sources that are coordinated through matching array indexes.
		 *
		 * Example:
		 *
		 *     _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
		 *     //=> [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.zip = platformImpl.zip;

		/**
		 * Creates a version of the function that can only be called one time. Repeated calls to the modified function will have no effect, returning the value
		 * from the original call. Useful for initialization functions, instead of having to set a boolean flag and then check it later.
		 *
		 * Example:
		 *
		 *     var initialize = _.once( createApplication )
		 *     initialize()
		 *     initialize()
		 *     // Application is only created once.
		 *
		 * @param {Function} function The callback function to call on the first time.
		 */
		_.once = platformImpl.once;

		/**
		 * Creates a version of the function that will only be run after first being called count times. Useful for
		 * grouping asynchronous responses, where you want to be sure that all the async calls have finished, before
		 * proceeding.
		 *
		 * Example:
		 *
		 *     var lock = _.after( 3, function() { // resuming with doing stuff after third call to "lock" function } )
		 *
		 * @param {Number} count The count after which the callback function is called.
		 * @param {Function} function The callback function to call after the **count** times.
		 */
		_.after = platformImpl.after;

		/**
		 * Computes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.
		 *
		 * Example:
		 *
		 *     _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
		 *     //=> [1, 2]
		 *
		 * @param {Array...} arrays
		 * @return {Array}
		 */
		_.intersection = platformImpl.intersection;

		/**
		 * Returns true if object is NaN.
		 * Note: this is not the same as the native isNaN function, which will also return true if the variable is undefined.
		 *
		 * @param {Object} Number
		 */
		_.isNaN = platformImpl.isNaN;

		/**
		 * Returns the same value that is used as the argument. In math: f(x) = x
		 * This function looks useless, but is used throughout Underscore as a default iterator.
		 *
		 *     var moe = {name : 'moe'};
		 *     moe === _.identity(moe);
		 *     //=> true
		 */
		_.identity = platformImpl.identity;

		return _
	}
)

define(
	'spell/client/development/createMessageDispatcher',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var createMatchingId = function( idToHandler, searchedId ) {
			if( searchedId.charAt( 0 ) === '.' ) {
				searchedId = searchedId.substring( 1 )
			}

			for( var id in idToHandler ) {
				if( searchedId.lastIndexOf( id, 0 ) === 0 ) {
					return id
				}
			}
		}

		var createRemainingId = function( id, matchingId ) {
			return id.substring( matchingId.length + 1 )
		}

		return function( idToHandler ) {
			return function( message, id, processedId ) {
				if( !processedId ) processedId = ''

				var matchingId = createMatchingId( idToHandler, id ),
					handler    = idToHandler[ matchingId ]

				if( !handler ) {
					throw 'Error: No handler for message with id \'' + processedId + ( processedId !== '' ? '.' : '' ) + id + '\' found.'
				}

				var remainingId = createRemainingId( id, matchingId )

				handler( message, remainingId, processedId + matchingId )
			}
		}
	}
)

define(
	'spell/client/development/createDebugMessageHandler',
	[
		'spell/client/development/createMessageDispatcher',
		'spell/client/development/createComponentMessageHandler',
		'spell/client/development/createEntityMessageHandler',
		'spell/client/development/createLibraryMessageHandler',
		'spell/client/development/createApplicationMessageHandler',
		'spell/client/development/createSettingsMessageHandler',
		'spell/client/development/createSystemMessageHandler'
	],
	function(
		createMessageDispatcher,
		createComponentMessageHandler,
		createEntityMessageHandler,
		createLibraryMessageHandler,
		createApplicationMessageHandler,
		createSettingsMessageHandler,
		createSystemMessageHandler
	) {
		'use strict'


		return function( spell, startEngine ) {
			return createMessageDispatcher( {
				'spell.debug.component'   : createComponentMessageHandler( spell ),
				'spell.debug.entity'      : createEntityMessageHandler( spell ),
				'spell.debug.library'     : createLibraryMessageHandler( spell ),
				'spell.debug.application' : createApplicationMessageHandler( spell, startEngine ),
				'spell.debug.settings'    : createSettingsMessageHandler( spell ),
				'spell.debug.system'      : createSystemMessageHandler( spell )
			} )
		}
	}
)

define(
	'spell/math/random/XorShift32',
	function() {
		'use strict'


		/**
		 * XorShift32 is a pseudo random number generator. It generates the next number in a sequence by repeatly applying a sequence of bit operations. You can use it
		 * to generate a sequence of random numbers. Since the algorithm is deterministic the generated sequence depends only on the chosen seed.
		 *
		 * Example:
		 *
		 *     // new instance of XorShift32 with seed 12345
		 *     var prng = new XorShift32( 12345 );
		 *
		 *     // always returns the same pseudo random number sequence depending on the seed
		 *     var number1 = prng.{@link #next}();
		 *     var number2 = prng.{@link #next}();
		 *
		 * @class spell.math.random.XorShift32
		 * @constructor
		 */
		var XorShift32 = function( seed ) {
			this.x = seed
		}

		XorShift32.prototype = {
			/**
			 * Returns the next number in the sequence.
			 *
			 * @return {Number}
			 */
			next : function() {
				var a = this.x,
					b = a

				a <<= 13
				b ^= a

				a >>= 17
				b ^= a

				a <<= 5
				b ^= a


				this.x = b

				return ( b + 2147483648 ) * ( 1 / 4294967296 )
			},

			/**
			 * Returns the next number between min and max in the sequence.
			 *
			 * @param {Number} min The minimum value
			 * @param {Number} max The maximum value
			 * @return {Number}
			 */
			nextBetween : function( min, max ) {
				return ( min + this.next() * ( max - min ) )
			},

			/**
			 * Returns the next integer between min and max in the sequence.
			 *
			 * @param {Number} min The minimum value
			 * @param {Number} max The maximum value
			 * @return {Number}
			 */
			nextIntegerBetween : function( min, max ) {
				return Math.round( this.nextBetween( Math.ceil( min ), Math.floor( max ) ) )
			}
		}

		return XorShift32
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec2',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 2d vector functions
		 *
		 * @class spell.math.vec2
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec2 = {};

		/**
		 * Creates a new, empty vec2
		 *
		 * @returns {vec2} a new 2d vector
		 */
		vec2.create = function() {
		    var out = Types.createFloatArray(2);
		    out[0] = 0;
		    out[1] = 0;
		    return out;
		};

		/**
		 * Creates a new vec2 initialized with values from an existing vector
		 *
		 * @param {vec2} a vector to clone
		 * @returns {vec2} a new 2d vector
		 */
		vec2.clone = function(a) {
		    var out = Types.createFloatArray(2);
		    out[0] = a[0];
		    out[1] = a[1];
		    return out;
		};

		/**
		 * Creates a new vec2 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @returns {vec2} a new 2d vector
		 */
		vec2.fromValues = function(x, y) {
		    var out = Types.createFloatArray(2);
		    out[0] = x;
		    out[1] = y;
		    return out;
		};

		/**
		 * Copy the values from one vec2 to another
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the source vector
		 * @returns {vec2} out
		 */
		vec2.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    return out;
		};

		/**
		 * Set the components of a vec2 to the given values
		 *
		 * @param {vec2} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @returns {vec2} out
		 */
		vec2.set = function(out, x, y) {
		    out[0] = x;
		    out[1] = y;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec2.sub = vec2.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec2.mul = vec2.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec2.div = vec2.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec2} out
		 */
		vec2.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    return out;
		};

		/**
		 * Scales a vec2 by a scalar number
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec2} out
		 */
		vec2.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec2} out
		 */
		vec2.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec2.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1];
		    return Math.sqrt(x*x + y*y);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec2.dist = vec2.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec2.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1];
		    return x*x + y*y;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec2.sqrDist = vec2.squaredDistance;

		/**
		 * Calculates the length of a vec2
		 *
		 * @param {vec2} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec2.length = function (a) {
		    var x = a[0],
		        y = a[1];
		    return Math.sqrt(x*x + y*y);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec2.len = vec2.length;

		/**
		 * Calculates the squared length of a vec2
		 *
		 * @param {vec2} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec2.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1];
		    return x*x + y*y;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec2.sqrLen = vec2.squaredLength;

		/**
		 * Negates the components of a vec2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a vector to negate
		 * @returns {vec2} out
		 */
		vec2.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    return out;
		};

		/**
		 * Normalize a vec2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a vector to normalize
		 * @returns {vec2} out
		 */
		vec2.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1];
		    var len = x*x + y*y;
		    if (len > 0) {
		        //TODO: evaluate use of glm_invsqrt here?
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec2.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1];
		};

		/**
		 * Computes the cross product of two vectors
		 * Note that the cross product must by definition produce a 3D vector
		 *
		 * @param {vec3} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @returns {vec3} out
		 */
		vec2.cross = function(out, a, b) {
		    var z = a[0] * b[1] - a[1] * b[0];
		    out[0] = out[1] = 0;
		    out[2] = z;
		    return out;
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the first operand
		 * @param {vec2} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec2} out
		 */
		vec2.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec2} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec2} out
		 */
		vec2.random = function (out, scale) {
		    scale = scale || 1.0;
		    var r = mathUtil.random() * 2.0 * Math.PI;
		    out[0] = Math.cos(r) * scale;
		    out[1] = Math.sin(r) * scale;
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat2
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat2} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat2 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[2] * y;
		    out[1] = m[1] * x + m[3] * y;
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat2d
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat2d} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat2d = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[2] * y + m[4];
		    out[1] = m[1] * x + m[3] * y + m[5];
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat3
		 * 3rd vector component is implicitly '1'
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat3} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat3 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[3] * y + m[6];
		    out[1] = m[1] * x + m[4] * y + m[7];
		    return out;
		};

		/**
		 * Transforms the vec2 with a mat4
		 * 3rd vector component is implicitly '0'
		 * 4th vector component is implicitly '1'
		 *
		 * @param {vec2} out the result vector
		 * @param {vec2} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec2} out
		 */
		vec2.transformMat4 = function(out, a, m) {
		    var x = a[0],
		        y = a[1];
		    out[0] = m[0] * x + m[4] * y + m[12];
		    out[1] = m[1] * x + m[5] * y + m[13];
		    return out;
		};

		/**
		 * Perform some operation over an array of vec2s.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec2. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec2.forEach = (function() {
		    var vec = vec2.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 2;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec2} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec2.str = function (a) {
		    return 'vec2(' + a[0] + ', ' + a[1] + ')';
		};

		return vec2;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec4',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 4d vector functions
		 *
		 * @class spell.math.vec4
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec4 = {};

		/**
		 * Creates a new, empty vec4
		 *
		 * @returns {vec4} a new 4d vector
		 */
		vec4.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    return out;
		};

		/**
		 * Creates a new vec4 initialized with values from an existing vector
		 *
		 * @param {vec4} a vector to clone
		 * @returns {vec4} a new 4d vector
		 */
		vec4.clone = function(a) {
		    var out = Types.createFloatArray(4);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Creates a new vec4 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {vec4} a new 4d vector
		 */
		vec4.fromValues = function(x, y, z, w) {
		    var out = Types.createFloatArray(4);
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = w;
		    return out;
		};

		/**
		 * Copy the values from one vec4 to another
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the source vector
		 * @returns {vec4} out
		 */
		vec4.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Set the components of a vec4 to the given values
		 *
		 * @param {vec4} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {vec4} out
		 */
		vec4.set = function(out, x, y, z, w) {
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = w;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    out[2] = a[2] + b[2];
		    out[3] = a[3] + b[3];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    out[2] = a[2] - b[2];
		    out[3] = a[3] - b[3];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec4.sub = vec4.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    out[2] = a[2] * b[2];
		    out[3] = a[3] * b[3];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec4.mul = vec4.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    out[2] = a[2] / b[2];
		    out[3] = a[3] / b[3];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec4.div = vec4.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    out[2] = Math.min(a[2], b[2]);
		    out[3] = Math.min(a[3], b[3]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {vec4} out
		 */
		vec4.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    out[2] = Math.max(a[2], b[2]);
		    out[3] = Math.max(a[3], b[3]);
		    return out;
		};

		/**
		 * Scales a vec4 by a scalar number
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec4} out
		 */
		vec4.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    out[2] = a[2] * b;
		    out[3] = a[3] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec4} out
		 */
		vec4.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    out[2] = a[2] + (b[2] * scale);
		    out[3] = a[3] + (b[3] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec4.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2],
		        w = b[3] - a[3];
		    return Math.sqrt(x*x + y*y + z*z + w*w);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec4.dist = vec4.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec4.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2],
		        w = b[3] - a[3];
		    return x*x + y*y + z*z + w*w;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec4.sqrDist = vec4.squaredDistance;

		/**
		 * Calculates the length of a vec4
		 *
		 * @param {vec4} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec4.length = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    return Math.sqrt(x*x + y*y + z*z + w*w);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec4.len = vec4.length;

		/**
		 * Calculates the squared length of a vec4
		 *
		 * @param {vec4} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec4.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    return x*x + y*y + z*z + w*w;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec4.sqrLen = vec4.squaredLength;

		/**
		 * Negates the components of a vec4
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a vector to negate
		 * @returns {vec4} out
		 */
		vec4.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] = -a[3];
		    return out;
		};

		/**
		 * Normalize a vec4
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a vector to normalize
		 * @returns {vec4} out
		 */
		vec4.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2],
		        w = a[3];
		    var len = x*x + y*y + z*z + w*w;
		    if (len > 0) {
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		        out[2] = a[2] * len;
		        out[3] = a[3] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec4.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the first operand
		 * @param {vec4} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec4} out
		 */
		vec4.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1],
		        az = a[2],
		        aw = a[3];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    out[2] = az + t * (b[2] - az);
		    out[3] = aw + t * (b[3] - aw);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec4} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec4} out
		 */
		vec4.random = function (out, scale) {
		    scale = scale || 1.0;

		    //TODO: This is a pretty awful way of doing this. Find something better.
		    out[0] = mathUtil.random();
		    out[1] = mathUtil.random();
		    out[2] = mathUtil.random();
		    out[3] = mathUtil.random();
		    vec4.normalize(out, out);
		    vec4.scale(out, out, scale);
		    return out;
		};

		/**
		 * Transforms the vec4 with a mat4.
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec4} out
		 */
		vec4.transformMat4 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2], w = a[3];
		    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12] * w;
		    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13] * w;
		    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14] * w;
		    out[3] = m[3] * x + m[7] * y + m[11] * z + m[15] * w;
		    return out;
		};

		/**
		 * Transforms the vec4 with a quat
		 *
		 * @param {vec4} out the result vector
		 * @param {vec4} a the vector to transform
		 * @param {quat} q quaternion to transform with
		 * @returns {vec4} out
		 */
		vec4.transformQuat = function(out, a, q) {
		    var x = a[0], y = a[1], z = a[2],
		        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

		        // calculate quat * vec
		        ix = qw * x + qy * z - qz * y,
		        iy = qw * y + qz * x - qx * z,
		        iz = qw * z + qx * y - qy * x,
		        iw = -qx * x - qy * y - qz * z;

		    // calculate result * inverse quat
		    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		    return out;
		};

		/**
		 * Perform some operation over an array of vectors.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec4. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec2s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec4.forEach = (function() {
		    var vec = vec4.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 4;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2]; vec[3] = a[i+3];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2]; a[i+3] = vec[3];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec4} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec4.str = function (a) {
		    return 'vec4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return vec4;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/vec3',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 3d vector functions
		 *
		 * @class spell.math.vec3
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var vec3 = {};

		/**
		 * Creates a new, empty vec3
		 *
		 * @returns {vec3} a new 3d vector
		 */
		vec3.create = function() {
		    var out = Types.createFloatArray(3);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    return out;
		};

		/**
		 * Creates a new vec3 initialized with values from an existing vector
		 *
		 * @param {vec3} a vector to clone
		 * @returns {vec3} a new 3d vector
		 */
		vec3.clone = function(a) {
		    var out = Types.createFloatArray(3);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    return out;
		};

		/**
		 * Creates a new vec3 initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @returns {vec3} a new 3d vector
		 */
		vec3.fromValues = function(x, y, z) {
		    var out = Types.createFloatArray(3);
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    return out;
		};

		/**
		 * Copy the values from one vec3 to another
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the source vector
		 * @returns {vec3} out
		 */
		vec3.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    return out;
		};

		/**
		 * Set the components of a vec3 to the given values
		 *
		 * @param {vec3} out the result vector
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @returns {vec3} out
		 */
		vec3.set = function(out, x, y, z) {
		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    return out;
		};

		/**
		 * Adds two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.add = function(out, a, b) {
		    out[0] = a[0] + b[0];
		    out[1] = a[1] + b[1];
		    out[2] = a[2] + b[2];
		    return out;
		};

		/**
		 * Subtracts vector b from vector a
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.subtract = function(out, a, b) {
		    out[0] = a[0] - b[0];
		    out[1] = a[1] - b[1];
		    out[2] = a[2] - b[2];
		    return out;
		};

		/**
		 * Alias for {@link #subtract}
		 *
		 * @property {Function}
		 */
		vec3.sub = vec3.subtract;

		/**
		 * Multiplies two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.multiply = function(out, a, b) {
		    out[0] = a[0] * b[0];
		    out[1] = a[1] * b[1];
		    out[2] = a[2] * b[2];
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		vec3.mul = vec3.multiply;

		/**
		 * Divides two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.divide = function(out, a, b) {
		    out[0] = a[0] / b[0];
		    out[1] = a[1] / b[1];
		    out[2] = a[2] / b[2];
		    return out;
		};

		/**
		 * Alias for {@link #divide}
		 *
		 * @property {Function}
		 */
		vec3.div = vec3.divide;

		/**
		 * Returns the minimum of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.min = function(out, a, b) {
		    out[0] = Math.min(a[0], b[0]);
		    out[1] = Math.min(a[1], b[1]);
		    out[2] = Math.min(a[2], b[2]);
		    return out;
		};

		/**
		 * Returns the maximum of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.max = function(out, a, b) {
		    out[0] = Math.max(a[0], b[0]);
		    out[1] = Math.max(a[1], b[1]);
		    out[2] = Math.max(a[2], b[2]);
		    return out;
		};

		/**
		 * Scales a vec3 by a scalar number
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {vec3} out
		 */
		vec3.scale = function(out, a, b) {
		    out[0] = a[0] * b;
		    out[1] = a[1] * b;
		    out[2] = a[2] * b;
		    return out;
		};

		/**
		 * Adds two vectors after scaling the second operand by a scalar value
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @param {Number} scale the amount to scale b by before adding
		 * @returns {vec3} out
		 */
		vec3.scaleAndAdd = function(out, a, b, scale) {
		    out[0] = a[0] + (b[0] * scale);
		    out[1] = a[1] + (b[1] * scale);
		    out[2] = a[2] + (b[2] * scale);
		    return out;
		};

		/**
		 * Calculates the euclidian distance between two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} distance between a and b
		 */
		vec3.distance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2];
		    return Math.sqrt(x*x + y*y + z*z);
		};

		/**
		 * Alias for {@link #distance}
		 *
		 * @property {Function}
		 */
		vec3.dist = vec3.distance;

		/**
		 * Calculates the squared euclidian distance between two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} squared distance between a and b
		 */
		vec3.squaredDistance = function(a, b) {
		    var x = b[0] - a[0],
		        y = b[1] - a[1],
		        z = b[2] - a[2];
		    return x*x + y*y + z*z;
		};

		/**
		 * Alias for {@link #squaredDistance}
		 *
		 * @property {Function}
		 */
		vec3.sqrDist = vec3.squaredDistance;

		/**
		 * Calculates the length of a vec3
		 *
		 * @param {vec3} a vector to calculate length of
		 * @returns {Number} length of a
		 */
		vec3.length = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    return Math.sqrt(x*x + y*y + z*z);
		};

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		vec3.len = vec3.length;

		/**
		 * Calculates the squared length of a vec3
		 *
		 * @param {vec3} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 */
		vec3.squaredLength = function (a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    return x*x + y*y + z*z;
		};

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		vec3.sqrLen = vec3.squaredLength;

		/**
		 * Negates the components of a vec3
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a vector to negate
		 * @returns {vec3} out
		 */
		vec3.negate = function(out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    return out;
		};

		/**
		 * Normalize a vec3
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a vector to normalize
		 * @returns {vec3} out
		 */
		vec3.normalize = function(out, a) {
		    var x = a[0],
		        y = a[1],
		        z = a[2];
		    var len = x*x + y*y + z*z;
		    if (len > 0) {
		        //TODO: evaluate use of glm_invsqrt here?
		        len = 1 / Math.sqrt(len);
		        out[0] = a[0] * len;
		        out[1] = a[1] * len;
		        out[2] = a[2] * len;
		    }
		    return out;
		};

		/**
		 * Calculates the dot product of two vectors
		 *
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {Number} dot product of a and b
		 */
		vec3.dot = function (a, b) {
		    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
		};

		/**
		 * Computes the cross product of two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @returns {vec3} out
		 */
		vec3.cross = function(out, a, b) {
		    var ax = a[0], ay = a[1], az = a[2],
		        bx = b[0], by = b[1], bz = b[2];

		    out[0] = ay * bz - az * by;
		    out[1] = az * bx - ax * bz;
		    out[2] = ax * by - ay * bx;
		    return out;
		};

		/**
		 * Performs a linear interpolation between two vectors
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the first operand
		 * @param {vec3} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {vec3} out
		 */
		vec3.lerp = function (out, a, b, t) {
		    var ax = a[0],
		        ay = a[1],
		        az = a[2];
		    out[0] = ax + t * (b[0] - ax);
		    out[1] = ay + t * (b[1] - ay);
		    out[2] = az + t * (b[2] - az);
		    return out;
		};

		/**
		 * Generates a random vector with the given scale
		 *
		 * @param {vec3} out the result vector
		 * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned
		 * @returns {vec3} out
		 */
		vec3.random = function (out, scale) {
		    scale = scale || 1.0;

		    var r = mathUtil.random() * 2.0 * Math.PI;
		    var z = (mathUtil.random() * 2.0) - 1.0;
		    var zScale = Math.sqrt(1.0-z*z) * scale;

		    out[0] = Math.cos(r) * zScale;
		    out[1] = Math.sin(r) * zScale;
		    out[2] = z * scale;
		    return out;
		};

		/**
		 * Transforms the vec3 with a mat4.
		 * 4th vector component is implicitly '1'
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {mat4} m matrix to transform with
		 * @returns {vec3} out
		 */
		vec3.transformMat4 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2];
		    out[0] = m[0] * x + m[4] * y + m[8] * z + m[12];
		    out[1] = m[1] * x + m[5] * y + m[9] * z + m[13];
		    out[2] = m[2] * x + m[6] * y + m[10] * z + m[14];
		    return out;
		};

		/**
		 * Transforms the vec3 with a mat3.
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {mat4} m the 3x3 matrix to transform with
		 * @returns {vec3} out
		 */
		vec3.transformMat3 = function(out, a, m) {
		    var x = a[0], y = a[1], z = a[2];
		    out[0] = x * m[0] + y * m[3] + z * m[6];
		    out[1] = x * m[1] + y * m[4] + z * m[7];
		    out[2] = x * m[2] + y * m[5] + z * m[8];
		    return out;
		};

		/**
		 * Transforms the vec3 with a quat
		 *
		 * @param {vec3} out the result vector
		 * @param {vec3} a the vector to transform
		 * @param {quat} q quaternion to transform with
		 * @returns {vec3} out
		 */
		vec3.transformQuat = function(out, a, q) {
		    // benchmarks: http://jsperf.com/quaternion-transform-vec3-implementations

		    var x = a[0], y = a[1], z = a[2],
		        qx = q[0], qy = q[1], qz = q[2], qw = q[3],

		        // calculate quat * vec
		        ix = qw * x + qy * z - qz * y,
		        iy = qw * y + qz * x - qx * z,
		        iz = qw * z + qx * y - qy * x,
		        iw = -qx * x - qy * y - qz * z;

		    // calculate result * inverse quat
		    out[0] = ix * qw + iw * -qx + iy * -qz - iz * -qy;
		    out[1] = iy * qw + iw * -qy + iz * -qx - ix * -qz;
		    out[2] = iz * qw + iw * -qz + ix * -qy - iy * -qx;
		    return out;
		};

		/**
		 * Perform some operation over an array of vec3s.
		 *
		 * @param {Array} a the array of vectors to iterate over
		 * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed
		 * @param {Number} offset Number of elements to skip at the beginning of the array
		 * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array
		 * @param {Function} fn Function to call for each vector in the array
		 * @param {Object} [arg] additional argument to pass to fn
		 * @returns {Array} a
		 * @function
		 */
		vec3.forEach = (function() {
		    var vec = vec3.create();

		    return function(a, stride, offset, count, fn, arg) {
		        var i, l;
		        if(!stride) {
		            stride = 3;
		        }

		        if(!offset) {
		            offset = 0;
		        }

		        if(count) {
		            l = Math.min((count * stride) + offset, a.length);
		        } else {
		            l = a.length;
		        }

		        for(i = offset; i < l; i += stride) {
		            vec[0] = a[i]; vec[1] = a[i+1]; vec[2] = a[i+2];
		            fn(vec, vec, arg);
		            a[i] = vec[0]; a[i+1] = vec[1]; a[i+2] = vec[2];
		        }

		        return a;
		    };
		})();

		/**
		 * Returns a string representation of a vector
		 *
		 * @param {vec3} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		vec3.str = function (a) {
		    return 'vec3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ')';
		};

		return vec3;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/quat',
	[
		'spell/shared/util/platform/Types',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/mat3'
	],
	function(
		Types,
		vec3,
		vec4,
		mat3
	) {
		'use strict'

		/**
		 * quaternion functions
		 *
		 * @class spell.math.quat
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.vec3
		 * @requires spell.math.vec4
		 * @requires spell.math.mat3
		 */
		var quat = {};

		/**
		 * Creates a new identity quat
		 *
		 * @returns {quat} a new quaternion
		 */
		quat.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Sets a quaternion to represent the shortest rotation from one
		 * vector to another.
		 *
		 * Both vectors are assumed to be unit length.
		 *
		 * @param {quat} out the receiving quaternion.
		 * @param {vec3} a the initial vector
		 * @param {vec3} b the destination vector
		 * @returns {quat} out
		 */
		quat.rotationTo = (function() {
		    var tmpvec3 = vec3.create();
		    var xUnitVec3 = vec3.fromValues(1,0,0);
		    var yUnitVec3 = vec3.fromValues(0,1,0);

		    return function(out, a, b) {
		        var dot = vec3.dot(a, b);
		        if (dot < -0.999999) {
		            vec3.cross(tmpvec3, xUnitVec3, a);
		            if (vec3.length(tmpvec3) < 0.000001)
		                vec3.cross(tmpvec3, yUnitVec3, a);
		            vec3.normalize(tmpvec3, tmpvec3);
		            quat.setAxisAngle(out, tmpvec3, Math.PI);
		            return out;
		        } else if (dot > 0.999999) {
		            out[0] = 0;
		            out[1] = 0;
		            out[2] = 0;
		            out[3] = 1;
		            return out;
		        } else {
		            vec3.cross(tmpvec3, a, b);
		            out[0] = tmpvec3[0];
		            out[1] = tmpvec3[1];
		            out[2] = tmpvec3[2];
		            out[3] = 1 + dot;
		            return quat.normalize(out, out);
		        }
		    };
		})();

		/**
		 * Sets the specified quaternion with values corresponding to the given
		 * axes. Each axis is a vec3 and is expected to be unit length and
		 * perpendicular to all other specified axes.
		 *
		 * @param {vec3} view  the vector representing the viewing direction
		 * @param {vec3} right the vector representing the local "right" direction
		 * @param {vec3} up    the vector representing the local "up" direction
		 * @returns {quat} out
		 */
		quat.setAxes = (function() {
		    var matr = mat3.create();

		    return function(out, view, right, up) {
		        matr[0] = right[0];
		        matr[3] = right[1];
		        matr[6] = right[2];

		        matr[1] = up[0];
		        matr[4] = up[1];
		        matr[7] = up[2];

		        matr[2] = view[0];
		        matr[5] = view[1];
		        matr[8] = view[2];

		        return quat.normalize(out, quat.fromMat3(out, matr));
		    };
		})();

		/**
		 * Creates a new quat initialized with values from an existing quaternion
		 *
		 * @param {quat} a quaternion to clone
		 * @returns {quat} a new quaternion
		 * @function
		 */
		quat.clone = vec4.clone;

		/**
		 * Creates a new quat initialized with the given values
		 *
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {quat} a new quaternion
		 * @function
		 */
		quat.fromValues = vec4.fromValues;

		/**
		 * Copy the values from one quat to another
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the source quaternion
		 * @returns {quat} out
		 * @function
		 */
		quat.copy = vec4.copy;

		/**
		 * Set the components of a quat to the given values
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {Number} x X component
		 * @param {Number} y Y component
		 * @param {Number} z Z component
		 * @param {Number} w W component
		 * @returns {quat} out
		 * @function
		 */
		quat.set = vec4.set;

		/**
		 * Set a quat to the identity quaternion
		 *
		 * @param {quat} out the receiving quaternion
		 * @returns {quat} out
		 */
		quat.identity = function(out) {
		    out[0] = 0;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Sets a quat from the given angle and rotation axis,
		 * then returns it.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {vec3} axis the axis around which to rotate
		 * @param {Number} rad the angle in radians
		 * @returns {quat} out
		 **/
		quat.setAxisAngle = function(out, axis, rad) {
		    rad = rad * 0.5;
		    var s = Math.sin(rad);
		    out[0] = s * axis[0];
		    out[1] = s * axis[1];
		    out[2] = s * axis[2];
		    out[3] = Math.cos(rad);
		    return out;
		};

		/**
		 * Adds two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {quat} out
		 * @function
		 */
		quat.add = vec4.add;

		/**
		 * Multiplies two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {quat} out
		 */
		quat.multiply = function(out, a, b) {
		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = b[0], by = b[1], bz = b[2], bw = b[3];

		    out[0] = ax * bw + aw * bx + ay * bz - az * by;
		    out[1] = ay * bw + aw * by + az * bx - ax * bz;
		    out[2] = az * bw + aw * bz + ax * by - ay * bx;
		    out[3] = aw * bw - ax * bx - ay * by - az * bz;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		quat.mul = quat.multiply;

		/**
		 * Scales a quat by a scalar number
		 *
		 * @param {quat} out the receiving vector
		 * @param {quat} a the vector to scale
		 * @param {Number} b amount to scale the vector by
		 * @returns {quat} out
		 * @function
		 */
		quat.scale = vec4.scale;

		/**
		 * Rotates a quaternion by the given angle about the X axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateX = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw + aw * bx;
		    out[1] = ay * bw + az * bx;
		    out[2] = az * bw - ay * bx;
		    out[3] = aw * bw - ax * bx;
		    return out;
		};

		/**
		 * Rotates a quaternion by the given angle about the Y axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateY = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        by = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw - az * by;
		    out[1] = ay * bw + aw * by;
		    out[2] = az * bw + ax * by;
		    out[3] = aw * bw - ay * by;
		    return out;
		};

		/**
		 * Rotates a quaternion by the given angle about the Z axis
		 *
		 * @param {quat} out quat receiving operation result
		 * @param {quat} a quat to rotate
		 * @param {number} rad angle (in radians) to rotate
		 * @returns {quat} out
		 */
		quat.rotateZ = function (out, a, rad) {
		    rad *= 0.5;

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bz = Math.sin(rad), bw = Math.cos(rad);

		    out[0] = ax * bw + ay * bz;
		    out[1] = ay * bw - ax * bz;
		    out[2] = az * bw + aw * bz;
		    out[3] = aw * bw - az * bz;
		    return out;
		};

		/**
		 * Calculates the W component of a quat from the X, Y, and Z components.
		 * Assumes that quaternion is 1 unit in length.
		 * Any existing W component will be ignored.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate W component of
		 * @returns {quat} out
		 */
		quat.calculateW = function (out, a) {
		    var x = a[0], y = a[1], z = a[2];

		    out[0] = x;
		    out[1] = y;
		    out[2] = z;
		    out[3] = -Math.sqrt(Math.abs(1.0 - x * x - y * y - z * z));
		    return out;
		};

		/**
		 * Calculates the dot product of two quaternions
		 *
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @returns {Number} dot product of a and b
		 * @function
		 */
		quat.dot = vec4.dot;

		/**
		 * Performs a linear interpolation between two quaternions
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {quat} out
		 * @function
		 */
		quat.lerp = vec4.lerp;

		/**
		 * Performs a spherical linear interpolation between two quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a the first operand
		 * @param {quat} b the second operand
		 * @param {Number} t interpolation amount between the two inputs
		 * @returns {quat} out
		 */
		quat.slerp = function (out, a, b, t) {
		    // benchmarks:
		    //    http://jsperf.com/quaternion-slerp-implementations

		    var ax = a[0], ay = a[1], az = a[2], aw = a[3],
		        bx = b[0], by = b[1], bz = b[2], bw = b[3];

		    var        omega, cosom, sinom, scale0, scale1;

		    // calc cosine
		    cosom = ax * bx + ay * by + az * bz + aw * bw;
		    // adjust signs (if necessary)
		    if ( cosom < 0.0 ) {
		        cosom = -cosom;
		        bx = - bx;
		        by = - by;
		        bz = - bz;
		        bw = - bw;
		    }
		    // calculate coefficients
		    if ( (1.0 - cosom) > 0.000001 ) {
		        // standard case (slerp)
		        omega  = Math.acos(cosom);
		        sinom  = Math.sin(omega);
		        scale0 = Math.sin((1.0 - t) * omega) / sinom;
		        scale1 = Math.sin(t * omega) / sinom;
		    } else {
		        // "from" and "to" quaternions are very close
		        //  ... so we can do a linear interpolation
		        scale0 = 1.0 - t;
		        scale1 = t;
		    }
		    // calculate final values
		    out[0] = scale0 * ax + scale1 * bx;
		    out[1] = scale0 * ay + scale1 * by;
		    out[2] = scale0 * az + scale1 * bz;
		    out[3] = scale0 * aw + scale1 * bw;

		    return out;
		};

		/**
		 * Calculates the inverse of a quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate inverse of
		 * @returns {quat} out
		 */
		quat.invert = function(out, a) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        dot = a0*a0 + a1*a1 + a2*a2 + a3*a3,
		        invDot = dot ? 1.0/dot : 0;

		    // TODO: Would be faster to return [0,0,0,0] immediately if dot == 0

		    out[0] = -a0*invDot;
		    out[1] = -a1*invDot;
		    out[2] = -a2*invDot;
		    out[3] = a3*invDot;
		    return out;
		};

		/**
		 * Calculates the conjugate of a quat
		 * If the quaternion is normalized, this function is faster than quat.inverse and produces the same result.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quat to calculate conjugate of
		 * @returns {quat} out
		 */
		quat.conjugate = function (out, a) {
		    out[0] = -a[0];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Alias for {@link spell.math.vec4#length}
		 *
		 * @property {Function}
		 */
		quat.length = vec4.length;

		/**
		 * Alias for {@link #length}
		 *
		 * @property {Function}
		 */
		quat.len = quat.length;

		/**
		 * Calculates the squared length of a quat
		 *
		 * @param {quat} a vector to calculate squared length of
		 * @returns {Number} squared length of a
		 * @function
		 */
		quat.squaredLength = vec4.squaredLength;

		/**
		 * Alias for {@link #squaredLength}
		 *
		 * @property {Function}
		 */
		quat.sqrLen = quat.squaredLength;

		/**
		 * Normalize a quat
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {quat} a quaternion to normalize
		 * @returns {quat} out
		 * @function
		 */
		quat.normalize = vec4.normalize;

		/**
		 * Creates a quaternion from the given 3x3 rotation matrix.
		 *
		 * NOTE: The resultant quaternion is not normalized, so you should be sure
		 * to renormalize the quaternion yourself where necessary.
		 *
		 * @param {quat} out the receiving quaternion
		 * @param {mat3} m rotation matrix
		 * @returns {quat} out
		 * @function
		 */
		quat.fromMat3 = (function() {
		    // benchmarks:
		    //    http://jsperf.com/typed-array-access-speed
		    //    http://jsperf.com/conversion-of-3x3-matrix-to-quaternion

		    var s_iNext = Types.Int8Array.fromValues( [ 1, 2, 0 ] )

		    return function(out, m) {
		        // Algorithm in Ken Shoemake's article in 1987 SIGGRAPH course notes
		        // article "Quaternion Calculus and Fast Animation".
		        var fTrace = m[0] + m[4] + m[8];
		        var fRoot;

		        if ( fTrace > 0.0 ) {
		            // |w| > 1/2, may as well choose w > 1/2
		            fRoot = Math.sqrt(fTrace + 1.0);  // 2w
		            out[3] = 0.5 * fRoot;
		            fRoot = 0.5/fRoot;  // 1/(4w)
		            out[0] = (m[7]-m[5])*fRoot;
		            out[1] = (m[2]-m[6])*fRoot;
		            out[2] = (m[3]-m[1])*fRoot;
		        } else {
		            // |w| <= 1/2
		            var i = 0;
		            if ( m[4] > m[0] )
		              i = 1;
		            if ( m[8] > m[i*3+i] )
		              i = 2;
		            var j = s_iNext[i];
		            var k = s_iNext[j];

		            fRoot = Math.sqrt(m[i*3+i]-m[j*3+j]-m[k*3+k] + 1.0);
		            out[i] = 0.5 * fRoot;
		            fRoot = 0.5 / fRoot;
		            out[3] = (m[k*3+j] - m[j*3+k]) * fRoot;
		            out[j] = (m[j*3+i] + m[i*3+j]) * fRoot;
		            out[k] = (m[k*3+i] + m[i*3+k]) * fRoot;
		        }

		        return out;
		    };
		})();

		/**
		 * Returns a string representation of a quatenion
		 *
		 * @param {quat} vec vector to represent as a string
		 * @returns {String} string representation of the vector
		 */
		quat.str = function (a) {
		    return 'quat(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return quat;
	}
)

/**
 * Utility math functions.
 *
 * @singleton
 * @class spell.math.util
 */
define(
	'spell/math/util',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		var util = {}

		util.FLOAT_EPSILON = 0.000001

		util.random = Math.random

		if( Types.hasFloatArraySupport() ) {
			var y = Types.createFloatArray( 1 )
			var i = Types.Int32Array.create( y.buffer )

			/**
			 * Fast way to calculate the inverse square root. See http://jsperf.com/inverse-square-root/5.
			 * If typed arrays are not available, a slower implementation will be used.
			 *
			 * @private
			 */
			util.invsqrt = function( x ) {
				var x2 = x * 0.5
				y[ 0 ] = x
				var threehalfs = 1.5

				i[ 0 ] = 0x5f3759df - ( i[ 0 ] >> 1 )

				var x3 = y[ 0 ]

				return x3 * ( threehalfs - ( x2 * x3 * x3 ) )
			};

		} else {
			/**
			 * Returns the inverse square root of the value x.
			 *
			 * @param {Number} x
			 * @returns {Number}
			 */
			util.invsqrt = function( x ) {
				return 1.0 / Math.sqrt( x )
			};
		}

		/**
		 * Clamps the value into the range specified by lowerBound and upperBound.
		 *
		 * @param {Number} value
		 * @param {Number} lowerBound
		 * @param {Number} upperBound
		 * @return {Number}
		 */
		util.clamp = function( value, lowerBound, upperBound ) {
			if( value < lowerBound ) return lowerBound
			if( value > upperBound ) return upperBound

			return value
		};

		/**
		 * Returns true when the value lies within in the interval specified by lowerBound and upperBound.
		 *
		 * @param value
		 * @param lowerBound
		 * @param upperBound
		 * @return {Boolean}
		 */
		util.isInInterval = function( value, lowerBound, upperBound ) {
			return ( value >= lowerBound && value <= upperBound )
		};

		/**
		 * Returns the modulo of dividend and divisor. The result is always positive (i.e. a positive member of the quotient ring defined by dividend % divisor).
		 *
		 * @param {Number} dividend
		 * @param {Number} divisor
		 * @return {Number}
		 */
		util.modulo = function( dividend, divisor ) {
			var tmp = dividend % divisor

			return tmp < 0 ?
				( tmp + divisor ) % divisor :
				tmp
		};

		/**
		 * Returns the sign of the supplied value x.
		 *
		 * Example:
		 *
		 *     util.sign( 2 ) // -> 1
		 *     util.sign( -5 ) // -> -1
		 *
		 * @param {Number} x
		 * @return {Number}
		 */
		util.sign = function( x ) {
			return x >= 0 ? 1 : -1
		};

		/**
		 * Rounds the value to multiples of resolution.
		 *
		 * Example:
		 *
		 *     util.roundToResolution( 5, 0.6 ) // -> 4.8
		 *     util.roundToResolution( 1233, 10 ) // -> 1230
		 *
		 * @param {Number} value
		 * @param {Number} resolution
		 * @return {Number}
		 */
		util.roundToResolution = function( value, resolution ) {
			if( !resolution ) resolution = 0.5

			var rest = value % resolution

   			return value - rest + ( rest > ( resolution / 2 ) ? resolution : 0 )
		};

		/**
		 * Checks whether a point is contained in a (rotated) rectangle or not.
		 *
		 * @param {vec2} point point to check
		 * @param {vec2} rectOrigin point the original from the rectangle (in the middle)
		 * @param {Number} rectWidth width of the rectangle
		 * @param {Number} rectHeight height of the rectangle
		 * @param {Number} rectRotation rotation in radians
		 * @return {Boolean}
		 */
		util.isPointInRect = function( point, rectOrigin, rectWidth, rectHeight, rectRotation ) {
			var tmp     = rectRotation, // Math.PI / 180
				c       = Math.cos( tmp ),
				s       = Math.sin( tmp ),
				leftX   = rectOrigin[ 0 ] - rectWidth / 2,
				rightX  = rectOrigin[ 0 ] + rectWidth / 2,
				topY    = rectOrigin[ 1 ] - rectHeight / 2,
				bottomY = rectOrigin[ 1 ] + rectHeight / 2

			// unrotate the point depending on the rotation of the rectangle
			var rotatedX = rectOrigin[ 0 ] + c * ( point[ 0 ] - rectOrigin[ 0 ] ) - s * ( point[ 1 ] - rectOrigin[ 1 ] ),
				rotatedY = rectOrigin[ 1 ] + s * ( point[ 0 ] - rectOrigin[ 0 ] ) + c * ( point[ 1 ] - rectOrigin[ 1 ] )

			return leftX <= rotatedX && rotatedX <= rightX && topY <= rotatedY && rotatedY <= bottomY
		};

		/**
		 * Returns an orthographic projection matrix specified by the four clippings.
		 *
		 * @param {mat3} out the result mat3 matrix
		 * @param {Number} left the left clipping
		 * @param {Number} right the right clipping
		 * @param {Number} bottom the bottom clipping
		 * @param {Number} top the top clipping
		 * @return {mat3}
		 */
		util.mat3Ortho = function( out, left, right, bottom, top ) {
			var rl = ( right - left ),
				tb = ( top - bottom )

			out[ 0 ] = 2 / rl
			out[ 1 ] = 0
			out[ 2 ] = 0
			out[ 3 ] = 0
			out[ 4 ] = 2 / tb
			out[ 5 ] = 0
			out[ 6 ] = -( left + right ) / rl
			out[ 7 ] = -( top + bottom ) / tb
			out[ 8 ] = 1

			return out
		};

		/**
		 * A triangle wave function. The output range is -1 to 1.
		 *
		 * @param {Number} t
		 * @param {Number} a
		 * @return {Number}
		 */
		util.triangle = function( t, a ) {
			if( a == 0 ) return 0

			var ta = t / a

			return 2 * Math.abs( 2 * ( ta - Math.floor( ta + 0.5 ) ) ) - 1
		}

		return util
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat4',
	[
		'spell/shared/util/platform/Types',
		'spell/math/util'
	],
	function(
		Types,
		mathUtil
	) {
		'use strict'


		/**
		 * 4x4 matrix functions
		 *
		 * @class spell.math.mat4
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 * @requires spell.math.util
		 */
		var mat4 = {};

		/**
		 * Creates a new identity mat4
		 *
		 * @returns {mat4} a new 4x4 matrix
		 */
		mat4.create = function() {
		    var out = Types.createFloatArray(16);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = 1;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 1;
		    out[11] = 0;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Creates a new mat4 initialized with values from an existing matrix
		 *
		 * @param {mat4} a matrix to clone
		 * @returns {mat4} a new 4x4 matrix
		 */
		mat4.clone = function(a) {
		    var out = Types.createFloatArray(16);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    out[9] = a[9];
		    out[10] = a[10];
		    out[11] = a[11];
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Copy the values from one mat4 to another
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    out[9] = a[9];
		    out[10] = a[10];
		    out[11] = a[11];
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Set a mat4 to the identity matrix
		 *
		 * @param {mat4} out the receiving matrix
		 * @returns {mat4} out
		 */
		mat4.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = 1;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 1;
		    out[11] = 0;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a01 = a[1], a02 = a[2], a03 = a[3],
		            a12 = a[6], a13 = a[7],
		            a23 = a[11];

		        out[1] = a[4];
		        out[2] = a[8];
		        out[3] = a[12];
		        out[4] = a01;
		        out[6] = a[9];
		        out[7] = a[13];
		        out[8] = a02;
		        out[9] = a12;
		        out[11] = a[14];
		        out[12] = a03;
		        out[13] = a13;
		        out[14] = a23;
		    } else {
		        out[0] = a[0];
		        out[1] = a[4];
		        out[2] = a[8];
		        out[3] = a[12];
		        out[4] = a[1];
		        out[5] = a[5];
		        out[6] = a[9];
		        out[7] = a[13];
		        out[8] = a[2];
		        out[9] = a[6];
		        out[10] = a[10];
		        out[11] = a[14];
		        out[12] = a[3];
		        out[13] = a[7];
		        out[14] = a[11];
		        out[15] = a[15];
		    }

		    return out;
		};

		/**
		 * Inverts a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.invert = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32,

		        // Calculate the determinant
		        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det;
		    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det;
		    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det;
		    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det;
		    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det;
		    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det;
		    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det;
		    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det;
		    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det;
		    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det;

		    return out;
		};

		/**
		 * Calculates the adjugate of a mat4
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the source matrix
		 * @returns {mat4} out
		 */
		mat4.adjoint = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

		    out[0]  =  (a11 * (a22 * a33 - a23 * a32) - a21 * (a12 * a33 - a13 * a32) + a31 * (a12 * a23 - a13 * a22));
		    out[1]  = -(a01 * (a22 * a33 - a23 * a32) - a21 * (a02 * a33 - a03 * a32) + a31 * (a02 * a23 - a03 * a22));
		    out[2]  =  (a01 * (a12 * a33 - a13 * a32) - a11 * (a02 * a33 - a03 * a32) + a31 * (a02 * a13 - a03 * a12));
		    out[3]  = -(a01 * (a12 * a23 - a13 * a22) - a11 * (a02 * a23 - a03 * a22) + a21 * (a02 * a13 - a03 * a12));
		    out[4]  = -(a10 * (a22 * a33 - a23 * a32) - a20 * (a12 * a33 - a13 * a32) + a30 * (a12 * a23 - a13 * a22));
		    out[5]  =  (a00 * (a22 * a33 - a23 * a32) - a20 * (a02 * a33 - a03 * a32) + a30 * (a02 * a23 - a03 * a22));
		    out[6]  = -(a00 * (a12 * a33 - a13 * a32) - a10 * (a02 * a33 - a03 * a32) + a30 * (a02 * a13 - a03 * a12));
		    out[7]  =  (a00 * (a12 * a23 - a13 * a22) - a10 * (a02 * a23 - a03 * a22) + a20 * (a02 * a13 - a03 * a12));
		    out[8]  =  (a10 * (a21 * a33 - a23 * a31) - a20 * (a11 * a33 - a13 * a31) + a30 * (a11 * a23 - a13 * a21));
		    out[9]  = -(a00 * (a21 * a33 - a23 * a31) - a20 * (a01 * a33 - a03 * a31) + a30 * (a01 * a23 - a03 * a21));
		    out[10] =  (a00 * (a11 * a33 - a13 * a31) - a10 * (a01 * a33 - a03 * a31) + a30 * (a01 * a13 - a03 * a11));
		    out[11] = -(a00 * (a11 * a23 - a13 * a21) - a10 * (a01 * a23 - a03 * a21) + a20 * (a01 * a13 - a03 * a11));
		    out[12] = -(a10 * (a21 * a32 - a22 * a31) - a20 * (a11 * a32 - a12 * a31) + a30 * (a11 * a22 - a12 * a21));
		    out[13] =  (a00 * (a21 * a32 - a22 * a31) - a20 * (a01 * a32 - a02 * a31) + a30 * (a01 * a22 - a02 * a21));
		    out[14] = -(a00 * (a11 * a32 - a12 * a31) - a10 * (a01 * a32 - a02 * a31) + a30 * (a01 * a12 - a02 * a11));
		    out[15] =  (a00 * (a11 * a22 - a12 * a21) - a10 * (a01 * a22 - a02 * a21) + a20 * (a01 * a12 - a02 * a11));
		    return out;
		};

		/**
		 * Calculates the determinant of a mat4
		 *
		 * @param {mat4} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat4.determinant = function (a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32;

		    // Calculate the determinant
		    return b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the first operand
		 * @param {mat4} b the second operand
		 * @returns {mat4} out
		 */
		mat4.multiply = function (out, a, b) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];

		    // Cache only the current line of the second matrix
		    var b0  = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
		    out[0] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[1] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[2] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[3] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[4]; b1 = b[5]; b2 = b[6]; b3 = b[7];
		    out[4] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[5] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[6] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[7] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[8]; b1 = b[9]; b2 = b[10]; b3 = b[11];
		    out[8] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[9] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[10] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[11] = b0*a03 + b1*a13 + b2*a23 + b3*a33;

		    b0 = b[12]; b1 = b[13]; b2 = b[14]; b3 = b[15];
		    out[12] = b0*a00 + b1*a10 + b2*a20 + b3*a30;
		    out[13] = b0*a01 + b1*a11 + b2*a21 + b3*a31;
		    out[14] = b0*a02 + b1*a12 + b2*a22 + b3*a32;
		    out[15] = b0*a03 + b1*a13 + b2*a23 + b3*a33;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat4.mul = mat4.multiply;

		/**
		 * Translate a mat4 by the given vector
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to translate
		 * @param {vec3} v vector to translate by
		 * @returns {mat4} out
		 */
		mat4.translate = function (out, a, v) {
		    var x = v[0], y = v[1], z = v[2],
		        a00, a01, a02, a03,
		        a10, a11, a12, a13,
		        a20, a21, a22, a23;

		    if (a === out) {
		        out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
		        out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
		        out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
		        out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
		    } else {
		        a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
		        a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
		        a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

		        out[0] = a00; out[1] = a01; out[2] = a02; out[3] = a03;
		        out[4] = a10; out[5] = a11; out[6] = a12; out[7] = a13;
		        out[8] = a20; out[9] = a21; out[10] = a22; out[11] = a23;

		        out[12] = a00 * x + a10 * y + a20 * z + a[12];
		        out[13] = a01 * x + a11 * y + a21 * z + a[13];
		        out[14] = a02 * x + a12 * y + a22 * z + a[14];
		        out[15] = a03 * x + a13 * y + a23 * z + a[15];
		    }

		    return out;
		};

		/**
		 * Scales the mat4 by the dimensions in the given vec3
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to scale
		 * @param {vec3} v the vec3 to scale the matrix by
		 * @returns {mat4} out
		 **/
		mat4.scale = function(out, a, v) {
		    var x = v[0], y = v[1], z = v[2];

		    out[0] = a[0] * x;
		    out[1] = a[1] * x;
		    out[2] = a[2] * x;
		    out[3] = a[3] * x;
		    out[4] = a[4] * y;
		    out[5] = a[5] * y;
		    out[6] = a[6] * y;
		    out[7] = a[7] * y;
		    out[8] = a[8] * z;
		    out[9] = a[9] * z;
		    out[10] = a[10] * z;
		    out[11] = a[11] * z;
		    out[12] = a[12];
		    out[13] = a[13];
		    out[14] = a[14];
		    out[15] = a[15];
		    return out;
		};

		/**
		 * Rotates a mat4 by the given angle
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @param {vec3} axis the axis to rotate around
		 * @returns {mat4} out
		 */
		mat4.rotate = function (out, a, rad, axis) {
		    var x = axis[0], y = axis[1], z = axis[2],
		        len = Math.sqrt(x * x + y * y + z * z),
		        s, c, t,
		        a00, a01, a02, a03,
		        a10, a11, a12, a13,
		        a20, a21, a22, a23,
		        b00, b01, b02,
		        b10, b11, b12,
		        b20, b21, b22;

		    if (Math.abs(len) < mathUtil.FLOAT_EPSILON) { return null; }

		    len = 1 / len;
		    x *= len;
		    y *= len;
		    z *= len;

		    s = Math.sin(rad);
		    c = Math.cos(rad);
		    t = 1 - c;

		    a00 = a[0]; a01 = a[1]; a02 = a[2]; a03 = a[3];
		    a10 = a[4]; a11 = a[5]; a12 = a[6]; a13 = a[7];
		    a20 = a[8]; a21 = a[9]; a22 = a[10]; a23 = a[11];

		    // Construct the elements of the rotation matrix
		    b00 = x * x * t + c; b01 = y * x * t + z * s; b02 = z * x * t - y * s;
		    b10 = x * y * t - z * s; b11 = y * y * t + c; b12 = z * y * t + x * s;
		    b20 = x * z * t + y * s; b21 = y * z * t - x * s; b22 = z * z * t + c;

		    // Perform rotation-specific matrix multiplication
		    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
		    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
		    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
		    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
		    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
		    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
		    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
		    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
		    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
		    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
		    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
		    out[11] = a03 * b20 + a13 * b21 + a23 * b22;

		    if (a !== out) { // If the source and destination differ, copy the unchanged last row
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the X axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateX = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a10 = a[4],
		        a11 = a[5],
		        a12 = a[6],
		        a13 = a[7],
		        a20 = a[8],
		        a21 = a[9],
		        a22 = a[10],
		        a23 = a[11];

		    if (a !== out) { // If the source and destination differ, copy the unchanged rows
		        out[0]  = a[0];
		        out[1]  = a[1];
		        out[2]  = a[2];
		        out[3]  = a[3];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[4] = a10 * c + a20 * s;
		    out[5] = a11 * c + a21 * s;
		    out[6] = a12 * c + a22 * s;
		    out[7] = a13 * c + a23 * s;
		    out[8] = a20 * c - a10 * s;
		    out[9] = a21 * c - a11 * s;
		    out[10] = a22 * c - a12 * s;
		    out[11] = a23 * c - a13 * s;
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the Y axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateY = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a00 = a[0],
		        a01 = a[1],
		        a02 = a[2],
		        a03 = a[3],
		        a20 = a[8],
		        a21 = a[9],
		        a22 = a[10],
		        a23 = a[11];

		    if (a !== out) { // If the source and destination differ, copy the unchanged rows
		        out[4]  = a[4];
		        out[5]  = a[5];
		        out[6]  = a[6];
		        out[7]  = a[7];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[0] = a00 * c - a20 * s;
		    out[1] = a01 * c - a21 * s;
		    out[2] = a02 * c - a22 * s;
		    out[3] = a03 * c - a23 * s;
		    out[8] = a00 * s + a20 * c;
		    out[9] = a01 * s + a21 * c;
		    out[10] = a02 * s + a22 * c;
		    out[11] = a03 * s + a23 * c;
		    return out;
		};

		/**
		 * Rotates a matrix by the given angle around the Z axis
		 *
		 * @param {mat4} out the receiving matrix
		 * @param {mat4} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat4} out
		 */
		mat4.rotateZ = function (out, a, rad) {
		    var s = Math.sin(rad),
		        c = Math.cos(rad),
		        a00 = a[0],
		        a01 = a[1],
		        a02 = a[2],
		        a03 = a[3],
		        a10 = a[4],
		        a11 = a[5],
		        a12 = a[6],
		        a13 = a[7];

		    if (a !== out) { // If the source and destination differ, copy the unchanged last row
		        out[8]  = a[8];
		        out[9]  = a[9];
		        out[10] = a[10];
		        out[11] = a[11];
		        out[12] = a[12];
		        out[13] = a[13];
		        out[14] = a[14];
		        out[15] = a[15];
		    }

		    // Perform axis-specific matrix multiplication
		    out[0] = a00 * c + a10 * s;
		    out[1] = a01 * c + a11 * s;
		    out[2] = a02 * c + a12 * s;
		    out[3] = a03 * c + a13 * s;
		    out[4] = a10 * c - a00 * s;
		    out[5] = a11 * c - a01 * s;
		    out[6] = a12 * c - a02 * s;
		    out[7] = a13 * c - a03 * s;
		    return out;
		};

		/**
		 * Creates a matrix from a quaternion rotation and vector translation
		 * This is equivalent to (but much faster than):
		 *
		 *     mat4.identity(dest);
		 *     mat4.translate(dest, vec);
		 *     var quatMat = mat4.create();
		 *     quat4.toMat4(quat, quatMat);
		 *     mat4.multiply(dest, quatMat);
		 *
		 * @param {mat4} out mat4 receiving operation result
		 * @param {quat4} q Rotation quaternion
		 * @param {vec3} v Translation vector
		 * @returns {mat4} out
		 */
		mat4.fromRotationTranslation = function (out, q, v) {
		    // Quaternion math
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[1] = xy + wz;
		    out[2] = xz - wy;
		    out[3] = 0;
		    out[4] = xy - wz;
		    out[5] = 1 - (xx + zz);
		    out[6] = yz + wx;
		    out[7] = 0;
		    out[8] = xz + wy;
		    out[9] = yz - wx;
		    out[10] = 1 - (xx + yy);
		    out[11] = 0;
		    out[12] = v[0];
		    out[13] = v[1];
		    out[14] = v[2];
		    out[15] = 1;

		    return out;
		};

		/**
		* Calculates a 4x4 matrix from the given quaternion
		*
		* @param {mat4} out mat4 receiving operation result
		* @param {quat} q Quaternion to create matrix from
		*
		* @returns {mat4} out
		*/
		mat4.fromQuat = function (out, q) {
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[1] = xy + wz;
		    out[2] = xz - wy;
		    out[3] = 0;

		    out[4] = xy - wz;
		    out[5] = 1 - (xx + zz);
		    out[6] = yz + wx;
		    out[7] = 0;

		    out[8] = xz + wy;
		    out[9] = yz - wx;
		    out[10] = 1 - (xx + yy);
		    out[11] = 0;

		    out[12] = 0;
		    out[13] = 0;
		    out[14] = 0;
		    out[15] = 1;

		    return out;
		};

		/**
		 * Generates a frustum matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {Number} left Left bound of the frustum
		 * @param {Number} right Right bound of the frustum
		 * @param {Number} bottom Bottom bound of the frustum
		 * @param {Number} top Top bound of the frustum
		 * @param {Number} near Near bound of the frustum
		 * @param {Number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.frustum = function (out, left, right, bottom, top, near, far) {
		    var rl = 1 / (right - left),
		        tb = 1 / (top - bottom),
		        nf = 1 / (near - far);
		    out[0] = (near * 2) * rl;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = (near * 2) * tb;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = (right + left) * rl;
		    out[9] = (top + bottom) * tb;
		    out[10] = (far + near) * nf;
		    out[11] = -1;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = (far * near * 2) * nf;
		    out[15] = 0;
		    return out;
		};

		/**
		 * Generates a perspective projection matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {number} fovy Vertical field of view in radians
		 * @param {number} aspect Aspect ratio. typically viewport width/height
		 * @param {number} near Near bound of the frustum
		 * @param {number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.perspective = function (out, fovy, aspect, near, far) {
		    var f = 1.0 / Math.tan(fovy / 2),
		        nf = 1 / (near - far);
		    out[0] = f / aspect;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = f;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = (far + near) * nf;
		    out[11] = -1;
		    out[12] = 0;
		    out[13] = 0;
		    out[14] = (2 * far * near) * nf;
		    out[15] = 0;
		    return out;
		};

		/**
		 * Generates a orthogonal projection matrix with the given bounds
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {number} left Left bound of the frustum
		 * @param {number} right Right bound of the frustum
		 * @param {number} bottom Bottom bound of the frustum
		 * @param {number} top Top bound of the frustum
		 * @param {number} near Near bound of the frustum
		 * @param {number} far Far bound of the frustum
		 * @returns {mat4} out
		 */
		mat4.ortho = function (out, left, right, bottom, top, near, far) {
		    var lr = 1 / (left - right),
		        bt = 1 / (bottom - top),
		        nf = 1 / (near - far);
		    out[0] = -2 * lr;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 0;
		    out[5] = -2 * bt;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 0;
		    out[9] = 0;
		    out[10] = 2 * nf;
		    out[11] = 0;
		    out[12] = (left + right) * lr;
		    out[13] = (top + bottom) * bt;
		    out[14] = (far + near) * nf;
		    out[15] = 1;
		    return out;
		};

		/**
		 * Generates a look-at matrix with the given eye position, focal point, and up axis
		 *
		 * @param {mat4} out mat4 frustum matrix will be written into
		 * @param {vec3} eye Position of the viewer
		 * @param {vec3} center Point the viewer is looking at
		 * @param {vec3} up vec3 pointing up
		 * @returns {mat4} out
		 */
		mat4.lookAt = function (out, eye, center, up) {
		    var x0, x1, x2, y0, y1, y2, z0, z1, z2, len,
		        eyex = eye[0],
		        eyey = eye[1],
		        eyez = eye[2],
		        upx = up[0],
		        upy = up[1],
		        upz = up[2],
		        centerx = center[0],
		        centery = center[1],
		        centerz = center[2];

		    if (Math.abs(eyex - centerx) < mathUtil.FLOAT_EPSILON &&
		        Math.abs(eyey - centery) < mathUtil.FLOAT_EPSILON &&
		        Math.abs(eyez - centerz) < mathUtil.FLOAT_EPSILON ) {
		        return mat4.identity(out);
		    }

		    z0 = eyex - centerx;
		    z1 = eyey - centery;
		    z2 = eyez - centerz;

		    len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
		    z0 *= len;
		    z1 *= len;
		    z2 *= len;

		    x0 = upy * z2 - upz * z1;
		    x1 = upz * z0 - upx * z2;
		    x2 = upx * z1 - upy * z0;
		    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
		    if (!len) {
		        x0 = 0;
		        x1 = 0;
		        x2 = 0;
		    } else {
		        len = 1 / len;
		        x0 *= len;
		        x1 *= len;
		        x2 *= len;
		    }

		    y0 = z1 * x2 - z2 * x1;
		    y1 = z2 * x0 - z0 * x2;
		    y2 = z0 * x1 - z1 * x0;

		    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
		    if (!len) {
		        y0 = 0;
		        y1 = 0;
		        y2 = 0;
		    } else {
		        len = 1 / len;
		        y0 *= len;
		        y1 *= len;
		        y2 *= len;
		    }

		    out[0] = x0;
		    out[1] = y0;
		    out[2] = z0;
		    out[3] = 0;
		    out[4] = x1;
		    out[5] = y1;
		    out[6] = z1;
		    out[7] = 0;
		    out[8] = x2;
		    out[9] = y2;
		    out[10] = z2;
		    out[11] = 0;
		    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
		    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
		    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
		    out[15] = 1;

		    return out;
		};

		/**
		 * Returns a string representation of a mat4
		 *
		 * @param {mat4} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat4.str = function (a) {
		    return 'mat4(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ', ' +
		                    a[4] + ', ' + a[5] + ', ' + a[6] + ', ' + a[7] + ', ' +
		                    a[8] + ', ' + a[9] + ', ' + a[10] + ', ' + a[11] + ', ' +
		                    a[12] + ', ' + a[13] + ', ' + a[14] + ', ' + a[15] + ')';
		};

		return mat4;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat3',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 3x3 matrix functions
		 *
		 * @class spell.math.mat3
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat3 = {};

		/**
		 * Creates a new identity mat3
		 *
		 * @returns {mat3} a new 3x3 matrix
		 */
		mat3.create = function() {
		    var out = Types.createFloatArray(9);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 1;
		    out[5] = 0;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 1;
		    return out;
		};

		/**
		 * Copies the upper-left 3x3 values into the given mat3.
		 *
		 * @param {mat3} out the receiving 3x3 matrix
		 * @param {mat4} a   the source 4x4 matrix
		 * @returns {mat3} out
		 */
		mat3.fromMat4 = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[4];
		    out[4] = a[5];
		    out[5] = a[6];
		    out[6] = a[8];
		    out[7] = a[9];
		    out[8] = a[10];
		    return out;
		};

		/**
		 * Creates a new mat3 initialized with values from an existing matrix
		 *
		 * @param {mat3} a matrix to clone
		 * @returns {mat3} a new 3x3 matrix
		 */
		mat3.clone = function(a) {
		    var out = Types.createFloatArray(9);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Copy the values from one mat3 to another
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Set a mat3 to the identity matrix
		 *
		 * @param {mat3} out the receiving matrix
		 * @returns {mat3} out
		 */
		mat3.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 0;
		    out[4] = 1;
		    out[5] = 0;
		    out[6] = 0;
		    out[7] = 0;
		    out[8] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a01 = a[1], a02 = a[2], a12 = a[5];
		        out[1] = a[3];
		        out[2] = a[6];
		        out[3] = a01;
		        out[5] = a[7];
		        out[6] = a02;
		        out[7] = a12;
		    } else {
		        out[0] = a[0];
		        out[1] = a[3];
		        out[2] = a[6];
		        out[3] = a[1];
		        out[4] = a[4];
		        out[5] = a[7];
		        out[6] = a[2];
		        out[7] = a[5];
		        out[8] = a[8];
		    }

		    return out;
		};

		/**
		 * Inverts a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.invert = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        b01 = a22 * a11 - a12 * a21,
		        b11 = -a22 * a10 + a12 * a20,
		        b21 = a21 * a10 - a11 * a20,

		        // Calculate the determinant
		        det = a00 * b01 + a01 * b11 + a02 * b21;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = b01 * det;
		    out[1] = (-a22 * a01 + a02 * a21) * det;
		    out[2] = (a12 * a01 - a02 * a11) * det;
		    out[3] = b11 * det;
		    out[4] = (a22 * a00 - a02 * a20) * det;
		    out[5] = (-a12 * a00 + a02 * a10) * det;
		    out[6] = b21 * det;
		    out[7] = (-a21 * a00 + a01 * a20) * det;
		    out[8] = (a11 * a00 - a01 * a10) * det;
		    return out;
		};

		/**
		 * Calculates the adjugate of a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the source matrix
		 * @returns {mat3} out
		 */
		mat3.adjoint = function(out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8];

		    out[0] = (a11 * a22 - a12 * a21);
		    out[1] = (a02 * a21 - a01 * a22);
		    out[2] = (a01 * a12 - a02 * a11);
		    out[3] = (a12 * a20 - a10 * a22);
		    out[4] = (a00 * a22 - a02 * a20);
		    out[5] = (a02 * a10 - a00 * a12);
		    out[6] = (a10 * a21 - a11 * a20);
		    out[7] = (a01 * a20 - a00 * a21);
		    out[8] = (a00 * a11 - a01 * a10);
		    return out;
		};

		/**
		 * Calculates the determinant of a mat3
		 *
		 * @param {mat3} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat3.determinant = function (a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8];

		    return a00 * (a22 * a11 - a12 * a21) + a01 * (-a22 * a10 + a12 * a20) + a02 * (a21 * a10 - a11 * a20);
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the first operand
		 * @param {mat3} b the second operand
		 * @returns {mat3} out
		 */
		mat3.multiply = function (out, a, b) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        b00 = b[0], b01 = b[1], b02 = b[2],
		        b10 = b[3], b11 = b[4], b12 = b[5],
		        b20 = b[6], b21 = b[7], b22 = b[8];

		    out[0] = b00 * a00 + b01 * a10 + b02 * a20;
		    out[1] = b00 * a01 + b01 * a11 + b02 * a21;
		    out[2] = b00 * a02 + b01 * a12 + b02 * a22;

		    out[3] = b10 * a00 + b11 * a10 + b12 * a20;
		    out[4] = b10 * a01 + b11 * a11 + b12 * a21;
		    out[5] = b10 * a02 + b11 * a12 + b12 * a22;

		    out[6] = b20 * a00 + b21 * a10 + b22 * a20;
		    out[7] = b20 * a01 + b21 * a11 + b22 * a21;
		    out[8] = b20 * a02 + b21 * a12 + b22 * a22;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat3.mul = mat3.multiply;

		/**
		 * Translate a mat3 by the given vector
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to translate
		 * @param {vec2} v vector to translate by
		 * @returns {mat3} out
		 */
		mat3.translate = function(out, a, v) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],
		        x = v[0], y = v[1];

		    out[0] = a00;
		    out[1] = a01;
		    out[2] = a02;

		    out[3] = a10;
		    out[4] = a11;
		    out[5] = a12;

		    out[6] = x * a00 + y * a10 + a20;
		    out[7] = x * a01 + y * a11 + a21;
		    out[8] = x * a02 + y * a12 + a22;
		    return out;
		};

		/**
		 * Rotates a mat3 by the given angle
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat3} out
		 */
		mat3.rotate = function (out, a, rad) {
		    var a00 = a[0], a01 = a[1], a02 = a[2],
		        a10 = a[3], a11 = a[4], a12 = a[5],
		        a20 = a[6], a21 = a[7], a22 = a[8],

		        s = Math.sin(rad),
		        c = Math.cos(rad);

		    out[0] = c * a00 + s * a10;
		    out[1] = c * a01 + s * a11;
		    out[2] = c * a02 + s * a12;

		    out[3] = c * a10 - s * a00;
		    out[4] = c * a11 - s * a01;
		    out[5] = c * a12 - s * a02;

		    out[6] = a20;
		    out[7] = a21;
		    out[8] = a22;
		    return out;
		};

		/**
		 * Scales the mat3 by the dimensions in the given vec2
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat3} a the matrix to rotate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat3} out
		 **/
		mat3.scale = function(out, a, v) {
		    var x = v[0], y = v[1];

		    out[0] = x * a[0];
		    out[1] = x * a[1];
		    out[2] = x * a[2];

		    out[3] = y * a[3];
		    out[4] = y * a[4];
		    out[5] = y * a[5];

		    out[6] = a[6];
		    out[7] = a[7];
		    out[8] = a[8];
		    return out;
		};

		/**
		 * Copies the values from a mat2d into a mat3
		 *
		 * @param {mat3} out the receiving matrix
		 * @param {mat2d} a the matrix to copy
		 * @returns {mat3} out
		 **/
		mat3.fromMat2d = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = 0;

		    out[3] = a[2];
		    out[4] = a[3];
		    out[5] = 0;

		    out[6] = a[4];
		    out[7] = a[5];
		    out[8] = 1;
		    return out;
		};

		/**
		* Calculates a 3x3 matrix from the given quaternion
		*
		* @param {mat3} out mat3 receiving operation result
		* @param {quat} q Quaternion to create matrix from
		*
		* @returns {mat3} out
		*/
		mat3.fromQuat = function (out, q) {
		    var x = q[0], y = q[1], z = q[2], w = q[3],
		        x2 = x + x,
		        y2 = y + y,
		        z2 = z + z,

		        xx = x * x2,
		        xy = x * y2,
		        xz = x * z2,
		        yy = y * y2,
		        yz = y * z2,
		        zz = z * z2,
		        wx = w * x2,
		        wy = w * y2,
		        wz = w * z2;

		    out[0] = 1 - (yy + zz);
		    out[3] = xy + wz;
		    out[6] = xz - wy;

		    out[1] = xy - wz;
		    out[4] = 1 - (xx + zz);
		    out[7] = yz + wx;

		    out[2] = xz + wy;
		    out[5] = yz - wx;
		    out[8] = 1 - (xx + yy);

		    return out;
		};

		/**
		* Calculates a 3x3 normal matrix (transpose inverse) from the 4x4 matrix
		*
		* @param {mat3} out mat3 receiving operation result
		* @param {mat4} a Mat4 to derive the normal matrix from
		*
		* @returns {mat3} out
		*/
		mat3.normalFromMat4 = function (out, a) {
		    var a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3],
		        a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7],
		        a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11],
		        a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15],

		        b00 = a00 * a11 - a01 * a10,
		        b01 = a00 * a12 - a02 * a10,
		        b02 = a00 * a13 - a03 * a10,
		        b03 = a01 * a12 - a02 * a11,
		        b04 = a01 * a13 - a03 * a11,
		        b05 = a02 * a13 - a03 * a12,
		        b06 = a20 * a31 - a21 * a30,
		        b07 = a20 * a32 - a22 * a30,
		        b08 = a20 * a33 - a23 * a30,
		        b09 = a21 * a32 - a22 * a31,
		        b10 = a21 * a33 - a23 * a31,
		        b11 = a22 * a33 - a23 * a32,

		        // Calculate the determinant
		        det = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det;
		    out[1] = (a12 * b08 - a10 * b11 - a13 * b07) * det;
		    out[2] = (a10 * b10 - a11 * b08 + a13 * b06) * det;

		    out[3] = (a02 * b10 - a01 * b11 - a03 * b09) * det;
		    out[4] = (a00 * b11 - a02 * b08 + a03 * b07) * det;
		    out[5] = (a01 * b08 - a00 * b10 - a03 * b06) * det;

		    out[6] = (a31 * b05 - a32 * b04 + a33 * b03) * det;
		    out[7] = (a32 * b02 - a30 * b05 - a33 * b01) * det;
		    out[8] = (a30 * b04 - a31 * b02 + a33 * b00) * det;

		    return out;
		};

		/**
		 * Returns a string representation of a mat3
		 *
		 * @param {mat3} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat3.str = function (a) {
		    return 'mat3(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
		                    a[3] + ', ' + a[4] + ', ' + a[5] + ', ' +
		                    a[6] + ', ' + a[7] + ', ' + a[8] + ')';
		};

		return mat3;
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat2d',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 3x2 matrix functions
		 *
		 * A mat2d contains six elements defined as:
		 * <pre>
		 * [a, b,
		 *  c, d,
		 *  tx,ty]
		 * </pre>
		 * This is a short form for the 3x3 matrix:
		 * <pre>
		 * [a, b, 0
		 *  c, d, 0
		 *  tx,ty,1]
		 * </pre>
		 * The last column is ignored so the array is shorter and operations are faster.
		 *
		 * @class spell.math.mat2d
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat2d = {};

		/**
		 * Creates a new identity mat2d
		 *
		 * @returns {mat2d} a new 2x3 matrix
		 */
		mat2d.create = function() {
		    var out = Types.createFloatArray(6);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    out[4] = 0;
		    out[5] = 0;
		    return out;
		};

		/**
		 * Creates a new mat2d initialized with values from an existing matrix
		 *
		 * @param {mat2d} a matrix to clone
		 * @returns {mat2d} a new 2x3 matrix
		 */
		mat2d.clone = function(a) {
		    var out = Types.createFloatArray(6);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    return out;
		};

		/**
		 * Copy the values from one mat2d to another
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the source matrix
		 * @returns {mat2d} out
		 */
		mat2d.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4];
		    out[5] = a[5];
		    return out;
		};

		/**
		 * Set a mat2d to the identity matrix
		 *
		 * @param {mat2d} out the receiving matrix
		 * @returns {mat2d} out
		 */
		mat2d.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    out[4] = 0;
		    out[5] = 0;
		    return out;
		};

		/**
		 * Inverts a mat2d
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the source matrix
		 * @returns {mat2d} out
		 */
		mat2d.invert = function(out, a) {
		    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
		        atx = a[4], aty = a[5];

		    var det = aa * ad - ab * ac;
		    if(!det){
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] = ad * det;
		    out[1] = -ab * det;
		    out[2] = -ac * det;
		    out[3] = aa * det;
		    out[4] = (ac * aty - ad * atx) * det;
		    out[5] = (ab * atx - aa * aty) * det;
		    return out;
		};

		/**
		 * Calculates the determinant of a mat2d
		 *
		 * @param {mat2d} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat2d.determinant = function (a) {
		    return a[0] * a[3] - a[1] * a[2];
		};

		/**
		 * Multiplies two matrixes
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the first operand
		 * @param {mat2d} b the second operand
		 * @returns {mat2d} out
		 */
		mat2d.multiply = function (out, a, b) {
		    var aa = a[0], ab = a[1], ac = a[2], ad = a[3],
		        atx = a[4], aty = a[5],
		        ba = b[0], bb = b[1], bc = b[2], bd = b[3],
		        btx = b[4], bty = b[5];

		    out[0] = aa*ba + ab*bc;
		    out[1] = aa*bb + ab*bd;
		    out[2] = ac*ba + ad*bc;
		    out[3] = ac*bb + ad*bd;
		    out[4] = ba*atx + bc*aty + btx;
		    out[5] = bb*atx + bd*aty + bty;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat2d.mul = mat2d.multiply;


		/**
		 * Rotates a mat2d by the given angle
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat2d} out
		 */
		mat2d.rotate = function (out, a, rad) {
		    var aa = a[0],
		        ab = a[1],
		        ac = a[2],
		        ad = a[3],
		        atx = a[4],
		        aty = a[5],
		        st = Math.sin(rad),
		        ct = Math.cos(rad);

		    out[0] = aa*ct + ab*st;
		    out[1] = -aa*st + ab*ct;
		    out[2] = ac*ct + ad*st;
		    out[3] = -ac*st + ct*ad;
		    out[4] = ct*atx + st*aty;
		    out[5] = ct*aty - st*atx;
		    return out;
		};

		/**
		 * Scales the mat2d by the dimensions in the given vec2
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to translate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat2d} out
		 **/
		mat2d.scale = function(out, a, v) {
		    var vx = v[0], vy = v[1];
		    out[0] = a[0] * vx;
		    out[1] = a[1] * vy;
		    out[2] = a[2] * vx;
		    out[3] = a[3] * vy;
		    out[4] = a[4] * vx;
		    out[5] = a[5] * vy;
		    return out;
		};

		/**
		 * Translates the mat2d by the dimensions in the given vec2
		 *
		 * @param {mat2d} out the receiving matrix
		 * @param {mat2d} a the matrix to translate
		 * @param {vec2} v the vec2 to translate the matrix by
		 * @returns {mat2d} out
		 **/
		mat2d.translate = function(out, a, v) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    out[4] = a[4] + v[0];
		    out[5] = a[5] + v[1];
		    return out;
		};

		/**
		 * Returns a string representation of a mat2d
		 *
		 * @param {mat2d} a matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat2d.str = function (a) {
		    return 'mat2d(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' +
		                    a[3] + ', ' + a[4] + ', ' + a[5] + ')';
		};

		return mat2d;
	}
)

/**
 * @class spell.shared.util.platform.Types
 */
define(
	'spell/shared/util/platform/Types',
	[
		'spell/shared/util/platform/private/nativeType/createFloatArray',
		'spell/shared/util/platform/private/nativeType/hasFloatArraySupport',
		'spell/shared/util/platform/private/nativeType/Int8Array',
		'spell/shared/util/platform/private/nativeType/Uint16Array',
		'spell/shared/util/platform/private/nativeType/Int32Array',
		'spell/shared/util/platform/private/Time'
	],
	function(
		createFloatArray,
		hasFloatArraySupport,
		Int8Array,
		Uint16Array,
		Int32Array,
		Time
	) {
		'use strict'


		return {
			createFloatArray     : createFloatArray,
			hasFloatArraySupport : hasFloatArraySupport,
			Int8Array            : Int8Array,
			Uint16Array          : Uint16Array,
			Int32Array           : Int32Array,
			Time                 : Time
		}
	}
)

/*
 * This file is derived from glMatrix 2.1.0. Original Licence follows:
 */

/* Copyright (c) 2013, Brandon Jones, Colin MacKenzie IV. All rights reserved.

Redistribution and use in source and binary forms, with or without modification,
are permitted provided that the following conditions are met:

  * Redistributions of source code must retain the above copyright notice, this
    list of conditions and the following disclaimer.
  * Redistributions in binary form must reproduce the above copyright notice,
    this list of conditions and the following disclaimer in the documentation
    and/or other materials provided with the distribution.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR
ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. */


define(
	'spell/math/mat2',
	[
		'spell/shared/util/platform/Types'
	],
	function(
		Types
	) {
		'use strict'


		/**
		 * 2x2 matrix functions
		 *
		 * @class spell.math.mat2
		 * @singleton
		 * @requires Math
		 * @requires spell.shared.util.platform.Types
		 */
		var mat2 = {};

		/**
		 * Creates a new identity mat2
		 *
		 * @returns {mat2} a new 2x2 matrix
		 */
		mat2.create = function() {
		    var out = Types.createFloatArray(4);
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Creates a new mat2 initialized with values from an existing matrix
		 *
		 * @param {mat2} a matrix to clone
		 * @returns {mat2} a new 2x2 matrix
		 */
		mat2.clone = function(a) {
		    var out = Types.createFloatArray(4);
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Copy the values from one mat2 to another
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.copy = function(out, a) {
		    out[0] = a[0];
		    out[1] = a[1];
		    out[2] = a[2];
		    out[3] = a[3];
		    return out;
		};

		/**
		 * Set a mat2 to the identity matrix
		 *
		 * @param {mat2} out the receiving matrix
		 * @returns {mat2} out
		 */
		mat2.identity = function(out) {
		    out[0] = 1;
		    out[1] = 0;
		    out[2] = 0;
		    out[3] = 1;
		    return out;
		};

		/**
		 * Transpose the values of a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.transpose = function(out, a) {
		    // If we are transposing ourselves we can skip a few steps but have to cache some values
		    if (out === a) {
		        var a1 = a[1];
		        out[1] = a[2];
		        out[2] = a1;
		    } else {
		        out[0] = a[0];
		        out[1] = a[2];
		        out[2] = a[1];
		        out[3] = a[3];
		    }

		    return out;
		};

		/**
		 * Inverts a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.invert = function(out, a) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],

		        // Calculate the determinant
		        det = a0 * a3 - a2 * a1;

		    if (!det) {
		        return null;
		    }
		    det = 1.0 / det;

		    out[0] =  a3 * det;
		    out[1] = -a1 * det;
		    out[2] = -a2 * det;
		    out[3] =  a0 * det;

		    return out;
		};

		/**
		 * Calculates the adjugate of a mat2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the source matrix
		 * @returns {mat2} out
		 */
		mat2.adjoint = function(out, a) {
		    // Caching this value is nessecary if out == a
		    var a0 = a[0];
		    out[0] =  a[3];
		    out[1] = -a[1];
		    out[2] = -a[2];
		    out[3] =  a0;

		    return out;
		};

		/**
		 * Calculates the determinant of a mat2
		 *
		 * @param {mat2} a the source matrix
		 * @returns {Number} determinant of a
		 */
		mat2.determinant = function (a) {
		    return a[0] * a[3] - a[2] * a[1];
		};

		/**
		 * Multiplies two mat2's
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the first operand
		 * @param {mat2} b the second operand
		 * @returns {mat2} out
		 */
		mat2.multiply = function (out, a, b) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3];
		    var b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3];
		    out[0] = a0 * b0 + a1 * b2;
		    out[1] = a0 * b1 + a1 * b3;
		    out[2] = a2 * b0 + a3 * b2;
		    out[3] = a2 * b1 + a3 * b3;
		    return out;
		};

		/**
		 * Alias for {@link #multiply}
		 *
		 * @property {Function}
		 */
		mat2.mul = mat2.multiply;

		/**
		 * Rotates a mat2 by the given angle
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the matrix to rotate
		 * @param {Number} rad the angle to rotate the matrix by
		 * @returns {mat2} out
		 */
		mat2.rotate = function (out, a, rad) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        s = Math.sin(rad),
		        c = Math.cos(rad);
		    out[0] = a0 *  c + a1 * s;
		    out[1] = a0 * -s + a1 * c;
		    out[2] = a2 *  c + a3 * s;
		    out[3] = a2 * -s + a3 * c;
		    return out;
		};

		/**
		 * Scales the mat2 by the dimensions in the given vec2
		 *
		 * @param {mat2} out the receiving matrix
		 * @param {mat2} a the matrix to rotate
		 * @param {vec2} v the vec2 to scale the matrix by
		 * @returns {mat2} out
		 **/
		mat2.scale = function(out, a, v) {
		    var a0 = a[0], a1 = a[1], a2 = a[2], a3 = a[3],
		        v0 = v[0], v1 = v[1];
		    out[0] = a0 * v0;
		    out[1] = a1 * v1;
		    out[2] = a2 * v0;
		    out[3] = a3 * v1;
		    return out;
		};

		/**
		 * Returns a string representation of a mat2
		 *
		 * @param {mat2} mat matrix to represent as a string
		 * @returns {String} string representation of the matrix
		 */
		mat2.str = function (a) {
		    return 'mat2(' + a[0] + ', ' + a[1] + ', ' + a[2] + ', ' + a[3] + ')';
		};

		return mat2;
	}
)

define(
	'spell/client/createSpell',
    [
		'spell/math/mat2',
		'spell/math/mat2d',
		'spell/math/mat3',
		'spell/math/mat4',
		'spell/math/quat',
		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/vec4',
		'spell/math/random/XorShift32'
    ],
	function(
		mat2,
		mat2d,
		mat3,
		mat4,
		quat,
		util,
		vec2,
		vec3,
		vec4,
		XorShift32
    ) {
		'use strict'


		return function() {
			return {
				math : {
					random : {
						XorShift32 : XorShift32
					},
					mat2 : mat2,
					mat2d : mat2d,
					mat3 : mat3,
					mat4 : mat4,
					quat : quat,
					vec2 : vec2,
					vec3 : vec3,
					vec4 : vec4
				}
			}
		}
	}
)

define(
	'spell/client/main',
	[
		'spell/client/createSpell',
		'spell/client/development/createDebugMessageHandler',
		'spell/client/isDebug',
		'spell/client/staticInclude',
		'spell/client/setApplicationModule',
		'spell/client/showSplashScreen',
		'spell/shared/util/createMainLoop',
		'spell/EntityManager',
		'spell/SceneManager',
		'spell/AssetManager',
		'spell/ConfigurationManager',
		'spell/EventManager',
		'spell/InputManager',
		'spell/LibraryManager',
		'spell/shared/util/createModuleLoader',
		'spell/PluginManager',
		'spell/StatisticsManager',
		'spell/Console',
		'spell/VisibilityManager',
		'spell/PhysicsManager',
		'spell/shared/util/platform/PlatformKit',
		'spell/shared/util/platform/initDebugEnvironment',
        'spell/shared/util/translate',

		'spell/functions'
	],
	function(
		createSpell,
		createDebugMessageHandler,
		isDebug,
		staticInclude,
		setApplicationModule,
		showSplashScreen,
		createMainLoop,
		EntityManager,
		SceneManager,
		AssetManager,
		ConfigurationManager,
		EventManager,
		InputManager,
		LibraryManager,
		createModuleLoader,
		PluginManager,
		StatisticsManager,
		Console,
		VisibilityManager,
		PhysicsManager,
		PlatformKit,
		initDebugEnvironment,
        translate,

		_,

		// configuration parameters passed in from stage zero loader
		stageZeroConfig
	) {
		'use strict'


		var preStart = function( applicationModule, cacheContent ) {
			PlatformKit.init( this.spell, _.bind( start, this, applicationModule, cacheContent ) )
		}

		var start = function( applicationModule, cacheContent ) {
			var spell                = this.spell,
				eventManager         = spell.eventManager,
				configurationManager = spell.configurationManager,
				libraryManager       = spell.libraryManager

			setApplicationModule(
                spell,
                configurationManager,
				PlatformKit.platformDetails.getTarget(),
                applicationModule,
                spell.loaderConfig
            )

			spell.console.setSendMessageToEditor( this.sendMessageToEditor )

			if( cacheContent ) {
				libraryManager.addToCache( cacheContent )
			}

			// creating rendering context
			var renderingContext = PlatformKit.RenderingFactory.createContext2d(
				spell.eventManager,
				configurationManager.getValue( 'id' ),
				configurationManager.getValue( 'currentScreenSize' )[ 0 ],
				configurationManager.getValue( 'currentScreenSize' )[ 1 ],
				configurationManager.getValue( 'renderingBackEnd' )
			)

			spell.console.debug( 'created rendering context (' + renderingContext.getConfiguration().type + ')' )


			// creating audio context
			var audioContext = PlatformKit.AudioFactory.createAudioContext(
				configurationManager.getValue( 'audioBackEnd' )
			)

			spell.console.debug( 'created audio context (' + audioContext.getConfiguration().type + ')' )


			libraryManager.init( audioContext, renderingContext )


			var assetManager = new AssetManager( libraryManager )

			var isModeDevelopment = configurationManager.getValue( 'mode' ) !== 'deployed'

			var moduleLoader = createModuleLoader( libraryManager, isModeDevelopment, configurationManager.getValue( 'libraryUrl' ) )

			var entityManager = new EntityManager( spell, configurationManager, assetManager, spell.eventManager, libraryManager, moduleLoader )

			var sceneManager = new SceneManager(
				spell,
				entityManager,
				spell.statisticsManager,
				libraryManager,
				spell.mainLoop,
				this.sendMessageToEditor,
				isModeDevelopment
			)

			var translatePartial = _.bind(
				translate,
				null,
				libraryManager,
				configurationManager.getValue( 'currentLanguage' )
			)

			var inputManager = new InputManager( configurationManager, renderingContext )
			inputManager.init()

			spell.audioContext         = audioContext
			spell.assetManager         = assetManager
			spell.configurationManager = configurationManager
			spell.moduleLoader         = moduleLoader
			spell.entityManager        = entityManager
			spell.physicsManager       = new PhysicsManager()
			spell.renderingContext     = renderingContext
			spell.sceneManager         = sceneManager
			spell.sendMessageToEditor  = this.sendMessageToEditor
			spell.translate            = translatePartial
			spell.inputManager         = inputManager
			spell.environment          = PlatformKit.createEnvironment( configurationManager, eventManager )
			spell.env                  = spell.environment
			spell.libraryManager       = libraryManager
			spell.visibilityManager    = new VisibilityManager( eventManager, configurationManager, entityManager )
			spell.visibilityManager.init()

			spell.console.debug( 'client started' )

			var run = function() {
				spell.sceneManager.startScene( spell.applicationModule.startScene, undefined, !isModeDevelopment )
				spell.mainLoop.run()
			}

			if( applicationModule.environment &&
				applicationModule.environment.forceSplashScreen ) {

				showSplashScreen( spell, run )

			} else {
				run()
			}
		}

		var init = function( loaderConfig ) {
			var spell                = createSpell(),
				console              = new Console(),
				eventManager         = new EventManager(),
				configurationManager = new ConfigurationManager( eventManager ),
				statisticsManager    = new StatisticsManager(),
				mainLoop             = createMainLoop( eventManager, statisticsManager, isDebug ),
				isModeDeployed       = loaderConfig.mode === 'deployed'

			statisticsManager.init()

			spell.applicationModule    = undefined
			spell.configurationManager = configurationManager
			if( loaderConfig.libraryUrl ) {
				spell.configurationManager.setValue( 'libraryUrl', loaderConfig.libraryUrl )
			}
			spell.eventManager         = eventManager
			spell.loaderConfig         = loaderConfig
			spell.console              = console
			spell.mainLoop             = mainLoop
			spell.registerTimer        = PlatformKit.registerTimer
			spell.scenes               = {}
			spell.statisticsManager    = statisticsManager
			spell.storage              = PlatformKit.createPersistentStorage()
			spell.pluginManager        = new PluginManager()
            spell.libraryManager       = new LibraryManager( eventManager, configurationManager.getValue( 'libraryUrl' ), isModeDeployed )

			this.spell = spell

			if( !isModeDeployed ) {
				console.setLogLevel( console.LOG_LEVEL_DEBUG )
				initDebugEnvironment( console )

				this.debugMessageHandler = createDebugMessageHandler(
					spell,
					_.bind( this.start, this )
				)
			}
		}


		var main = function() {
			this.spell
			this.debugMessageHandler
			this.sendMessageToEditor

			init.call( this, stageZeroConfig )
		}

		main.prototype = {
			start : preStart,

			/*
			 * This callback is called when the engine instance sends message to the editing environment.
			 *
			 * @param {Function} fn
			 */
			setSendMessageToEditor : function( fn ) {
				this.sendMessageToEditor = fn
			},

			/*
			 * This method is used to send debug messages to the engine instance.
			 *
			 * @param {Object} message
			 */
			sendDebugMessage : function( message ) {
				this.debugMessageHandler( message.payload, message.type )
			}
		}

		return new main()
	}
)

define(
	'spell/shared/util/platform/private/storage/PersistentStorage',
	[
		'spell/shared/util/platform/private/storage/CookieStorage',
		'spell/shared/util/platform/private/storage/LocalStorage'
	],
	function(
		CookieStorage,
		LocalStorage
	) {
		'use strict'


		var hasLocalStorage = function() {
			return 'localStorage' in window && window[ 'localStorage' ] !== null
		}

		var PersistentStorage = function() {
			this.storage = hasLocalStorage() ? new LocalStorage() : new CookieStorage()
		}

		PersistentStorage.prototype = {
			set: function( key, value ) {
				this.storage.set( key, value )
			},
			get: function( key ) {
				return this.storage.get( key )
			},
			clear: function( key ) {
				this.storage.clear( key )
			}
		}

		return PersistentStorage
	}
)

define(
	'spell/shared/util/platform/private/storage/LocalStorage',
	[
		'spell/shared/util/platform/private/storage/decodeValue',
		'spell/shared/util/platform/private/storage/encodeValue'
	],
	function(
		decodeValue,
		encodeValue
	) {
		'use strict'


		var PREFIX = 'SpellJS-'

		var LocalStorage = function() {
			this.store = window.localStorage
		}

		LocalStorage.prototype = {
			clear : function( name ) {
				this.store.removeItem( PREFIX + name )
			},
			set : function( name, value ) {
				if( value === undefined ||
					value === null ) {

					return
				}

				this.store.setItem( PREFIX + name, encodeValue( value ) )
			},
			get : function( name ) {
				return decodeValue( this.store.getItem( PREFIX + name ) )
			}
		}

		return LocalStorage
	}
)

define(
	'spell/shared/util/platform/private/storage/encodeValue',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'

		var encodeValue = function( value ){
			var flat = '',
				i = 0,
				enc,
				len,
				key;

			if (value == null) {
				return 'e:1';
			} else if(typeof value == 'number') {
				enc = 'n:' + value;
			} else if(typeof value == 'boolean') {
				enc = 'b:' + (value ? '1' : '0');
			} else if(_.isArray(value)) {
				for (len = value.length; i < len; i++) {
					flat += encodeValue(value[i]);
					if (i != len - 1) {
						flat += '^';
					}
				}
				enc = 'a:' + flat;
			} else if (typeof value == 'object') {
				for (key in value) {
					if (typeof value[key] != 'function' && value[key] !== undefined) {
						flat += key + '=' + encodeValue(value[key]) + '^';
					}
				}
				enc = 'o:' + flat.substring(0, flat.length-1);
			} else {
				enc = 's:' + value;
			}
			return escape(enc);
		}

		return encodeValue
	}
)

define(
	'spell/shared/util/platform/private/storage/decodeValue',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'

		var decodeValue = function( value ){
			// a -> Array
			// n -> Number
			// b -> Boolean
			// s -> String
			// o -> Object
			// -> Empty (null)

			var	re = /^(a|n|b|s|o|e)\:(.*)$/,
				matches = re.exec(unescape(value)),
				all,
				type,
				keyValue,
				values,
				vLen,
				v;

			if(!matches || !matches[1]){
				return; // non state
			}

			type = matches[1];
			value = matches[2];
			switch (type) {
				case 'e':
					return null;
				case 'n':
					return parseFloat(value);
				case 'b':
					return (value == '1');
				case 'a':
					all = [];
					if(value != ''){
						values = value.split('^');
						vLen   = values.length;

						for (v = 0; v < vLen; v++) {
							value = values[v];
							all.push(decodeValue(value));
						}
					}
					return all;
				case 'o':
					all = {};
					if(value != ''){
						values = value.split('^');
						vLen   = values.length;

						for (v = 0; v < vLen; v++) {
							value = values[v];
							keyValue         = value.split('=');
							all[keyValue[0]] = decodeValue(keyValue[1]);
						}
					}
					return all;
				default:
					return value;
			}
		}

		return decodeValue
	}
)

define(
	'spell/shared/util/platform/private/storage/CookieStorage',
	[
		'spell/shared/util/platform/private/storage/decodeValue',
		'spell/shared/util/platform/private/storage/encodeValue'
	],
	function(
		decodeValue,
		encodeValue
	) {
		'use strict'


		var PREFIX  = "SpellJS-"

		var CookieStorage = function() {
			var me = this

			me.path    = "/"
			me.expires = new Date(new Date().getTime()+(1000*60*60*24*7)) //7 days
			me.domain  = null
			me.secure  = false
			me.state   = me.readCookies()
		}

		CookieStorage.prototype = {
			clear : function( name ) {
				this.clearCookie( name )
			},
			set : function( name, value ) {
				var me = this

				me.clear( name )

				if( value === undefined ||
					value === null ) {

					return
				}

				me.setCookie( name, value )
			},
			get : function( name ) {
				return decodeValue( this.state[ PREFIX + name ] )
			},
			readCookies : function() {
				var cookies = {},
					c = document.cookie + ";",
					re = /\s?(.*?)=(.*?);/g,
					len = PREFIX.length,
					matches,
					name,
					value

				while((matches = re.exec(c)) != null) {
					name = matches[1]
					value = matches[2]
					if (name && name.substring(0, len) == PREFIX){
						cookies[name.substr(len)] = decodeValue(value)
					}
				}
				return cookies
			},
			// private
			setCookie : function ( name, value ) {
				var me     = this,
					prefix = PREFIX + name

				document.cookie = prefix + "=" + encodeValue(value) +
					((me.expires == null) ? "" : ("; expires=" + me.expires.toGMTString())) +
					((me.path == null) ? "" : ("; path=" + me.path)) +
					((me.domain == null) ? "" : ("; domain=" + me.domain)) +
					((me.secure == true) ? "; secure" : "")

				me.state[ prefix ] = value
			},
			clearCookie : function( name ) {
				var me     = this,
					prefix = PREFIX + name

				document.cookie = prefix + "=null; expires=Thu, 01-Jan-70 00:00:01 GMT" +
					((me.path == null) ? "" : ("; path=" + me.path)) +
					((me.domain == null) ? "" : ("; domain=" + me.domain)) +
					((me.secure == true) ? "; secure" : "")

				delete me.state[ prefix ]
			}
		}

		return CookieStorage
	}
)

define(
	'spell/shared/util/platform/private/platformDetails',
	[
		'spell/shared/util/platform/private/input/support',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone',
		'spell/shared/util/platform/private/environment/isHtml5WinStore',
		'spell/shared/util/platform/private/jsonCoder'
	],
	function(
		support,
		isHtml5Ejecta,
		isHtml5TeaLeaf,
		isHtml5Tizen,
		isHtml5WinPhone,
		isHtml5WinStore,
		jsonCoder
	) {
		'use strict'


		if( isHtml5TeaLeaf ) {
			var gameClosureDeviceInfo = jsonCoder.decode( NATIVE.device.native_info )
		}

		return {
			hasPlentyRAM : function() {
                return !isHtml5Ejecta
            },
			hasTouchSupport : function() {
				return support.hasWebkitTouchApi() ||
					support.hasPointerTouchApi()
			},
			hasDeviceOrientationSupport : support.hasDeviceOrientationApi,
			getOS : function() {
				if( isHtml5Ejecta ) {
					return 'iOS ' + navigator.userAgent.match( /([\.\d]+)\)$/ )[ 1 ]

				} else if( isHtml5TeaLeaf ) {
					return 'Android ' + gameClosureDeviceInfo.versionRelease

				} else {
					return navigator.platform
				}
			},
			getPlatformAdapter : function() {
				if( isHtml5Ejecta ) return 'ejecta'
				if( isHtml5TeaLeaf ) return 'gameclosure'

				return 'html5'
			},
			getPlatform : function() {
				return navigator.userAgent
			},
			getTarget : function() {
				if( isHtml5Ejecta ) return 'ios'
				if( isHtml5TeaLeaf ) return 'android'
				if( isHtml5Tizen ) return 'tizen'
				if( isHtml5WinPhone ) return 'winphone'
				if( isHtml5WinStore ) return 'winstore'

				return 'web'
			},
			getDevice : function() {
				if( isHtml5Ejecta ) return navigator.userAgent.match( /\((.*);/ )[ 1 ]
				if( isHtml5TeaLeaf ) return gameClosureDeviceInfo.model + ', ' + gameClosureDeviceInfo.manufacturer

				return 'unknown'
			},
			getScreenHeight: function() {
				return screen.height
			},
			getScreenWidth: function() {
				return screen.width
			},
			isMobileDevice: function() {
				return isHtml5Ejecta || isHtml5TeaLeaf
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/openURL',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5Ejecta,
	    isHtml5Tizen,
		isHtml5WinPhone
	) {
		'use strict'


		return function( url, message ) {
			if( isHtml5WinPhone ) {
				window.external.notify( 'openUrl;' + url )

			} else if( isHtml5Ejecta ) {
				ejecta.openURL( url, message )

			} else if( isHtml5Tizen ) {
				var appControl = new tizen.ApplicationControl(
					'http://tizen.org/appcontrol/operation/view',
					url
				)

				tizen.application.launchAppControl(
					appControl,
					null,
					function() { },
					function( e ) { }
				)

			} else {
				window.open( url, '_blank' )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/network/performHttpRequest',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var createParameters = function( parameters ) {
			return _.map(
				parameters,
				function( value, key ) {
					return key + '=' + encodeURIComponent( value )
				}

			).join( '&' )
		}

		var createRequest = function() {
			return typeof XDomainRequest === 'undefined' ? new XMLHttpRequest() : new XDomainRequest()
		}

		var createCorsRequest = function( method, url, data, onLoad, onError ) {
			var request = createRequest()

			if( onLoad ) {
				request.onreadystatechange = function() {
					if( this.readyState == 4 &&
						this.status == 200 ) {

						onLoad( this.responseText )
					}
				}
			}

			if( _.size( data ) > 0 &&
				method == 'GET' ) {

				url += '?' + createParameters( data )
			}

			if( onError ) {
				request.onerror = function( event ) {
					onError( 'Error while accessing ' + url + '.' )
				}
			}

			request.open( method, url, true )

			return request
		}

		/**
		 * Performs a http request. The host specified in the url must allow CORS requests (html5 and flash). Otherwise
		 * an uncatchable error will be thrown.
		 *
		 * @param method
		 * @param url
		 * @param data
		 * @param onLoad
		 * @param onError
		 */
		var performHttpRequest = function( method, url, data, onLoad, onError ) {
			if( !method ) {
				throw 'method is undefined.'
			}

			if( method !== 'GET' &&
				method !== 'POST' ) {

				throw 'The provided method is not supported.'
			}

			if( !url ) {
				throw 'url is undefined.'
			}

			var request = createCorsRequest( method, url, data, onLoad, onError )

			if( method === 'POST' ) {
				if( request.setRequestHeader ) {
					request.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' )
				}

				request.send( createParameters( data ) )

			} else {
				request.send()
			}
		}

		return performHttpRequest
	}
)

define(
	'spell/shared/util/platform/private/network/createSocket',
	function() {
		'use strict'


		return function( host ) {
			var WebSocket = window.MozWebSocket || window.WebSocket,
				socket    = new WebSocket( 'ws://' + host + '/', 'socketrocket-0.1')

			return {
				send : function( message ) {
					socket.send( message )
				},
				setOnMessage : function( callback ) {
					socket.onmessage = function( event ) {
						callback( event.data )
					}
				},
				setOnConnected : function( callback ) {
					socket.onopen = function( event ) {
						callback( event.data )
					}
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/ModuleLoader',
	function() {
		'use strict'


		/**
		 * The global needjs public functions are wrapped into this amd module in order to prevent a dependency on global namespace.
		 */

		var createDependentModules = typeof window === 'undefined' ?
			function() {} :
			window.createDependentModules

		return {
			createDependentModules : createDependentModules,
			require                : require,
			define                 : define
		}
	}
)

define(
	'spell/shared/util/platform/private/log',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		return function( text ) {
			if( console.originalLog ) {
				console.originalLog( text )

			} else {
				console.log( text )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/loader/TextLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var onLoad = function( request ) {
			if( this.loaded === true ) return

			this.loaded = true

			var response = request.response || request.responseText

			if( request.status !== 200 &&
				request.status !== 0 ) {

				onError.call( this, response )

				return
			}

			this.onLoadCallback( this.postProcess ? this.postProcess( response ) : response )
		}

		var onError = function( event ) {
			this.onErrorCallback( event )
		}

		var onReadyStateChange = function( request ) {
			/*
			 * readyState === 4 means 'DONE'; see https://developer.mozilla.org/en/DOM/XMLHttpRequest
			 */
			if( request.readyState !== 4 ) return

			onLoad.call( this, request )
		}


		var TextLoader = function( postProcess, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.postProcess     = postProcess
			this.url             = url
			this.onLoadCallback  = onLoadCallback
			this.onErrorCallback = onErrorCallback
			this.loaded          = false
		}

		TextLoader.prototype = {
			start : function() {
				var request = new XMLHttpRequest()

				request.onload             = _.bind( onLoad, this, request )
				request.onreadystatechange = _.bind( onReadyStateChange, this, request )
				request.onerror            = _.bind( onError, this )

				request.open( 'GET', this.url, true )
				request.send()
			}
		}

		return TextLoader
	}
)

define(
	'spell/shared/util/platform/private/loader/SoundLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var onLoad = function( buffer ) {
			if( this.loaded === true ) return
			this.loaded = true

			// TODO: free SoundLoader retained js objects

			this.onLoadCallback( this.audioContext.createSound( buffer ) )
		}


		var SoundLoader = function( audioContext, asset, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.audioContext    = audioContext
			this.asset           = asset
			this.url             = url
			this.onLoadCallback  = onLoadCallback
			this.onErrorCallback = onErrorCallback
			this.loaded          = false
		}

		SoundLoader.prototype = {
			start : function() {
				this.audioContext.loadBuffer(
					this.url,
					this.asset,
					_.bind( onLoad, this )
				)
			}
		}

		return SoundLoader
	}
)

define(
	'spell/shared/util/platform/private/loader/ImageLoader',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var free = function( image ) {
			image.onload = null
			image.onreadystatechange = null
			image.onerror = null
		}

		var onLoad = function( image ) {
			if( this.loaded === true ) return
			this.loaded = true

			free( image )
			this.onLoadCallback( this.renderingContext.createTexture( image ) )
		}

		var onError = function( image, event ) {
			free( image )
			this.onErrorCallback( event )
		}

		var onReadyStateChange = function( image ) {
			if( image.readyState === 'complete' ) {
				image.onload( image )
			}
		}


		var ImageLoader = function( renderingContext, url, onLoadCallback, onErrorCallback, onTimedOutCallback ) {
			this.renderingContext = renderingContext
			this.url              = url
			this.onLoadCallback   = onLoadCallback
			this.onErrorCallback  = onErrorCallback
			this.loaded           = false
		}

		ImageLoader.prototype = {
			start : function() {
				var image = new Image()

				image.onload             = _.bind( onLoad, this, image )
				image.onreadystatechange = _.bind( onReadyStateChange, this, image )
				image.onerror            = _.bind( onError, this, image )
				image.src                = this.url
			}
		}

		return ImageLoader
	}
)

define(
	'spell/shared/util/platform/private/jsonCoder',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		/**
		 * Creates a string encoded json data structure out of a json data structure.
		 */
		var encode = _.bind( JSON.stringify, JSON )

		/**
		 * Creates a json data structure out of a string encoded json data structure.
		 */
		var decode = _.bind( JSON.parse, JSON )

		return {
			encode : encode,
			decode : decode
		}
	}
)

define(
	'spell/shared/util/platform/private/Input',
	[
		'spell/shared/util/platform/private/input/deviceOrientationHandler',
		'spell/shared/util/platform/private/input/keyHandler',
		'spell/shared/util/platform/private/input/pointerHandler',
		'spell/shared/util/platform/private/input/mousewheelHandler'
	],
	function(
		deviceOrientationHandler,
		keyHandler,
		pointerHandler,
		mousewheelHandler
	) {
		'use strict'


		var preventDefaultHandler = function( event ) {
			event.preventDefault()
		}

		var setListener = function( callback ) {
			// disable context menu on right click
			document.addEventListener( 'contextmenu', preventDefaultHandler, true )

			deviceOrientationHandler.registerListener( window, callback )
			keyHandler.registerListener( document, callback )
			mousewheelHandler.registerListener( document, callback )
			pointerHandler.registerListener( document, this.container, this.configurationManager, callback )
		}

		var removeListener = function() {
			deviceOrientationHandler.removeListener( window )
			keyHandler.removeListener( document )
			mousewheelHandler.removeListener( document )
			pointerHandler.removeListener( document )
		}

		var Input = function( configurationManager, renderingContext ) {
			this.configurationManager = configurationManager
			this.container            = renderingContext.getCanvasElement()
		}

		Input.prototype = {
			setInputEventListener : setListener,
			removeInputEventListener : removeListener
		}

		return Input
	}
)

define(
	'spell/shared/util/platform/private/input/support',
	[
		'spell/functions',
		'spell/shared/util/platform/private/input/deviceOrientationHandler',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/registerTimer'
	],
	function(
		_,
		deviceOrientationHandler,
		isHtml5Ejecta,
		isHtml5TeaLeaf,
		registerTimer
	) {
		'use strict'


		var DEVICE_ORIENTATION_PROBING_TIMEOUT = 50

		var isBrokenDeviceOrientationApi = true

		return {
			hasPointerApi : function() {
				return window.navigator.pointerEnabled
			},
			hasMicrosoftPointerApi : function() {
				return window.navigator.msPointerEnabled
			},
			hasPointerTouchApi : function() {
				return ( 'msMaxTouchPoints' in window.navigator && window.navigator.msMaxTouchPoints > 0 ) ||
					( 'maxTouchPoints' in window.navigator && window.navigator.maxTouchPoints > 0 )
			},
			hasWebkitTouchApi : function() {
				return ( 'ontouchstart' in window ) || // webkit
					( window.DocumentTouch && document instanceof DocumentTouch ) || // Firefox Mobile
					isHtml5Ejecta
			},
			hasDeviceOrientationApi : function() {
				return isHtml5TeaLeaf ||
					( window.DeviceMotionEvent !== undefined && !isBrokenDeviceOrientationApi )
			},
			hasNativeClickEvent : function() {
				return !( isHtml5Ejecta || isHtml5TeaLeaf )
			},
			init : function( spell, next ) {
				if( !isHtml5TeaLeaf && window.DeviceMotionEvent ) {
					var doneProbing = _.once( function() {
						deviceOrientationHandler.removeListener( window )

						next()
					} )

					var probeDeviceOrientationApi = function( event ) {
						if( isBrokenDeviceOrientationApi &&
							event.gamma !== 0 ) {

							isBrokenDeviceOrientationApi = false
						}
					}

					registerTimer( doneProbing, DEVICE_ORIENTATION_PROBING_TIMEOUT )

					deviceOrientationHandler.registerListener( window, probeDeviceOrientationApi )

				} else {
					next()
				}
			}
		}
	}
)

/**
 * This function handles DOM Level 3 mouse events and pointer events
 * see http://www.w3.org/TR/DOM-Level-3-Events/
 * http://www.w3.org/Submission/pointer-events/#list-of-pointer-events
 *
 * Touch Events:
 * http://developer.apple.com/library/safari/#documentation/UserExperience/Reference/TouchEventClassReference/TouchEvent/TouchEvent.html#//apple_ref/doc/uid/TP40009358
 * https://dvcs.w3.org/hg/webevents/raw-file/tip/touchevents.html
 *
 *
 * interface Event {
 *      const unsigned short              NONE            = 0;
 *      const unsigned short              CAPTURING_PHASE = 1;
 *      const unsigned short              AT_TARGET       = 2;
 *      const unsigned short              BUBBLING_PHASE  = 3;
 *
 *      readonly attribute DOMString      type;
 *      readonly attribute EventTarget?   target;
 *      readonly attribute EventTarget?   currentTarget;
 *      readonly attribute unsigned short eventPhase;
 *      readonly attribute boolean        bubbles;
 *      readonly attribute boolean        cancelable;
 *      readonly attribute DOMTimeStamp   timeStamp;
 *      void                              stopPropagation();
 *      void                              preventDefault();
 *      void                              initEvent(DOMString eventTypeArg, boolean canBubbleArg, boolean cancelableArg);
 *
 *      void                              stopImmediatePropagation();
 *      readonly attribute boolean        defaultPrevented;
 *      readonly attribute boolean        isTrusted;
 * };
 *
 * interface UIEvent : Event {
 *      readonly attribute views::AbstractView  view;
 *      readonly attribute long             detail;
 * };
 *
 * interface MouseEvent : UIEvent {
 *      readonly attribute long           screenX;
 *      readonly attribute long           screenY;
 *      readonly attribute long           clientX;
 *      readonly attribute long           clientY;
 *      readonly attribute boolean        ctrlKey;
 *      readonly attribute boolean        shiftKey;
 *      readonly attribute boolean        altKey;
 *      readonly attribute boolean        metaKey;
 *      readonly attribute unsigned short button;
 *      readonly attribute unsigned short buttons;
 *      readonly attribute EventTarget?   relatedTarget;
 *      boolean                           getModifierState(DOMString keyArg);
 * };
 *
 * interface TouchEvent : UIEvent {
 *      readonly attribute TouchList   touches;
 *      readonly attribute TouchList   targetTouches;
 *      readonly attribute TouchList   changedTouches;
 *      readonly attribute boolean     altKey;
 *      readonly attribute boolean     metaKey;
 *      readonly attribute boolean     ctrlKey;
 *      readonly attribute boolean     shiftKey;
 *      readonly attribute EventTarget relatedTarget
 * };
 *
 * interface PointerEvent : MouseEvent {
 *      const unsigned short POINTER_TYPE_UNAVAILABLE = 0x00000001;
 *      const unsigned short POINTER_TYPE_TOUCH = 0x00000002;
 *      const unsigned short POINTER_TYPE_PEN = 0x00000003;
 *      const unsigned short POINTER_TYPE_MOUSE = 0x00000004;
 *      readonly attribute long               pointerId;
 *      readonly attribute long               width;
 *      readonly attribute long               height;
 *      readonly attribute float              pressure;
 *      readonly attribute long               tiltX;
 *      readonly attribute long               tiltY;
 *      readonly attribute long               pointerType;
 *      readonly attribute unsigned long long hwTimestamp;
 *      readonly attribute boolean            isPrimary;
 * };
 */
define(
	'spell/shared/util/platform/private/input/pointerHandler',
	[
		'spell/shared/util/platform/private/input/support',
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',

		'spell/functions'
	],
	function(
		supportedInputApi,
		isHtml5Ejecta,
		_
	) {
		'use strict'

		var IS_MOBILE_SAFARI = !!navigator.platform.match( /^(iPad|iPod|iPhone)$/ ),
		IS_MOBILE_CHROME = !!navigator.userAgent.match( /Chrome\/[.0-9]* Mobile/ )

		var nativeHandler = null
		var nativeClickHandler = null

		var registeredEvents = [ ]
		var eventMappings = {
			pointermove     : 'pointerMove',
			pointerup       : 'pointerUp',
			pointerdown     : 'pointerDown',
			pointercancel   : 'pointerCancel',

			MSPointerMove   : 'pointerMove',
			MSPointerUp     : 'pointerUp',
			MSPointerDown   : 'pointerDown',
			MSPointerCancel : 'pointerCancel',

			touchstart      : 'pointerDown',
			touchmove       : 'pointerMove',
			touchend        : 'pointerUp',
			touchcancel     : 'pointerCancel',

			mousemove       : 'pointerMove',
			mousedown       : 'pointerDown',
			mouseup         : 'pointerUp'
		}

		var emitSpellPointerEvent = function( callback, eventType, pointerId, button, positionX, positionY ) {
			callback( {
				type      : eventType,
				pointerId : pointerId,
				button    : button, // 0=left button, 1=middle button if present, 2=right button
				position  : [ positionX, positionY ] // position of the pointer in screen coordinates (origin top left!)
			} )

			if( !supportedInputApi.hasNativeClickEvent() &&
				eventType === 'pointerDown' ) {

				callback( {
					type      : 'click',
					pointerId : 0,
					button    : 0, // 0=left button, 1=middle button if present, 2=right button
					position  : [ positionX, positionY ] // position of the pointer in screen coordinates (origin top left!)
				} )
			}
		}

		function getOffset( element ) {
			if( isHtml5Ejecta || !element.getBoundingClientRect ) {
				return [ 0, 0 ]
			}

			var box = element.getBoundingClientRect()

			var body    = document.body
			var docElem = document.documentElement

			var scrollTop  = window.pageYOffset || docElem.scrollTop || body.scrollTop
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft

			var clientTop  = docElem.clientTop || body.clientTop || 0
			var clientLeft = docElem.clientLeft || body.clientLeft || 0

			var top  = box.top + scrollTop - clientTop
			var left = box.left + scrollLeft - clientLeft

			return [ Math.round( left ), Math.round( top ) ]
		}

		var nativeTouchHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				button     = 0,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container )

			// only preventDefault on touchmove, otherwise no click event is triggered in mobile Safari
			if( eventType == 'touchmove' ) {
				event.preventDefault()
			}

			if( !IS_MOBILE_SAFARI && !IS_MOBILE_CHROME && eventType == 'touchstart' ) {
				//don't preventDefault on touchstart on iOS, because otherwise no click event is triggered
				event.preventDefault()
			}

			if( eventMappings[ eventType ] ) {
				eventType = eventMappings[ eventType ]
			}

			for( var i = 0, length = event.changedTouches.length; i < length; i++ ) {
				var touch     = event.changedTouches[ i ],
					pointerId = touch.identifier,
					positionX = touch.pageX - offset[ 0 ],
					positionY = touch.pageY - offset[ 1 ]

				// if the event missed the display it gets ignored
				if( positionX < 0 || positionX > screenSize[ 0 ] ||
					positionY < 0 || positionY > screenSize [ 1 ] ) {

					continue
				}

				emitSpellPointerEvent( callback, eventType, pointerId, button, positionX, positionY )
			}
		}

		var nativePointerHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				button     = event.button,
				pointerId  = typeof event.pointerId != "undefined" ? event.pointerId :  1,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container ),
				positionX  = event.pageX - offset[ 0 ],
				positionY  = event.pageY - offset[ 1 ]

			// if the event missed the display it gets ignored
			if( positionX < 0 || positionX > screenSize[ 0 ] ||
				positionY < 0 || positionY > screenSize [ 1 ] ) {

				return
			}

			if( button > 0 ) {
				// only prevent default for non left click buttons
				event.preventDefault()
			}

			if( eventMappings[ eventType ] ) {
				eventType = eventMappings[ eventType ]
			}


			emitSpellPointerEvent( callback, eventType, pointerId, button, positionX, positionY )
		}

		var nativeClickHandlerImpl = function( callback, eventMappings, container, configurationManager, event ) {
			var eventType  = event.type,
				screenSize = configurationManager.getValue( 'currentScreenSize' ),
				offset     = getOffset( container ),
				positionX  = event.pageX - offset[ 0 ],
				positionY  = event.pageY - offset[ 1 ]

			// if the event missed the display it gets ignored
			if( positionX < 0 || positionX > screenSize[ 0 ] ||
				positionY < 0 || positionY > screenSize [ 1 ] ) {

				return false
			}

			emitSpellPointerEvent( callback, eventType, 0, 0, positionX, positionY )
		}

		var registerListener = function( el, container, configurationManager, callback ) {
			if( supportedInputApi.hasPointerApi() ) {
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'pointermove', 'pointerup', 'pointerdown', 'pointercancel'
				]

			} else if( supportedInputApi.hasMicrosoftPointerApi() ) {
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'MSPointerMove', 'MSPointerUp', 'MSPointerDown', 'MSPointerCancel'
				]

			} else if( supportedInputApi.hasWebkitTouchApi() ) {
				nativeHandler = _.bind( nativeTouchHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'touchstart', 'touchmove', 'touchend', 'touchcancel'
				]

			} else {
				// use generic mouse events as input source
				nativeHandler = _.bind( nativePointerHandlerImpl, this, callback, eventMappings, container, configurationManager )
				registeredEvents = [
					'mousemove', 'mousedown', 'mouseup'
				]
			}

			for( var i in registeredEvents ) {
				el.addEventListener( registeredEvents[ i ], nativeHandler, true )
			}

			nativeClickHandler = _.bind( nativeClickHandlerImpl, this, callback, eventMappings, container, configurationManager )
			el.addEventListener( 'click', nativeClickHandler, true )
		}

		var removeListener = function( el ) {
			if( nativeHandler !== null ) {
				for( var i in registeredEvents ) {
					el.removeEventListener( registeredEvents[ i ], nativeHandler )
				}
				registeredEvents.length = 0
				nativeHandler = null
			}

			el.removeEventListener( 'click', nativeClickHandler )
			nativeClickHandler = null
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * WheelEvents
 *
 * interface WheelEvent : MouseEvent {
 *      // DeltaModeCode
 *      const unsigned long              DOM_DELTA_PIXEL = 0x00;
 *      const unsigned long              DOM_DELTA_LINE  = 0x01;
 *      const unsigned long              DOM_DELTA_PAGE  = 0x02;
 *
 *      readonly attribute double         deltaX;
 *      readonly attribute double         deltaY;
 *      readonly attribute double         deltaZ;
 *      readonly attribute unsigned long deltaMode;
 *  };
 */
define(
	'spell/shared/util/platform/private/input/mousewheelHandler',
	[
		'spell/functions'
	],
	function(
		_
	) {
		'use strict'


		var nativeHandler

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			var delta     = event.wheelDelta ? event.wheelDelta : event.detail * -1,
				direction = delta > 0 ? 1 : -1

			callback( {
				type : 'mouseWheel',
				direction : direction
			} )
		}

		var registerListener = function( el, callback ) {
			nativeHandler = _.bind( nativeHandlerImpl, this, callback )

			el.addEventListener( 'mousewheel', nativeHandler, true )
			el.addEventListener( 'DOMMouseScroll', nativeHandler, true )
		}

		var removeListener = function( el ) {
			if( nativeHandler ) {
				el.removeEventLister( 'mousewheel', nativeHandler )
				el.removeEventLister( 'DOMMouseScroll', nativeHandler )

				nativeHandler = undefined
			}
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * http://www.w3.org/TR/DOM-Level-3-Events/#key-algorithm
 * http://www.w3.org/TR/DOM-Level-3-Events/#keys-keyvalues
 * http://www.w3.org/TR/DOM-Level-3-Events/#key-values
 *
 * interface Event {
 *      const unsigned short              NONE            = 0;
 *      const unsigned short              CAPTURING_PHASE = 1;
 *      const unsigned short              AT_TARGET       = 2;
 *      const unsigned short              BUBBLING_PHASE  = 3;
 *
 *      readonly attribute DOMString      type;
 *      readonly attribute EventTarget?   target;
 *      readonly attribute EventTarget?   currentTarget;
 *      readonly attribute unsigned short eventPhase;
 *      readonly attribute boolean        bubbles;
 *      readonly attribute boolean        cancelable;
 *      readonly attribute DOMTimeStamp   timeStamp;
 *      void                              stopPropagation();
 *      void                              preventDefault();
 *      void                              initEvent(DOMString eventTypeArg, boolean canBubbleArg, boolean cancelableArg);
 *
 *      void                              stopImmediatePropagation();
 *      readonly attribute boolean        defaultPrevented;
 *      readonly attribute boolean        isTrusted;
 * };
 *
 * interface UIEvent : Event {
 *      readonly attribute views::AbstractView  view;
 *      readonly attribute long             detail;
 * };
 *
 * interface KeyboardEvent : UIEvent {
 *      // KeyLocationCode
 *      const unsigned long       DOM_KEY_LOCATION_STANDARD      = 0x00;
 *      const unsigned long       DOM_KEY_LOCATION_LEFT          = 0x01;
 *      const unsigned long       DOM_KEY_LOCATION_RIGHT         = 0x02;
 *      const unsigned long       DOM_KEY_LOCATION_NUMPAD        = 0x03;
 *
 *      readonly attribute DOMString       keyIdentifier;
 *      readonly attribute unsigned long   keyLocation;
 *      readonly attribute boolean         ctrlKey;
 *      readonly attribute boolean         shiftKey;
 *      readonly attribute boolean         altKey;
 *      readonly attribute boolean         metaKey;
 *
 *      boolean            getModifierState(in DOMString keyIdentifierArg);
 *
 *      void               initKeyboardEvent(in DOMString typeArg,
 *                                     in boolean canBubbleArg,
 *                                     in boolean cancelableArg,
 *                                     in views::AbstractView viewArg,
 *                                     in DOMString keyIdentifierArg,
 *                                     in unsigned long keyLocationArg,
 *                                     in DOMString modifiersListArg);
 *
 *      void               initKeyboardEventNS(in DOMString namespaceURIArg,
 *                                        in DOMString typeArg,
 *                                        in boolean canBubbleArg,
 *                                        in boolean cancelableArg,
 *                                        in views::AbstractView viewArg,
 *                                        in DOMString keyIdentifierArg,
 *                                        in unsigned long keyLocationArg,
 *                                        in DOMString modifiersListArg);
 * };
 */

define(
	'spell/shared/util/platform/private/input/keyHandler',
	[
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone',
		'spell/shared/util/input/keyCodes',
		'spell/functions'
	],
	function(
		isHtml5TeaLeaf,
		isHtml5Tizen,
		isHtml5WinPhone,
		keyCodes,
		_
	) {
		'use strict'


		var nativeHandler

		var KeyEvent = function( keyCode, type ) {
			this.keyCode = keyCode
			this.type = type === 'keydown' ? 'keyDown' : 'keyUp'
		}

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			var keyCode         = event.keyCode,
				keyIdentifier   = event.keyIdentifier

			if( isHtml5Tizen ) {
				if( keyIdentifier == 'XF86Send') { //menu button
					keyCode = keyCodes.MENU

				} else if( keyIdentifier == 'XF86Phone' ) { //home button
					keyCode = keyCodes.HOME

				} else if ( keyIdentifier == 'XF86Stop' ) { //back button
					keyCode = keyCodes.BACK

				} else if ( keyIdentifier == 'XF86PowerOff' ) { //power button
					keyCode = keyCodes.POWER
				}
			}

			if( keyCode ) {
				callback( new KeyEvent( keyCode, event.type ) )
			}
		}

		var registerListener = function( el, callback ) {
			if( !el ||
				!callback ) {

				return
			}

			if( isHtml5TeaLeaf ) {
				NATIVE.events.registerHandler(
					'keyEvent',
					function( event ) {
						callback( new KeyEvent( event.keyCode, event.type ) )
					}
				)
			} else if( isHtml5WinPhone ) {
				window.backButtonPressed = function( keyCode, type ) {
					callback(new KeyEvent(parseInt( keyCode,10), type))
				}
			}


			nativeHandler = _.bind( nativeHandlerImpl, this, callback )

			el.addEventListener( 'keyup', nativeHandler, true )
			el.addEventListener( 'keydown', nativeHandler, true )

			if( isHtml5Tizen ) {
				el.addEventListener( 'tizenhwkey', nativeHandler, true )
			}
		}

		var removeListener = function( el ) {
			if( nativeHandler !== null ) {
				el.removeEventLister( 'keyup', nativeHandler )
				el.removeEventLister( 'keydown', nativeHandler )

				if( isHtml5Tizen ) {
					el.removeEventLister( 'tizenhwkey', nativeHandler )
				}
			}

			nativeHandler = null
		}

		return {
			registerListener : registerListener,
			removeListener : removeListener
		}
	}
)

/**
 * See http://www.w3.org/TR/orientation-event/#deviceorientation for details.
 *
 * interface DeviceOrientationEvent : Event {
 *    readonly attribute double? alpha;
 *    readonly attribute double? beta;
 *    readonly attribute double? gamma;
 *    readonly attribute boolean absolute;
 *
 *    void initDeviceOrientationEvent(in DOMString type,
 *       in boolean bubbles,
 *       in boolean cancelable,
 *       in double? alpha,
 *       in double? beta,
 *       in double? gamma,
 *       in boolean absolute
 *    );
 * }
 *
 * interface DeviceAcceleration {
 *    readonly attribute double? x;
 *    readonly attribute double? y;
 *    readonly attribute double? z;
 * }
 *
 *interface DeviceRotationRate {
 *    readonly attribute double? alpha;
 *    readonly attribute double? beta;
 *    readonly attribute double? gamma;
 *}
 *
 *interface DeviceMotionEvent : Event {
 *    readonly attribute DeviceAcceleration? acceleration;
 *    readonly attribute DeviceAcceleration? accelerationIncludingGravity;
 *    readonly attribute DeviceRotationRate? rotationRate;
 *    readonly attribute double? interval;
 *
 *    void initAccelerometerEvent(
 *        in DOMString type,
 *        in boolean bubbles,
 *        in boolean cancelable,
 *        in DeviceAcceleration? acceleration,
 *        in DeviceAcceleration? accelerationIncludingGravity,
 *        in DeviceRotationRate? rotationRate,
 *        in double? interval
 *    );
 *}
 */

define(
	'spell/shared/util/platform/private/input/deviceOrientationHandler',
	[
		'spell/functions',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/environment/isHtml5Tizen'
	],
	function(
		_,
		isHtml5TeaLeaf,
		isHtml5Tizen
	) {
		'use strict'


		var TO_DEGREE_FACTOR = 180 / Math.PI

		var nativeHandler

		var DeviceOrientationEvent = function( alpha, beta, gamma ) {
			this.type = 'deviceOrientation'
			this.alpha = alpha
			this.beta = beta
			this.gamma = gamma
		}

		var nativeHandlerImpl = function( callback, event ) {
			event.preventDefault()

			callback( new DeviceOrientationEvent( event.alpha, event.beta, event.gamma ) )
		}

		return {
			registerListener : function( el, callback ) {
				if( isHtml5TeaLeaf ) {
					nativeHandler = function( event ) {
						callback( new DeviceOrientationEvent(
							event.alpha * TO_DEGREE_FACTOR,
							event.beta * TO_DEGREE_FACTOR,
							event.gamma * TO_DEGREE_FACTOR
						) )
					}

					NATIVE.events.registerHandler( 'deviceorientation', nativeHandler )

				} else if( isHtml5Tizen ) {
					nativeHandler = function( event ) {
						callback( new DeviceOrientationEvent( event.alpha, event.beta, -event.gamma ) )
					}

					el.addEventListener( 'deviceorientation', nativeHandler, true )

				} else {
					nativeHandler = _.bind( nativeHandlerImpl, this, callback )

					el.addEventListener( 'deviceorientation', nativeHandler, true )
				}
			},
			removeListener : function( el ) {
				if( !nativeHandler ) return

				if( isHtml5TeaLeaf ) {
					NATIVE.events.unregisterHandler( 'deviceorientation', nativeHandler )

				} else {
					el.removeEventListener( 'deviceorientation', nativeHandler, true )
				}

				nativeHandler = undefined
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/initDebugEnvironment',
	function() {
		'use strict'


		return function( spellConsole ) {
			// rewiring console.log
			console.originalLog = console.log

			console.log = function() {
				if( console.originalLog ) {
					// trigger a warning for using console.log once and then allow console.log usage
					console.log = console.originalLog
					delete console.originalLog

					var warning = 'console.log can be used only during development because it is not cross-platform save. Be sure to remove this call when you finished your debugging. Use spell.console to enable cross-platform logging.'
					spellConsole.warn( warning )
					console.warn( warning )

					console.log.apply( this, arguments )
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/initViewport',
	[
		'spell/shared/util/platform/private/getAvailableScreenSize',

		'spell/functions'
	],
	function(
		getAvailableScreenSize,

		_
	) {
        'use strict'


		var getViewportMetaTag = function() {
			var metaTags = document.getElementsByTagName( 'meta' )

			for( var i = 0, n = metaTags.length, metaTag; i < n; i++ ) {
				metaTag = metaTags[ i ]

				if( metaTag.name === 'viewport' ) return metaTag
			}
		}

		var updateViewportMetaTag = function( initialScale, maximumScale, width ) {
			var viewportMetaTag = getViewportMetaTag()
			if( !viewportMetaTag ) return

			viewportMetaTag.setAttribute(
				'content',
				'width=' + width + ', user-scalable=0, initial-scale=' + initialScale + ', maximum-scale=' + maximumScale + ''
			)
		}

		var deviceClasses = [
			{
				userAgentKeywords : [ 'iPhone', 'iPod', 'Tizen' ],
				initialScale : 0.5,
				maximumScale : 0.5,
				getWidth: function() { return 'device-width' }
			},
			{
				userAgentKeywords : [ 'iPad' ],
				initialScale : 1.0,
				maximumScale : 1.0,
				getWidth: function() { return 'device-width' }
			},
			{
				userAgentKeywords : [ 'Android' ],
				initialScale : 1.0,
				maximumScale : 1.0,
				getWidth: function() { return window.innerWidth }
			}
		]

		var getDeviceClass = function( userAgent ) {
			return _.find(
				deviceClasses,
				function( deviceClass ) {
					return _.any(
						deviceClass.userAgentKeywords,
						function( keyword ) {
							return userAgent.match( new RegExp( keyword, 'i' ) )
						}
					)
				}
			)
		}

		/**
		 * Initializes the browser viewport
		 *
		 * @param eventManager the event manager
		 * @param id the id of the spell container div
		 */
		return function( eventManager, id ) {
			var processResize = function() {
				if( window.scrollTo ) {
					window.scrollTo( 0, 0 )
				}

				eventManager.publish(
					eventManager.EVENT.AVAILABLE_SCREEN_SIZE_CHANGED,
					[ getAvailableScreenSize( id ) ]
				)
			}

			var processOrientationChange = function() {
				var orientation    = window.orientation,
					orienationMode = orientation === 0 ?
						'portrait' :
						orientation === -90 ?
							'landscapeRotatedRight' :
							'landscapeRotatedLeft'

				window.setTimeout(function() {
					var deviceClass = getDeviceClass( navigator.userAgent )

					if( deviceClass ) {
						updateViewportMetaTag( deviceClass.initialScale, deviceClass.maximumScale, deviceClass.getWidth() )
					}

					window.setTimeout( function() {
						eventManager.publish(
							eventManager.EVENT.DEVICE_ORIENTATION_CHANGED,
							[ orienationMode ]
						)

						processResize()
					}, 500)

				}, 500)

			}

			var deviceClass = getDeviceClass( navigator.userAgent )

			if( deviceClass ) {
				updateViewportMetaTag( deviceClass.initialScale, deviceClass.maximumScale, deviceClass.getWidth() )
			}

			window.addEventListener( 'orientationchange', processOrientationChange, true )
			window.addEventListener( 'resize', processResize, true )

			processOrientationChange()
		}
	}
)

define(
	'spell/data/algorithm/RLE',
	function() {
		'use strict'


		return {
			encode : function( data ) {
				var count     = 0,
					lastValue = data[ 0 ],
					result    = []

				for( var i = 0, value, n = data.length; i < n; i++ ) {
					value = data[ i ]

					if( value != lastValue ) {
						result.push( count )
						result.push( lastValue )

						lastValue = value
						count = 1

					} else {
						count++
					}
				}

				if( count > 0 ) {
					result.push( count )
					result.push( lastValue )
				}

				return result
			},
			decode : function( data ) {
				var result = []

				for( var i = 0, count, value, n = data.length; i < n; i += 2 ) {
					count = data[ i ]
					value = data[ i + 1 ]

					for( var j = 0; j < count; j++ ) {
						result.push( value )
					}
				}

				return result
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/createSplashScreenImage',
	[
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/data/algorithm/RLE'
	],
	function(
		isHtml5TeaLeaf,
		RLE
	) {
		'use strict'


		var putDataRGBInImageData = function( imageData, dataRGB, numPixels ) {
			var data = imageData.data

			for( var i = 0, srcOffset, dstOffset, n = numPixels; i < n; i++ ) {
				srcOffset = i * 3
				dstOffset = i * 4

				data[ dstOffset ]     = dataRGB[ srcOffset ]
				data[ dstOffset + 1 ] = dataRGB[ srcOffset + 1 ]
				data[ dstOffset + 2 ] = dataRGB[ srcOffset + 2 ]
				data[ dstOffset + 3 ] = 255
			}
		}

		return function() {
			if( isHtml5TeaLeaf ) {
				return
			}

			// dataRLE is a run-length encoded uint8 array in RGB format containing the splash texture data.
			var dataRLE = [69369,0,3,19,3,21,18,0,3,19,3,21,738,0,3,38,3,42,18,0,3,38,3,42,738,0,3,38,3,42,18,0,3,38,3,42,588,0,3,38,3,32,3,28,3,39,3,31,3,4,6,0,3,1,3,25,3,38,3,39,3,26,3,1,3,0,3,31,3,42,3,12,3,0,3,38,3,42,3,37,3,0,3,13,3,42,3,30,3,0,3,1,3,25,3,38,3,39,3,26,3,2,3,0,3,38,3,32,3,29,3,42,3,0,3,1,3,25,3,38,3,39,3,26,3,2,6,0,3,25,3,39,3,31,3,39,3,42,18,0,3,38,3,42,3,27,3,39,3,31,3,3,3,0,3,38,3,42,3,4,3,0,3,21,3,42,3,20,552,0,3,38,3,42,6,25,3,42,3,27,6,0,3,23,3,42,3,25,3,24,3,42,3,23,3,0,3,22,3,42,3,18,3,5,3,42,3,34,3,42,3,4,3,19,3,42,3,21,3,0,3,22,3,42,3,20,3,19,3,42,3,24,3,0,3,38,3,42,3,38,3,36,3,0,3,22,3,42,3,20,3,19,3,42,3,24,3,0,3,22,3,42,3,29,3,24,3,41,3,42,18,0,3,38,3,42,3,24,3,26,3,42,3,26,3,0,3,22,3,42,3,16,3,0,3,30,3,42,3,7,552,0,3,38,3,42,6,0,3,41,3,36,6,0,3,35,3,41,6,0,3,41,3,35,3,0,3,13,3,42,3,23,3,14,3,42,3,17,3,42,3,13,3,25,3,42,3,12,3,0,3,35,3,40,6,0,3,40,3,35,3,0,3,38,3,42,9,0,3,35,3,40,6,0,3,40,3,35,3,0,3,34,3,42,3,1,3,0,3,38,3,42,18,0,3,38,3,42,3,0,3,2,3,42,3,35,3,0,3,5,3,42,3,28,3,0,3,40,3,36,555,0,3,38,3,42,6,0,3,39,3,40,6,0,3,40,3,39,6,0,3,39,3,40,3,0,3,3,3,42,3,28,3,23,3,40,3,2,3,41,3,22,3,30,3,42,3,2,3,0,3,40,3,42,9,39,3,38,3,0,3,38,3,42,9,0,3,40,3,42,9,39,3,38,3,0,3,40,3,39,6,0,3,38,3,42,18,0,3,38,3,42,6,0,3,39,3,40,6,0,3,30,3,39,3,9,3,42,3,23,555,0,3,38,3,42,3,0,3,1,3,42,3,34,6,0,3,35,3,42,6,1,3,42,3,35,6,0,3,36,3,33,3,31,3,32,3,0,3,34,3,29,6,35,6,0,3,34,3,40,3,1,12,0,3,38,3,42,9,0,3,34,3,40,3,1,12,0,3,35,3,41,6,0,3,38,3,42,18,0,3,38,3,42,3,0,3,2,3,42,3,34,6,0,3,13,3,42,3,29,3,42,3,10,555,0,3,38,3,42,3,20,3,26,3,42,3,23,6,0,3,23,3,42,6,26,3,42,3,23,6,0,3,27,6,38,3,24,3,0,3,25,3,37,3,40,3,26,6,0,3,22,3,42,3,33,3,24,3,30,3,19,3,0,3,38,3,42,9,0,3,22,3,42,3,33,3,24,3,30,3,19,3,0,3,25,3,42,3,27,3,24,3,41,3,42,18,0,3,38,3,42,3,16,3,27,3,42,3,22,9,0,3,38,3,42,3,38,558,0,3,38,6,42,3,39,3,27,3,1,6,0,3,1,3,26,6,39,3,26,3,1,6,0,3,18,6,42,3,15,3,0,3,16,6,42,3,17,9,0,3,24,3,38,3,40,3,35,3,15,3,0,3,38,3,42,12,0,3,24,3,38,3,40,3,35,3,15,3,0,3,3,3,30,3,39,3,31,3,33,3,42,18,0,3,27,3,35,3,40,3,39,3,25,12,0,3,22,3,42,3,25,558,0,3,38,3,42,195,0,3,20,3,42,3,12,558,0,3,38,3,42,189,0,3,22,3,24,3,39,3,38,3,1,558,0,3,38,3,42,189,0,3,25,3,39,3,34,3,12,1809,0,3,48,3,74,762,0,3,74,3,186,27,0,3,48,3,111,729,0,3,8,3,240,3,9,24,0,3,182,3,104,732,0,3,195,3,74,21,0,3,74,3,206,3,2,732,0,3,119,3,134,18,0,3,6,3,219,3,72,735,0,3,59,3,210,18,0,3,120,3,180,294,0,3,50,3,101,3,119,3,118,6,119,3,102,3,50,174,0,3,187,12,255,3,118,18,0,3,187,12,255,3,118,30,0,1,17,1,12,1,9,1,68,1,51,1,36,1,67,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,68,1,51,1,36,1,17,1,12,1,8,33,0,1,67,1,46,1,27,1,118,1,81,1,47,1,118,1,80,1,46,1,119,1,79,1,44,1,119,1,78,1,42,1,119,1,77,1,41,1,119,1,77,1,39,1,67,1,43,1,21,1,16,1,10,1,5,75,0,3,3,3,20,18,0,3,90,3,35,285,0,3,17,3,119,3,238,24,255,3,238,3,119,168,0,3,186,12,255,3,119,18,0,3,186,12,255,3,119,30,0,1,68,1,50,1,34,1,255,1,190,1,131,1,255,1,190,1,131,1,255,1,189,1,130,1,255,1,190,1,131,1,255,1,190,1,131,1,255,1,189,1,130,1,255,1,189,1,130,1,68,1,50,1,34,24,0,1,67,1,47,1,29,1,169,1,118,1,70,1,255,1,176,1,104,1,255,1,174,1,101,1,255,1,172,1,98,1,255,1,170,1,94,1,255,1,169,1,91,1,255,1,167,1,88,1,255,1,165,1,84,1,255,1,164,1,81,1,255,1,162,1,78,1,255,1,160,1,74,1,221,1,136,1,61,1,135,1,83,1,35,1,16,1,10,1,4,42,0,3,14,333,0,3,50,3,238,33,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,67,1,49,1,32,1,255,1,186,1,124,1,255,1,187,1,125,1,255,1,186,1,124,1,255,1,187,1,125,1,255,1,186,1,124,1,255,1,186,1,123,1,255,1,186,1,123,1,68,1,49,1,32,18,0,1,17,1,11,1,7,1,153,1,105,1,64,1,255,1,176,1,104,1,255,1,174,1,101,1,255,1,172,1,98,1,255,1,171,1,96,1,255,1,170,1,93,1,255,1,168,1,90,1,255,1,167,1,87,1,255,1,165,1,84,1,255,1,163,1,80,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,158,1,71,1,255,1,156,1,67,1,255,1,155,1,65,1,67,1,40,1,16,39,0,3,39,3,234,3,114,3,6,324,0,3,50,3,238,36,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,48,1,31,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,183,1,118,1,255,1,182,1,117,1,255,1,182,1,116,1,67,1,48,1,30,18,0,1,203,1,139,1,81,1,255,1,175,1,102,1,255,1,173,1,99,1,255,1,171,1,96,1,255,1,170,1,94,1,255,1,169,1,91,1,255,1,167,1,88,1,255,1,166,1,85,1,255,1,164,1,82,1,255,1,163,1,79,1,255,1,161,1,76,1,255,1,159,1,73,1,255,1,158,1,70,1,255,1,156,1,67,1,255,1,155,1,64,1,255,1,153,1,61,1,67,1,40,1,15,42,0,3,36,3,182,3,219,3,80,321,0,3,186,18,255,3,187,3,118,3,119,3,186,3,238,6,255,3,187,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,47,1,29,1,255,1,179,1,111,1,255,1,180,1,112,1,255,1,180,1,112,1,255,1,180,1,112,1,255,1,179,1,111,1,255,1,179,1,111,1,255,1,179,1,110,1,67,1,46,1,28,15,0,1,119,1,81,1,46,1,255,1,172,1,98,1,255,1,171,1,96,1,255,1,170,1,94,1,255,1,169,1,92,1,255,1,168,1,89,1,255,1,167,1,87,1,255,1,165,1,84,1,255,1,163,1,80,1,255,1,162,1,78,1,255,1,160,1,75,1,255,1,159,1,72,1,255,1,158,1,70,1,255,1,156,1,66,1,255,1,155,1,64,1,255,1,153,1,61,1,255,1,151,1,58,1,67,1,39,1,14,48,0,3,72,3,212,3,188,3,3,9,0,3,36,3,184,3,42,36,0,3,3,3,68,3,11,249,0,3,67,15,255,3,204,3,33,15,0,3,50,3,119,3,101,168,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,47,1,27,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,177,1,106,1,255,1,176,1,105,1,255,1,176,1,105,1,67,1,46,1,27,12,0,1,34,1,23,1,12,1,255,1,171,1,96,1,255,1,170,1,93,1,255,1,169,1,91,1,255,1,168,1,89,1,255,1,166,1,86,1,255,1,165,1,84,1,255,1,164,1,81,1,255,1,163,1,79,1,255,1,161,1,77,1,255,1,159,1,73,1,255,1,158,1,71,1,255,1,157,1,69,1,255,1,156,1,66,1,255,1,154,1,63,1,255,1,153,1,60,1,255,1,151,1,57,1,255,1,150,1,55,1,67,1,39,1,13,51,0,3,2,3,63,12,0,3,169,3,240,3,254,3,157,3,15,21,0,3,44,3,120,3,182,3,246,3,197,3,35,249,0,3,118,12,255,3,238,3,17,195,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,46,1,26,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,174,1,100,1,255,1,173,1,99,1,255,1,172,1,98,1,67,1,45,1,26,12,0,1,119,1,78,1,43,1,255,1,168,1,89,1,255,1,167,1,88,1,255,1,166,1,86,1,255,1,165,1,84,1,255,1,164,1,82,1,255,1,163,1,79,1,255,1,161,1,77,1,238,1,149,1,70,1,102,1,63,1,29,1,33,1,21,1,8,3,0,1,50,1,31,1,13,1,101,1,61,1,24,1,135,1,80,1,31,1,204,1,121,1,45,1,255,1,149,1,54,1,255,1,148,1,51,1,67,1,39,1,13,66,0,3,60,3,227,6,255,3,248,3,245,3,109,3,3,12,0,3,89,3,218,3,143,3,77,3,14,255,0,3,187,12,255,3,153,198,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,45,1,25,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,94,1,255,1,170,1,93,1,67,1,45,1,24,12,0,1,153,1,100,1,52,1,255,1,165,1,84,1,255,1,165,1,83,1,255,1,164,1,81,1,255,1,163,1,79,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,159,1,73,1,51,1,31,1,14,21,0,1,34,1,19,1,6,1,68,1,39,1,13,1,17,1,9,1,3,63,0,3,3,3,213,3,251,12,255,3,204,3,116,282,0,3,187,12,255,3,119,48,0,3,67,6,118,6,119,3,0,3,16,3,119,3,204,12,255,3,187,3,135,3,33,39,0,3,17,3,119,3,187,3,238,9,255,3,238,3,186,3,119,3,34,30,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,44,1,23,1,255,1,168,1,89,1,255,1,168,1,89,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,88,1,255,1,167,1,87,1,67,1,44,1,23,12,0,1,186,1,120,1,59,1,255,1,163,1,80,1,255,1,162,1,78,1,255,1,161,1,77,1,255,1,160,1,74,1,255,1,159,1,73,1,255,1,158,1,70,1,204,1,125,1,54,96,0,3,105,3,223,12,255,3,241,3,230,3,11,282,0,3,186,12,255,3,153,48,0,3,118,12,255,3,118,3,238,27,255,3,118,33,0,3,84,3,238,27,255,3,238,3,102,27,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,43,1,21,1,255,1,165,1,83,1,255,1,165,1,84,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,165,1,83,1,255,1,164,1,82,1,67,1,43,1,21,12,0,1,187,1,118,1,56,1,255,1,160,1,74,1,255,1,159,1,73,1,255,1,158,1,71,1,255,1,158,1,70,1,255,1,157,1,68,1,255,1,156,1,66,1,204,1,124,1,51,93,0,3,18,3,242,15,255,3,203,3,89,285,0,3,169,12,255,3,238,3,17,45,0,3,118,48,255,3,119,27,0,3,84,39,255,3,102,24,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,42,1,20,1,255,1,161,1,77,1,255,1,163,1,79,1,255,1,162,1,78,1,255,1,162,1,78,1,255,1,162,1,78,1,255,1,161,1,77,1,255,1,161,1,77,1,67,1,42,1,20,12,0,1,186,1,115,1,51,1,255,1,158,1,70,1,255,1,157,1,69,1,255,1,156,1,67,1,255,1,156,1,66,1,255,1,155,1,64,1,255,1,153,1,61,1,255,1,153,1,60,1,50,1,29,1,11,90,0,3,151,3,234,12,255,3,228,3,195,288,0,3,119,15,255,3,204,3,17,42,0,3,119,24,255,3,238,3,186,21,255,3,33,21,0,3,17,3,238,15,255,3,169,3,119,3,186,15,255,3,238,3,33,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,42,1,19,1,255,1,159,1,73,1,255,1,159,1,72,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,73,1,255,1,159,1,72,1,67,1,41,1,19,12,0,1,136,1,83,1,35,1,255,1,155,1,65,1,255,1,155,1,64,1,255,1,154,1,62,1,255,1,154,1,62,1,255,1,153,1,60,1,255,1,151,1,58,1,255,1,150,1,56,1,203,1,119,1,43,1,33,1,19,1,7,84,0,3,36,3,253,15,255,3,219,3,50,9,0,3,14,276,0,3,16,3,238,15,255,3,203,3,33,39,0,3,119,18,255,3,169,3,51,6,0,3,16,3,153,15,255,3,152,21,0,3,153,12,255,3,238,3,51,9,0,3,68,15,255,3,136,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,41,1,17,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,157,1,68,1,255,1,156,1,67,1,255,1,156,1,67,1,255,1,156,2,67,1,41,1,17,12,0,1,101,1,61,1,24,1,255,1,154,1,62,1,255,1,153,1,60,1,255,1,151,1,58,1,255,1,151,1,57,1,255,1,150,1,56,1,255,1,149,1,54,1,255,1,148,1,52,1,255,1,147,1,50,1,238,1,137,1,45,1,119,1,68,1,22,81,0,3,179,3,159,3,224,9,255,3,217,3,165,12,0,3,203,3,164,3,29,273,0,3,118,18,255,3,238,3,85,36,0,3,119,12,255,3,238,3,68,18,0,3,170,15,255,3,34,15,0,3,17,3,238,12,255,3,102,15,0,3,119,12,255,3,238,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,41,1,16,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,154,1,63,1,255,1,155,1,64,1,255,1,154,1,63,1,255,1,154,1,63,1,67,1,40,1,16,15,0,1,238,1,141,1,52,1,255,1,150,1,55,1,255,1,149,1,54,1,255,1,149,1,53,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,49,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,144,1,44,1,221,1,123,1,36,1,84,1,47,1,13,72,0,3,74,3,180,3,3,3,12,3,124,3,246,3,250,3,245,3,26,12,0,3,12,3,132,3,237,3,128,3,8,270,0,3,152,21,255,3,169,3,17,30,0,3,119,12,255,3,186,21,0,3,34,15,255,3,102,15,0,3,101,12,255,3,221,18,0,3,34,15,255,3,50,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,40,1,15,1,255,1,151,1,58,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,152,1,59,1,255,1,151,1,58,1,255,1,151,1,58,1,67,1,39,1,14,15,0,1,118,1,69,1,24,1,255,1,148,1,52,1,255,1,147,1,50,1,255,1,147,1,50,1,255,1,146,1,48,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,144,1,44,1,255,1,143,1,42,1,255,1,143,1,41,1,255,1,141,1,39,1,255,1,141,1,38,1,187,1,102,1,26,1,68,1,37,1,9,63,0,3,6,3,219,3,77,9,4,3,33,3,182,3,120,21,0,3,29,3,164,3,224,3,42,270,0,3,152,21,255,3,221,3,50,27,0,3,119,12,255,3,187,24,0,3,203,12,255,3,152,15,0,3,136,12,255,3,152,21,0,3,221,12,255,3,119,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,39,1,14,1,255,1,149,1,54,1,255,1,150,1,55,1,255,1,150,1,55,1,255,1,150,1,55,1,255,1,149,1,54,1,255,1,149,1,54,1,255,1,149,1,54,1,67,1,39,1,14,18,0,1,152,1,87,1,29,1,255,1,146,1,47,1,255,1,145,1,46,1,255,1,145,1,45,1,255,1,144,1,44,1,255,1,143,1,42,1,255,1,143,1,41,1,255,1,142,1,40,1,255,1,141,1,38,1,255,1,140,1,37,1,255,1,139,1,35,1,255,1,139,1,34,1,255,1,138,1,32,1,136,1,73,1,16,60,0,3,120,3,146,12,4,3,78,3,219,3,5,27,0,3,60,3,6,273,0,3,119,24,255,3,102,24,0,3,119,12,255,3,187,24,0,3,135,12,255,3,186,15,0,3,186,12,255,3,119,21,0,3,187,12,255,3,118,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,39,1,13,1,255,1,147,1,50,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,50,1,255,1,148,1,51,1,255,1,147,1,50,1,255,1,147,1,50,1,67,1,39,1,13,21,0,1,152,1,86,1,25,1,255,1,144,1,43,1,255,1,143,1,42,1,255,1,142,1,40,1,255,1,141,1,39,1,255,1,141,1,38,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,139,1,35,1,255,1,138,1,33,1,255,1,138,1,32,1,255,1,137,1,30,1,255,1,136,1,28,1,203,1,109,1,22,1,16,1,8,1,1,51,0,3,26,3,243,3,34,12,5,3,181,3,75,312,0,3,50,3,203,21,255,3,119,21,0,3,119,12,255,3,187,24,0,3,118,12,255,3,238,15,0,3,220,12,255,3,68,21,0,3,186,12,255,3,152,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,38,1,12,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,146,1,47,1,255,1,145,1,46,1,67,1,38,1,12,24,0,1,85,1,47,1,12,1,220,1,122,1,33,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,139,1,35,1,255,1,139,1,34,1,255,1,138,1,32,1,255,1,138,1,32,1,255,1,137,1,31,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,134,1,25,1,169,1,89,1,15,51,0,3,155,3,125,3,6,9,5,3,105,3,191,321,0,3,136,21,255,3,85,18,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,15,255,3,153,3,119,3,118,15,119,3,204,12,255,3,186,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,38,1,11,1,255,1,144,1,44,1,255,1,144,1,44,1,255,1,144,1,44,1,255,1,144,1,43,1,255,1,144,1,43,1,255,1,144,1,43,1,255,1,144,1,43,1,67,1,38,1,11,30,0,1,118,1,64,1,16,1,238,1,129,1,31,1,255,1,138,1,32,1,255,1,138,1,32,1,255,1,137,1,30,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,135,1,26,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,133,1,22,1,101,1,53,1,8,45,0,3,48,3,252,3,9,9,6,3,9,3,252,3,48,324,0,3,68,3,238,15,255,3,238,3,16,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,187,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,10,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,143,1,41,1,255,1,142,1,40,1,255,1,142,1,40,1,255,1,141,1,39,1,67,1,37,1,10,33,0,1,16,1,9,1,2,1,118,1,64,1,14,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,135,1,27,1,255,1,135,1,26,1,255,1,134,1,25,1,255,1,134,1,24,1,255,1,133,1,23,1,255,1,133,1,22,1,255,1,132,1,21,1,203,1,105,1,16,45,0,3,195,3,106,12,6,3,134,3,149,330,0,3,16,3,204,15,255,3,118,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,187,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,9,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,37,1,255,1,140,1,36,1,255,1,140,1,36,1,67,1,37,1,9,39,0,1,33,1,17,1,3,1,204,1,107,1,19,1,255,1,134,1,25,1,255,1,133,1,23,1,255,1,133,1,23,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,130,1,18,1,51,1,26,1,3,39,0,3,89,3,167,12,7,3,50,3,237,3,18,333,0,3,34,3,238,12,255,3,187,15,0,3,119,12,255,3,187,24,0,3,68,15,255,15,0,54,255,3,136,18,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,37,1,9,1,255,1,138,1,33,1,255,1,138,1,33,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,139,1,34,1,255,1,138,1,33,1,67,1,37,1,8,42,0,1,17,1,9,1,1,1,203,1,105,1,17,1,255,1,132,1,21,1,255,1,132,1,21,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,17,1,102,1,52,1,6,36,0,3,11,3,228,3,65,12,7,3,152,3,105,339,0,3,152,15,255,15,0,3,119,12,255,3,187,24,0,3,84,15,255,15,0,15,255,3,67,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,8,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,255,1,137,1,31,1,67,1,36,1,7,45,0,1,84,1,43,1,6,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,119,1,60,1,7,36,0,3,135,3,142,12,8,3,81,3,206,3,3,339,0,3,84,15,255,15,0,3,119,12,255,3,187,24,0,3,119,12,255,3,204,15,0,3,220,12,255,3,102,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,7,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,29,1,255,1,136,1,28,1,255,1,136,1,28,1,255,1,136,1,28,1,67,1,36,1,7,48,0,1,255,1,131,1,19,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,119,1,60,1,6,33,0,3,32,3,249,3,23,3,8,9,9,3,182,3,75,342,0,3,68,15,255,15,0,3,119,12,255,3,187,24,0,3,170,12,255,3,170,15,0,3,186,12,255,3,119,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,36,1,6,1,255,1,134,1,25,1,255,1,134,1,25,1,255,1,135,1,26,1,255,1,135,1,26,1,255,1,135,1,26,1,255,1,134,1,25,1,255,1,134,1,25,1,67,1,35,1,6,45,0,1,16,1,8,1,1,1,255,1,130,1,17,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,127,1,12,1,118,1,59,1,5,33,0,3,165,3,121,12,9,3,118,3,180,345,0,3,101,15,255,15,0,3,119,12,255,3,187,24,0,3,238,12,255,3,119,15,0,3,153,12,255,3,204,57,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,30,0,1,68,1,35,1,6,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,134,1,24,1,255,1,133,1,23,1,255,1,133,1,23,1,255,1,133,1,23,1,67,1,35,1,6,45,0,1,101,1,51,1,5,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,11,1,118,1,59,1,5,30,0,3,60,3,197,3,9,9,10,3,24,3,249,3,35,345,0,3,187,12,255,3,204,15,0,3,119,12,255,3,187,21,0,3,101,15,255,3,34,15,0,3,102,15,255,3,67,54,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,119,1,61,1,9,1,101,1,52,1,8,1,34,1,17,1,2,9,0,1,101,1,52,1,8,1,255,1,133,1,22,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,133,1,22,1,255,1,133,1,22,1,255,1,132,1,21,1,255,1,132,1,21,1,67,1,34,1,5,12,0,1,119,1,61,1,9,1,255,1,132,1,20,1,170,1,87,1,12,1,118,1,60,1,8,1,33,1,17,1,2,15,0,1,67,1,34,1,3,1,238,1,119,1,13,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,126,1,10,1,67,1,33,1,2,27,0,3,3,3,206,3,97,12,10,3,142,3,134,345,0,3,101,15,255,3,152,15,0,3,119,12,255,3,187,18,0,3,17,3,220,12,255,3,204,18,0,3,16,15,255,3,203,3,16,24,0,3,67,3,33,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,130,1,18,1,255,1,131,1,19,1,255,1,131,1,19,1,221,1,113,1,16,1,169,1,87,1,12,1,152,1,78,1,11,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,132,1,20,1,255,1,132,1,20,1,255,1,131,1,19,1,255,1,131,1,19,1,255,1,131,1,19,1,51,1,26,1,3,12,0,1,119,1,60,1,8,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,129,1,16,1,238,1,120,1,15,1,187,1,94,1,11,1,119,1,60,1,6,1,135,1,68,1,7,1,204,1,102,1,11,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,238,1,118,1,8,30,0,3,105,3,154,12,11,3,62,3,227,3,11,315,0,3,119,3,255,3,220,3,152,3,101,3,67,6,0,3,67,3,153,18,255,3,84,15,0,3,119,12,255,3,203,3,34,12,0,3,34,3,203,15,255,3,85,21,0,3,152,15,255,3,221,3,101,3,16,3,0,3,33,3,67,3,118,3,170,3,238,3,255,3,119,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,129,1,16,1,255,1,130,1,17,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,17,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,1,255,1,130,1,18,15,0,1,119,1,60,1,7,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,119,1,58,1,3,27,0,3,18,3,237,3,54,12,11,3,163,3,95,318,0,3,119,42,255,3,204,18,0,3,119,18,255,3,203,3,153,3,119,3,186,18,255,3,169,24,0,3,34,3,238,42,255,3,118,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,16,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,16,1,255,1,129,1,15,1,152,1,77,1,8,15,0,1,119,1,60,1,6,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,204,1,99,1,5,1,17,1,8,28,0,3,150,3,138,3,11,9,12,3,98,3,206,3,3,318,0,3,119,39,255,3,238,3,51,18,0,3,119,45,255,3,204,3,16,27,0,3,101,42,255,3,119,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,128,1,13,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,128,1,14,1,255,1,129,1,15,1,255,1,129,1,15,1,255,1,129,1,15,1,238,1,119,1,13,1,34,1,17,1,1,15,0,1,119,1,59,1,6,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,255,1,125,1,8,1,221,1,108,1,6,1,51,1,25,1,1,27,0,3,36,3,249,3,18,12,12,3,198,3,59,321,0,3,119,36,255,3,187,3,51,21,0,3,119,42,255,3,136,36,0,3,84,3,238,36,255,3,118,21,0,3,186,12,255,3,118,18,0,3,186,12,255,3,118,12,0,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,255,1,128,1,13,1,238,1,119,1,12,1,51,1,25,1,2,18,0,1,119,1,59,1,5,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,127,1,11,1,255,1,126,1,10,1,255,1,126,1,10,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,255,1,125,1,8,1,152,1,74,1,3,1,16,1,7,31,0,3,179,3,121,6,12,3,13,3,12,3,129,3,165,324,0,3,16,3,102,3,136,3,186,3,238,12,255,3,238,3,186,3,135,3,68,27,0,3,119,12,255,3,221,3,152,3,221,12,255,3,187,3,136,3,33,42,0,3,16,3,101,3,170,3,203,15,255,3,204,3,170,3,119,3,50,24,0,3,102,3,118,3,119,6,118,3,68,18,0,3,102,3,118,3,119,6,118,3,68,12,0,1,50,1,25,1,2,1,118,1,58,1,4,1,169,1,84,1,7,1,203,1,101,1,9,1,255,1,127,1,11,1,255,1,127,1,12,1,255,1,127,1,12,1,255,1,127,1,12,1,238,1,119,1,11,1,186,1,93,1,8,1,119,1,59,1,5,1,17,1,8,25,0,1,51,1,25,1,2,1,118,1,59,1,5,1,153,1,75,1,5,1,186,1,92,1,7,1,221,1,109,1,8,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,126,1,9,1,255,1,125,1,8,1,204,1,99,1,5,1,170,1,83,1,4,1,119,1,58,1,2,1,34,1,16,34,0,3,74,3,183,12,13,3,41,3,243,3,27,390,0,3,119,12,255,3,186,333,0,3,215,3,116,12,13,3,147,3,120,393,0,3,119,12,255,3,187,333,0,3,42,3,182,3,187,3,87,3,14,3,70,3,227,3,8,393,0,3,119,12,255,3,187,339,0,3,71,3,219,3,151,3,169,3,90,396,0,3,119,12,255,3,187,342,0,3,6,3,113,3,180,399,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,750,0,3,119,12,255,3,187,49791,0,3,4,18,112,3,14,3,17,3,14,15,0,3,84,3,78,96,0,3,71,3,60,3,0,3,84,3,78,57,0,3,84,3,78,60,0,3,84,3,78,33,0,3,17,3,14,36,0,3,84,3,78,6,0,3,71,3,60,60,0,3,84,3,78,21,0,3,17,3,14,84,0,3,71,3,60,3,0,3,71,3,60,192,0,3,2,6,62,3,104,3,112,6,62,3,2,3,112,3,94,15,0,3,78,3,74,96,0,3,112,3,94,3,0,3,78,3,74,42,0,3,42,3,86,9,0,3,78,3,74,60,0,3,78,3,74,33,0,3,112,3,94,36,0,3,78,3,74,6,0,3,112,3,94,3,0,3,42,3,86,51,0,3,78,3,74,6,0,3,42,3,86,9,0,3,112,3,94,24,0,3,12,3,82,3,107,3,101,3,52,45,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,12,3,82,3,107,3,101,3,52,174,0,3,94,3,112,9,0,3,112,3,94,15,0,3,38,3,36,96,0,3,112,3,94,3,0,3,38,3,36,42,0,3,89,3,112,9,0,3,38,3,36,60,0,3,38,3,36,33,0,3,112,3,94,36,0,3,38,3,36,6,0,3,112,3,94,3,0,3,89,3,112,51,0,3,38,3,36,6,0,3,89,3,112,9,0,3,112,3,94,24,0,3,75,3,112,3,57,3,51,3,41,45,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,75,3,112,3,57,3,51,3,41,174,0,3,94,3,112,9,0,3,112,3,99,3,64,3,99,3,101,3,36,3,0,3,112,3,106,3,0,3,29,3,85,3,105,3,103,3,75,12,0,3,15,3,86,3,101,3,109,3,95,3,32,6,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,6,3,73,6,105,3,54,3,86,3,101,3,109,3,95,3,32,3,0,3,101,9,112,3,37,3,0,3,112,3,106,3,0,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,15,0,3,112,3,106,3,0,3,29,3,85,3,105,3,103,3,75,15,0,3,112,3,103,3,85,3,107,3,82,3,8,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,101,9,112,3,37,12,0,3,86,3,109,3,0,3,57,3,112,3,104,3,0,3,63,3,112,3,20,3,0,3,112,3,106,3,0,3,101,9,112,3,37,3,0,3,112,3,99,3,64,3,99,3,101,3,36,12,0,3,83,3,112,3,20,12,0,3,112,3,82,3,86,3,107,3,82,3,8,3,0,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,83,3,112,3,20,180,0,3,94,3,112,9,0,3,112,3,108,3,68,3,54,3,112,3,87,3,0,3,112,3,106,3,0,3,86,3,112,3,48,3,34,3,29,12,0,3,13,3,55,3,45,3,49,3,112,3,87,6,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,71,3,112,3,60,3,40,3,36,3,55,3,45,3,49,3,112,3,87,3,0,3,12,3,96,3,112,3,13,3,3,3,0,3,112,3,106,3,0,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,15,0,3,112,3,106,3,0,3,86,3,112,3,48,3,34,3,29,15,0,3,112,3,103,3,36,3,56,3,112,3,64,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,12,3,96,3,112,3,13,3,3,12,0,3,61,3,112,3,13,3,83,3,86,3,112,3,16,3,79,3,107,3,1,3,0,3,112,3,106,3,0,3,12,3,96,3,112,3,13,3,3,3,0,3,112,3,108,3,68,3,54,3,112,3,87,12,0,3,36,3,110,3,106,3,51,9,0,3,112,3,103,3,39,3,56,3,112,3,64,3,0,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,36,3,110,3,106,3,51,177,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,70,3,112,3,103,3,62,3,7,12,0,3,19,3,87,3,109,6,112,3,94,6,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,100,3,101,6,0,3,19,3,87,3,109,6,112,3,94,6,0,3,94,3,112,9,0,3,112,3,106,3,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,70,3,112,3,103,3,62,3,7,15,0,3,112,3,94,3,0,3,10,3,112,3,86,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,94,3,112,18,0,3,37,3,112,3,29,3,106,3,44,3,108,3,41,3,95,3,83,6,0,3,112,3,106,6,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,15,0,3,22,3,84,3,112,3,68,6,0,3,112,3,94,3,0,3,4,3,112,3,86,3,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,3,0,3,22,3,84,3,112,3,68,174,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,2,3,50,3,96,3,112,3,77,12,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,103,3,100,6,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,94,3,112,9,0,3,112,3,106,3,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,2,3,50,3,96,3,112,3,77,15,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,94,3,112,18,0,3,13,3,112,3,59,3,112,3,19,3,89,3,62,3,108,3,59,6,0,3,112,3,106,6,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,18,0,3,2,3,105,3,106,6,0,3,112,3,94,3,0,3,6,3,112,3,82,3,0,3,95,3,102,12,0,3,112,3,94,3,0,3,112,3,94,6,0,3,112,3,94,6,0,3,2,3,105,3,106,174,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,30,3,36,3,47,3,112,3,83,12,0,3,84,3,112,3,45,3,46,3,112,3,94,6,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,79,3,112,3,60,3,44,3,110,3,112,3,45,3,46,3,112,3,94,6,0,3,89,3,112,3,43,3,28,3,0,3,112,3,106,3,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,30,3,36,3,47,3,112,3,83,15,0,3,112,3,98,3,21,3,64,3,112,3,55,3,0,3,107,3,106,3,53,3,107,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,89,3,112,3,43,3,28,15,0,3,101,3,91,3,107,3,1,3,65,3,91,3,112,3,34,6,0,3,112,3,106,6,0,3,89,3,112,3,43,3,28,3,0,3,112,3,94,6,0,3,112,3,94,12,0,3,59,3,53,3,55,3,112,3,92,6,0,3,112,3,100,3,30,3,62,3,112,3,57,3,0,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,3,0,3,112,3,94,3,43,3,49,3,112,3,87,3,59,3,53,3,55,3,112,3,92,6,0,3,74,3,89,3,1,159,0,3,94,3,112,9,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,106,3,0,3,71,3,100,3,109,3,93,3,26,12,0,3,30,3,100,3,103,3,76,3,103,3,94,6,0,9,112,3,105,3,69,3,3,3,0,9,112,3,105,3,69,3,3,3,0,3,112,3,94,3,0,3,112,3,106,6,0,3,13,3,83,3,108,3,100,3,68,3,100,3,103,3,76,3,103,3,94,6,0,3,43,3,98,3,102,3,45,3,0,3,112,3,106,3,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,106,3,0,3,71,3,100,3,109,3,93,3,26,15,0,3,86,3,97,3,108,3,104,3,66,3,2,3,0,3,53,3,106,3,89,3,86,3,112,6,0,3,112,3,106,6,0,3,112,3,94,3,0,3,43,3,98,3,102,3,45,15,0,3,76,3,112,3,86,3,0,3,41,6,112,3,10,6,0,3,112,3,106,6,0,3,43,3,98,3,102,3,45,3,0,3,112,3,94,6,0,3,112,3,94,12,0,3,75,3,103,3,109,3,90,3,24,6,0,9,112,3,105,3,69,3,3,3,0,3,6,3,74,6,106,3,85,3,0,3,112,3,94,3,0,3,112,3,94,3,70,3,107,3,100,3,35,3,75,3,103,3,109,3,90,3,24,6,0,3,89,3,102,3,4,255,0,3,112,3,94,15,0,3,112,3,94,390,0,3,112,3,94,81,0,3,1,3,4,258,0,3,112,3,94,15,0,3,112,3,94,390,0,3,112,3,94,4071,0,3,112,3,94,12,0,3,84,3,78,102,0,3,14,3,17,309,0,3,84,3,78,27,0,3,71,3,60,123,0,3,71,3,60,159,0,3,112,3,94,12,0,3,78,3,74,102,0,3,94,3,112,18,0,3,47,3,93,3,97,3,93,279,0,3,78,3,74,27,0,3,112,3,94,123,0,3,112,3,94,159,0,3,112,3,94,12,0,3,38,3,36,102,0,3,94,3,112,18,0,3,106,3,103,285,0,3,38,3,36,27,0,3,112,3,94,123,0,3,112,3,94,159,0,3,112,3,94,12,0,3,112,3,106,6,0,3,6,3,73,6,105,3,39,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,84,3,65,3,99,3,102,3,37,3,29,3,85,3,105,3,103,3,75,3,0,3,17,3,83,3,107,3,100,3,49,3,0,3,14,3,87,3,101,3,105,3,112,12,0,3,6,12,112,3,46,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,83,3,93,3,64,15,0,3,112,3,84,3,65,3,99,3,102,3,37,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,21,0,3,6,3,73,6,105,3,42,3,68,3,104,3,107,3,79,3,10,6,0,3,112,6,85,3,103,3,52,3,63,3,100,3,102,3,37,6,0,3,112,6,85,3,103,3,52,3,63,3,100,3,102,3,37,6,0,3,17,3,83,3,107,3,100,3,49,3,0,3,112,3,83,3,93,3,64,3,0,3,6,3,73,6,105,3,39,3,112,3,106,3,0,3,15,3,86,3,101,3,109,3,95,3,32,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,29,3,85,3,105,3,103,3,75,3,0,3,17,3,83,3,107,3,100,3,49,12,0,3,3,3,68,3,104,3,107,3,79,3,10,6,0,3,112,3,84,3,65,3,99,3,102,3,37,3,0,3,112,3,96,3,99,3,95,3,0,3,19,3,112,3,59,141,0,3,112,3,94,12,0,3,112,3,106,6,0,3,71,3,112,3,60,3,40,3,23,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,107,3,62,3,54,3,112,3,88,3,86,3,112,3,48,3,34,3,29,3,0,3,86,3,109,3,23,3,61,3,112,3,17,3,78,3,112,3,46,3,103,3,112,15,0,3,13,3,112,3,99,3,13,3,62,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,68,3,40,15,0,3,112,3,107,3,62,3,54,3,112,3,88,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,3,18,12,112,3,59,3,0,3,71,3,112,3,60,3,40,3,81,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,55,3,105,3,112,3,67,3,53,3,112,3,87,6,0,3,112,3,107,3,55,3,105,3,112,3,67,3,53,3,112,3,87,6,0,3,86,3,109,3,23,3,61,3,112,3,17,3,112,3,107,3,68,3,40,3,0,3,71,3,112,3,60,3,40,3,23,3,112,3,106,3,0,3,13,3,55,3,45,3,49,3,112,3,87,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,86,3,112,3,48,3,34,3,29,3,0,3,86,3,109,3,23,3,61,3,112,3,17,9,0,3,57,3,112,3,56,3,41,3,112,3,76,6,0,3,112,3,107,3,62,3,54,3,112,3,88,3,0,3,112,3,94,3,53,3,112,3,17,3,48,3,112,3,21,141,0,3,112,3,94,12,0,3,112,3,106,6,0,3,100,3,101,9,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,6,0,3,112,3,94,3,70,3,112,3,103,3,62,3,7,3,0,3,107,3,109,3,94,3,99,3,112,3,35,3,102,3,103,3,0,3,94,3,112,18,0,3,112,3,97,3,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,3,16,12,94,3,50,3,0,3,100,3,101,6,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,107,3,109,3,94,3,99,3,112,3,35,3,112,3,94,9,0,3,100,3,101,9,0,3,112,3,106,3,0,3,19,3,87,3,109,6,112,3,94,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,70,3,112,3,103,3,62,3,7,3,0,3,107,3,109,3,94,3,99,3,112,3,35,9,0,3,84,3,112,3,4,3,0,3,99,3,102,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,8,3,107,3,51,3,77,3,97,144,0,3,112,3,94,12,0,3,112,3,106,6,0,3,103,3,100,9,0,3,95,3,102,12,0,3,112,3,94,6,0,3,112,3,94,3,2,3,50,3,96,3,112,3,77,3,0,3,95,3,102,12,0,3,104,3,101,3,0,3,94,3,112,18,0,3,112,3,97,3,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,103,3,100,6,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,95,3,102,12,0,3,112,3,94,9,0,3,103,3,100,9,0,3,112,3,106,3,0,3,80,3,112,3,32,3,2,3,112,3,94,6,0,3,112,3,94,15,0,3,112,3,94,3,0,3,94,3,112,3,0,3,2,3,50,3,96,3,112,3,77,3,0,3,95,3,102,21,0,3,84,3,112,3,5,3,0,3,100,3,101,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,0,3,67,3,87,3,105,3,59,144,0,3,112,3,104,6,60,3,35,3,0,3,112,3,106,6,0,3,79,3,112,3,60,3,44,3,25,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,6,0,3,112,3,94,3,30,3,36,3,47,3,112,3,83,3,0,3,67,3,112,3,63,3,43,3,60,3,0,3,83,3,112,3,43,3,104,3,112,18,0,3,112,3,97,3,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,79,3,112,3,60,3,44,3,84,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,67,3,112,3,63,3,43,3,60,3,0,3,112,3,94,9,0,3,79,3,112,3,60,3,44,3,25,3,112,3,106,3,0,3,84,3,112,3,45,3,46,3,112,3,94,6,0,3,112,3,94,15,0,3,107,3,106,3,53,3,107,3,112,3,0,3,30,3,36,3,47,3,112,3,83,3,0,3,67,3,112,3,63,3,43,3,60,12,0,3,58,3,112,3,59,3,46,3,112,3,75,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,3,0,3,19,6,112,3,21,6,0,3,74,3,89,3,1,129,0,12,112,3,54,3,0,3,112,3,106,6,0,3,13,3,83,3,108,3,100,3,37,3,6,3,74,6,106,3,85,3,0,3,112,3,94,6,0,3,112,3,94,3,71,3,100,3,109,3,93,3,26,3,0,3,6,3,74,6,106,3,85,3,0,3,21,3,94,3,102,3,93,3,112,18,0,3,112,3,97,3,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,21,0,3,112,3,94,6,0,3,112,3,94,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,21,0,3,13,3,83,3,108,3,100,3,41,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,94,3,112,6,0,3,112,3,94,6,0,3,6,3,74,6,106,3,85,3,0,3,112,3,94,9,0,3,13,3,83,3,108,3,100,3,37,3,112,3,106,3,0,3,30,3,100,3,103,3,76,3,103,3,94,6,0,3,112,3,94,15,0,3,53,3,106,3,89,3,86,3,112,3,0,3,71,3,100,3,109,3,93,3,26,3,0,3,6,3,74,6,106,3,85,12,0,3,3,3,70,3,105,3,107,3,79,3,10,6,0,3,112,3,94,6,0,3,112,3,94,3,0,3,112,3,94,6,0,3,90,3,96,9,0,3,89,3,102,3,4,738,0,3,37,3,45,3,110,3,58,9,0,3,1,3,4,741,0,3,76,3,106,3,82,3,8,10833,0],
				dataRGB = RLE.decode( dataRLE ),
				size    = 256

			var canvas = document.createElement( 'canvas' )

			canvas.width = size
			canvas.height = size

			var context   = canvas.getContext( '2d' ),
				imageData = context.createImageData( size, size )

			putDataRGBInImageData( imageData, dataRGB, size * size )
			context.putImageData( imageData, 0, 0 )

			return canvas
		}
	}
)

define(
	'spell/shared/util/platform/private/getAvailableScreenSize',
    [
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
        'spell/shared/util/platform/private/environment/isHtml5Ejecta',
	    'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
    ],
	function(
		isHtml5TeaLeaf,
        isHtml5Ejecta,
	    isHtml5Tizen,
		isHtml5WinPhone
    ) {
		'use strict'


		var getOffset = function( element ) {
            if( !element.getBoundingClientRect ) {
                return [ 0, 0 ]
            }

			var box = element.getBoundingClientRect()

			var body    = document.body
			var docElem = document.documentElement

			var scrollTop  = window.pageYOffset || docElem.scrollTop || body.scrollTop
			var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft

			var clientTop  = docElem.clientTop || body.clientTop || 0
			var clientLeft = docElem.clientLeft || body.clientLeft || 0

			var top  = box.top + scrollTop - clientTop
			var left = box.left + scrollLeft - clientLeft

			return [ Math.round( left ), Math.round( top ) ]
		}

		var createScreenSize = function( id ) {
			var offset = getOffset( document.getElementById( id ) )

			return [ window.innerWidth - offset[ 0 ], window.innerHeight - offset[ 1 ] ]
		}

		return function( id ) {
            if( isHtml5TeaLeaf ||
				isHtml5Ejecta ||
	            isHtml5Tizen ||
				isHtml5WinPhone ) {

                return [ window.innerWidth, window.innerHeight ]
            }

			if( !id ) {
				throw 'Missing container id argument. Please call the function with the spell container id.'
			}

			return createScreenSize( id )
		}
	}
)

define(
	'spell/shared/util/platform/private/flurry',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf'
	],
	function(
		isHtml5Ejecta,
		isHtml5TeaLeaf
	) {
		'use strict'


		return {
			logEvent : function( eventName, timed ) {
				if( isHtml5Ejecta ) {
					//ejecta.flurryLogEvent( eventName, timed )

				} else if( isHtml5TeaLeaf ) {
					NATIVE.flurry.logEvent( eventName )
				}
			},
			endTimedEvent : function( eventName ) {
				if( isHtml5Ejecta ) {
					//ejecta.flurryEndTimedEvent( eventName )

				} else if( isHtml5TeaLeaf ) {
					NATIVE.flurry.endTimedEvent( eventName )
				}
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/Environment',
	[
		'spell/shared/util/platform/private/environment/visibilityChangeHandler'
	],
	function(
		visibilityChangeHandler
	) {
		'use strict'


		var Environment = function( configurationManager, eventManager ) {
			this.configurationManager = configurationManager
			this.eventManager         = eventManager

			if( typeof window !== 'undefined' ) {
				this.window               = window
			}
		}

		Environment.prototype = {
			init : function() {
				visibilityChangeHandler.registerListener( this.eventManager )
			}
		}

		return Environment
	}
)

/**
 * See http://www.w3.org/TR/page-visibility/ for details.
 *
 * enum VisibilityState { "hidden", "visible", "prerender", "unloaded" };
 *
 * partial interface Document {
 *  readonly attribute boolean hidden;
 *  readonly attribute VisibilityState visibilityState;
 * };
 */

define(
	'spell/shared/util/platform/private/environment/visibilityChangeHandler',
	[
		'spell/functions'
	],
	function(
		_
		) {
		'use strict'

		var hidden, state, visibilityChange

		if( typeof document.hidden !== 'undefined' ) {

			hidden = 'hidden'
			visibilityChange = 'visibilitychange'
			state = 'visibilityState'

		} else if( typeof document.mozHidden !== 'undefined' ) {

			hidden = 'mozHidden'
			visibilityChange = 'mozvisibilitychange'
			state = 'mozVisibilityState'

		} else if( typeof document.msHidden !== 'undefined' ) {

			hidden = 'msHidden'
			visibilityChange = 'msvisibilitychange'
			state = 'msVisibilityState'

		} else if( typeof document.webkitHidden !== 'undefined' ) {

			hidden = 'webkitHidden'
			visibilityChange = 'webkitvisibilitychange'
			state = 'webkitVisibilityState'
		}


		var handleVisibilityChange = function( eventManager ) {

			var visibilityState = document[ state ],
				isVisible       = ( visibilityState == 'VISIBLE' || visibilityState == 'visible' )

			eventManager.publish(
				eventManager.EVENT.VISIBILITY_CHANGED,
				isVisible
			)
		}

		return {
			registerListener : function( eventManager ) {

				var listener = _.bind( handleVisibilityChange, this, eventManager )

				document.addEventListener( visibilityChange, listener )
			},
			removeListener : function( ) {
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5WinStore',
	function() {
		'use strict'

		return typeof( Windows ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isBrowser',
	function() {
		'use strict'


		return !!( typeof window !== 'undefined' && navigator && document )
	}
)

define(
	'spell/shared/util/platform/private/createHost',
	function() {
		'use strict'


		return function() {
			return document.location.host
		}
	}
)

define(
	'spell/shared/util/platform/private/createComponentType',
	[
		'spell/shared/util/createModuleId'
	],
	function(
		createModuleId
	) {
		'use strict'


		var componentIdToType = {}

		return function( moduleLoader, spell, componentId ) {
			var type = componentIdToType[ componentId ]

			if( type === false ) {
				return

			} else if( type === undefined ) {
				try {
					type = moduleLoader.require( createModuleId( componentId ) )
					componentIdToType[ componentId ] = type

				} catch( exception ) {
					componentIdToType[ componentId ] = false

					return
				}
			}

			return new type( spell )
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/winPhoneAudio/createWinPhoneAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId',
		'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId,
		createHtml5AudioContext
	) {
		'use strict'


		var isMutedValue         = false
		var html5AudioContext    = createHtml5AudioContext()
		var isContextPausedValue = false

		var generateRequest = function( params ) {
			return params.join( ';' )
		}

		var sendNotification = function() {
			window.external.notify( generateRequest( Array.prototype.slice.call(arguments) ) )
		}

		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id  = createSoundId(),
				src = soundAsset.resource.resource.src

			volume = createNormalizedVolume( volume )
			loop   = !!loop

			if( soundAsset.isMusic ) {
				html5AudioContext.loadBuffer( src, soundAsset, function() {
					if( isContextMuted() ) {
						html5AudioContext.muteContext()
					}

					html5AudioContext.play( soundAsset, volume, loop )
				})

			} else {
				sendNotification( 'playSound', id, src, volume, loop )
			}

			return id
		}

		var stop = function( id ) {
			sendNotification( 'stopSound', id )
		}

		var setVolume = function ( id, volume ) {
			var volume = createNormalizedVolume( volume )

			sendNotification( 'setVolume', id, volume )
		}

		var setLoop = function( id, loop ) {
			sendNotification( 'setLoop', id, !!loop )
		}

		var mute = function( id ) {
			sendNotification( 'mute', id )
		}

		var unmute = function( id ) {
			sendNotification( 'unmute', id )
		}

		var muteContext = function() {
			html5AudioContext.muteContext()
			sendNotification( 'muteContext' )

			isMutedValue = true
		}

		var unmuteContext = function() {
			html5AudioContext.unmuteContext()
			sendNotification( 'unmuteContext' )

			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			sendNotification( 'pause', id )
		}

		var resume = function( id ) {
			sendNotification( 'resume', id )
		}

		var pauseContext = function() {
			html5AudioContext.pauseContext()
			sendNotification( 'pauseContext' )

			isContextPausedValue = true
		}

		var resumeContext = function() {
			html5AudioContext.resumeContext()
			sendNotification( 'resumeContext' )

			isContextPausedValue = false
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var tick = function() {}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var src = createFixedSoundFileSrc( src )

			sendNotification( 'loadBuffer', src )

			onLoadCallback( { src: src } )
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		/*
		 * Returns an audio context. Once a context has been created additional calls to this method return the same instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		/*
		 * Creates a wrapper context for the back-end context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'winPhone' } }
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/nativeAudio/createNativeAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId
	) {
		'use strict'


		var dummy = function() {}

		// Unfortunately the game closure sound api is missing a "sound identity" concept. Therefore it is not possible to reference a playing sound by anything
		// but its src attribute value. The src value is not unqiue though.

		// HACK: This leaks memory because ids are never removed.
		var idToUrl = {}

		var audioBuffers = {}

		var AudioBuffer = function( src, onload, onerror ) {
			this.src     = src
			this.onload  = onload
			this.onerror = onerror
			this.loaded  = false
		}

		var isMutedValue         = false
		var isContextPausedValue = false

		var muteContext = function() {
			isMutedValue = true

			for( var id in idToUrl ) {
				setVolume( id , 0.0 )
			}
		}

		var pause = function( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			NATIVE.sound.pauseSound( url )
		}

		var resume = function( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			NATIVE.sound.play( url, 1, false )
		}

		var pauseContext = function() {
			isContextPausedValue = true

			for( var id in idToUrl ) {
				NATIVE.sound.pauseSound( id )
			}
		}

		var resumeContext = function() {
			isContextPausedValue = true

			for( var id in idToUrl ) {
				NATIVE.sound.playSound( id )
			}
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var unmuteContext = function() {
			isMutedValue = false

			for( var id in idToUrl ) {
				setVolume( id , 1.0 )
			}
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var setVolume = function( id, volume ) {
			var url = idToUrl[ id ]
			if( !url ) return

//			console.log( ' *** setVolume: ' + id + ' vol. ' + ( isMutedValue ? 0.0 : 1.0 ) )

			NATIVE.sound.setVolume( url, createNormalizedVolume( volume ) )
		}

		var stop = function ( id ) {
			var url = idToUrl[ id ]
			if( !url ) return

			delete idToUrl[ id ]

//			console.log( ' *** stop: ' + id )

			// TODO: Repair this
			// just a test if this causes the crash on android

			NATIVE.sound.stopSound( url )
		}

		var play = function( soundAsset, volume, loop ) {
			var id               = createSoundId(),
				url              = soundAsset.resource.src,
				normalizedVolume = createNormalizedVolume( volume )

			idToUrl[ id ] = url

//			console.log( ' *** play: ' + url + ', ' + ( id ? id : 'anonymous' ) + ', vol: ' + ( isMutedValue ? 0.0 : normalizedVolume ) )

			if( soundAsset.isMusic ) {
				NATIVE.sound.playBackgroundMusic( url, isMutedValue ? 0 : normalizedVolume, !!loop )

			} else {
				NATIVE.sound.playSound( url, isMutedValue ? 0 : normalizedVolume, !!loop )
			}

			return id
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( audioBuffer ) {
//			console.log( ' *** Creating sound from buffer ' + audioBuffer.src )

			return {
				/*
				 * Public
				 */
				duration : 0, // not available

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				src : audioBuffer.src
			}
		}


		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var fixedSrc = createFixedSoundFileSrc( src )

			var audioBuffer = new AudioBuffer( fixedSrc, onLoadCallback )

			audioBuffers[ fixedSrc ] = audioBuffer

			if( soundAsset.isMusic ) {
				onLoadCallback( audioBuffer )

			} else {
				// trigger a load for this sound, this will trigger a sound loaded message in the future which will call the onLoadCallback
				NATIVE.sound.loadSound( fixedSrc )
			}
		}

		var createWrapperContext = function() {
			return {
				tick             : dummy,
				play             : play,
				setLoop          : dummy,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : dummy,
				unmute           : dummy,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'native' } }
			}
		}

		/**
		 * Creates an audio context
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			// The "soundLoaded" event is only triggered when loading a sound and not when loading (a.k.a. streaming) background music.
			NATIVE.events.registerHandler(
				'soundLoaded',
				function( event ) {
//					console.log( ' *** soundLoaded: ' + event.url )

					var audioBuffer = audioBuffers[ event.url ]

					if( audioBuffer &&
						!audioBuffer.loaded ) {

						audioBuffer.loaded = true

						if( audioBuffer.onload ) {
							audioBuffer.onload( audioBuffer )
						}
					}
				}
			)

			NATIVE.events.registerHandler(
				'soundError',
				function( event ) {
//					console.log( ' *** error loading ' + event.url )

					var audioBuffer = audioBuffers[ event.url ]

					if( audioBuffer &&
						audioBuffer.onerror ) {

						audioBuffer.onerror( audioBuffer )
					}
				}
			)

			return createWrapperContext()
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/webAudio/createWebAudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId',

		'spell/functions'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId,

		_
	) {
		'use strict'


		var PLAYING_STATE = {
			 INIT: 0,
 			 PLAYING: 1,
			 PAUSED: 2,
			 FINISHED: 3
		}

		var SourceNodeWrapper = function( soundResource, volume, loop ) {
			this.volume             = volume
			this.loop               = loop
			this.startOffsetContext = 0
			this.pauseOffsetContext = 0
			this.startOffset        = 0
			this.state              = PLAYING_STATE.INIT

			this.soundResource = soundResource
		}

		SourceNodeWrapper.prototype = {


			play: function() {
				if( !this.soundResource || !this.soundResource.resource)
					return

				if( !this.node ||
					this.node.playbackState !== this.node.PLAYING_STATE ) {

					var gainNode    = context.createGainNode(),
						startOffset = this.startOffset + this.pauseOffsetContext - this.startOffsetContext

					this.node = context.createBufferSource()
					this.node.buffer = this.soundResource.resource
					this.node.connect( gainNode )

					gainNode.connect( context.destination )

					this.startOffsetContext = context.currentTime
					this.startOffset = startOffset % this.node.buffer.duration

					this.node.gain.value = isMuted() ? 0 : this.volume
					this.node.loop = this.loop
					this.state = PLAYING_STATE.PLAYING

					this.node.start( 0, this.startOffset )
				}
			}
		}

		var context,
			sourceNodes     = {},
			isMutedValue    = false,
			isContextPaused = false

		var create = function( id, soundResource, volume, loop, offset ) {
			volume = createNormalizedVolume( volume )
			loop   = !!loop
			offset = offset || 0

			var sourceNode = new SourceNodeWrapper( soundResource, volume, loop, offset )
			sourceNodes[ id ] = sourceNode

			return sourceNode
		}

		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id = createSoundId()

			var sourceNode = _.has( sourceNodes, id ) ?
				sourceNodes[ id ] :
				create( id, soundAsset.resource )

			setLoop( id, loop )
			setVolume( id, volume )

			sourceNode.play()

			return id
		}

		var stop = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState === sourceNode.node.PLAYING_STATE ) {

				sourceNode.node.stop( 0 )
			}
		}

		var setVolume = function ( id, volume ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.volume =  createNormalizedVolume( volume )

				if( sourceNode.node ) {
					sourceNode.node.gain.value = sourceNode.volume
				}
			}
		}

		var setLoop = function( id, loop ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.loop = !!loop

				if( sourceNode.node ) {
					sourceNode.node.loop = sourceNode.loop
				}
			}
		}

		var mute = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.node.gain.value = 0
			}
		}

		var unmute = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode ) {
				sourceNode.node.gain.value = sourceNode.volume
			}
		}

		var destroy = function( id ) {
			stop( id )

			sourceNodes[ id ] = null
			delete sourceNodes[ id ]
		}

		/**
		 * Looks through the sourceNodes and cleans up finished nodes
		 */
		var tick = function() {
			for( var id in sourceNodes ) {
				var sourceNode = sourceNodes[ id ]

				if( sourceNode.state != PLAYING_STATE.PAUSED &&
					sourceNode.node &&
					sourceNode.node.playbackState === sourceNode.node.FINISHED_STATE ) {

					destroy( id )
				}
			}
		}

		var muteContext = function() {
			_.each( sourceNodes, function( value, key ) {
				mute( key )
			} )

			isMutedValue = true
		}

		var unmuteContext = function() {
			_.each( sourceNodes, function( value, key ) {
				unmute( key )
			} )

			isMutedValue = false
		}

		var resumeContext = function() {
			_.each( sourceNodes, function( value, key ) {
				resume( key )
			} )

			isContextPaused = false
		}

		var pauseContext = function() {
			_.each( sourceNodes, function( value, key ) {
				pause( key )
			} )

			isContextPaused = true
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var getIsContextPaused = function() {
			return isContextPaused
		}

		var isMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState === sourceNode.node.PLAYING_STATE ) {

				sourceNode.state = PLAYING_STATE.PAUSED
				sourceNode.pauseOffsetContext = context.currentTime
				sourceNode.node.stop( 0 )
			}
		}

		var resume = function( id ) {
			var sourceNode = sourceNodes[ id ]

			if( sourceNode &&
				sourceNode.node.playbackState !== sourceNode.node.PLAYING_STATE ) {

				sourceNode.play()
			}
		}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var request = new XMLHttpRequest()

			request.open( 'GET', createFixedSoundFileSrc( src ), true )
			request.responseType = 'arraybuffer'

			request.onload = function() {
				context.decodeAudioData(
					request.response,
					onLoadCallback
				)
			}

			request.onError = function() {
				throw 'Error: Could not load sound resource "' + config.resource + '".'
			}

			request.send()
		}

		/*
		 * Creates a wrapper context from the backend context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : getIsContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'web' } }
			}
		}

		/*
		 * Returns a audio context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			if( context ) return context

			context = new webkitAudioContext()

			return createWrapperContext()
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/getFileExtOfSupportedFormat',
	[
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5TeaLeaf,
		isHtml5WinPhone
	) {
		'use strict'


		var fileExtensionToMimeTypes = [
			{
				fileExtension : 'ogg',
				mimeTypes : [
					'audio/ogg; codecs=vorbis'
				]
			},
			{
				fileExtension : 'mp3',
				mimeTypes : [
					'audio/mpeg; codecs="mp3"',
					'audio/mpeg',
					'audio/mp3',
					'audio/MPA',
					'audio/mpa-robust'
				]
			}
		]

		var fileExtOfSupportedFormat

		var getFileExtOfSupportedFormat = function() {
			if( isHtml5WinPhone ) {
				return 'wav'
			}

			if( isHtml5TeaLeaf ) {
				return 'mp3'
			}

			if( fileExtOfSupportedFormat ) {
				return fileExtOfSupportedFormat
			}

			var probe = new Audio()

			for( var i = 0, n = fileExtensionToMimeTypes.length; i < n; i++ ) {
				var fileExtension = fileExtensionToMimeTypes[ i ].fileExtension,
					mimeTypes     = fileExtensionToMimeTypes[ i ].mimeTypes

				for( var j = 0, m = mimeTypes.length; j < m; j++ ) {
					if( probe.canPlayType( mimeTypes[ j ] ) ) {
						fileExtOfSupportedFormat = fileExtension

						return fileExtension
					}
				}
			}
		}

        return getFileExtOfSupportedFormat
	}
)

define(
	'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
	[
		'spell/shared/util/platform/private/sound/getFileExtOfSupportedFormat'
	],
	function(
		getFileExtOfSupportedFormat
	) {
		'use strict'


		/**
		 * This function removes the extension from the supplied sound resource file and adds an extension which is
		 * supported by the audio back-end. The proper solution would be to not include the file extension in the
		 * library path to the sound resource file.
		 *
		 * @param src
		 * @return {String}
		 */
		var createFixedSoundFileSrc = function( src ) {
			var srcParts = src.split( '.' )

			srcParts.pop()
			srcParts.push( getFileExtOfSupportedFormat() )

			return srcParts.join( '.' )
		}

        return createFixedSoundFileSrc
	}
)

define(
	'spell/shared/util/createNormalizedVolume',
	[
		'spell/math/util'
	],
	function(
		mathUtil
	) {
		'use strict'

		return function( x ) {
			return x !== undefined ?
				mathUtil.clamp( x, 0, 1 ) :
				1
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext',
	[
		'spell/shared/util/createNormalizedVolume',
		'spell/shared/util/platform/private/sound/createFixedSoundFileSrc',
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createNormalizedVolume,
		createFixedSoundFileSrc,
		createSoundId
	) {
		'use strict'


		var MAX_NUM_CHANNELS = 16 // the maximum amount of concurrently playing audio elements

		var audioElements        = {},
			isMutedValue         = false,
			numFreeChannels      = MAX_NUM_CHANNELS,
			isContextPausedValue = false

		var create = function( id, soundResource ) {
			var audio

			if( soundResource.resource.cloneNode ) {
				audio = soundResource.resource.cloneNode( true )

			} else {
				audio = new Audio()
				audio.src = soundResource.resource.src
			}

			audio.id = id
			audio.playing = false

			return audio
		}

		var loopCallback = function() {
			this.currentTime = 0
			this.play()
		}

		var removeCallback = function() {
			free( this )
		}

		var free = function( audioElement ) {
			audioElement.pause()

			audioElement.removeEventListener( 'ended', removeCallback, true )
			audioElement.removeEventListener( 'ended', loopCallback, true )

			numFreeChannels++

			delete audioElements[ audioElement.id ]
		}


		/**
		 * @param {SoundAsset} soundAsset
		 * @param volume
		 * @param loop
		 */
		var play = function( soundAsset, volume, loop ) {
			var id           = createSoundId(),
				audioElement = audioElements[ id ]

			if( !audioElement &&
				numFreeChannels > 0 ) {

				// when a free channel exists play the sound
				numFreeChannels--

				audioElement = create( id, soundAsset.resource )
				audioElements[ id ] = audioElement
			}

			if( audioElement ) {
				setLoop( id, loop )

				if( !audioElement.playing ) {
					audioElement.playing = true
					audioElement.play()
				}

				//set volume after play. In some browser it won't have an effect otherwise
				setVolume( id, volume )
				if( isContextMuted() ) {
					mute( id )
				}
			}

			return id
		}

		var stop = function( id ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return

			free( audioElement )
		}

		var setVolume = function ( id, volume ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return


			audioElement.volume = audioElement.sourceVolume = createNormalizedVolume( volume )
		}

		var setLoop = function( id, loop ) {
			var audioElement = audioElements[ id ]
			if( !audioElement ) return

			audioElement.loop = !!loop

			if( loop ) {
				audioElement.addEventListener( 'ended', loopCallback, true )
				audioElement.removeEventListener( 'ended', removeCallback, true )

			} else {
				audioElement.addEventListener( 'ended', removeCallback, true )
				audioElement.removeEventListener( 'ended', loopCallback, true )
			}
		}

		var mute = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.volume = 0
			}
		}

		var unmute = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.volume = audioElement.sourceVolume
			}
		}

		var muteContext = function() {
			for( var id in audioElements ) {
				mute( id )
			}

			isMutedValue = true
		}

		var unmuteContext = function() {
			for( var id in audioElements ) {
				unmute( id )
			}

			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var pause = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.pause()
			}
		}

		var resume = function( id ) {
			var audioElement = audioElements[ id ]

			if( audioElement ) {
				audioElement.play()
			}
		}

		var pauseContext = function() {
			for( var id in audioElements ) {
				pause( id )
			}

			isContextPausedValue = true
		}

		var resumeContext = function() {
			for( var id in audioElements ) {
				resume( id )
			}

			isContextPausedValue = false
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var tick = function() {}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			var audioElement = new Audio()

			audioElement.src = createFixedSoundFileSrc( src )

			// old webkit
			if( audioElement.autobuffer ) {
				audioElement.autobuffer = 'auto'
			}

			// new webkit
			if( audioElement.preload ) {
				audioElement.preload = 'auto'
			}

			audioElement.load()

			onLoadCallback( audioElement )
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {
				/*
				 * Public
				 */
				duration : buffer.duration,

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				resource : buffer
			}
		}

		/*
		 * Returns an audio context. Once a context has been created additional calls to this method return the same instance.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		/*
		 * Creates a wrapper context for the back-end context.
		 */
		var createWrapperContext = function() {
			return {
				tick             : tick,
				play             : play,
				setLoop          : setLoop,
				setVolume        : setVolume,
				pause            : pause,
				resume           : resume,
				stop             : stop,
				mute             : mute,
				unmute           : unmute,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'web' } }
			}
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/createSoundId',
	function() {
		'use strict'


		var nextSoundId  = 1

		return function() {
			return nextSoundId++
		}
	}
)

define(
	'spell/shared/util/platform/private/sound/dummyAudio/createDummyAudioContext',
	[
		'spell/shared/util/platform/private/sound/createSoundId'
	],
	function(
		createSoundId
	) {
		'use strict'


		var isMutedValue         = false
		var isContextPausedValue = false

		var dummy = function() {}

		var play = function( soundAsset, volume, loop ) {
			return createSoundId()
		}

		var muteContext = function() {
			isMutedValue = true
		}

		var unmuteContext = function() {
			isMutedValue = false
		}

		var isContextMuted = function() {
			return isMutedValue
		}

		var isContextPaused = function() {
			return isContextPausedValue
		}

		var pauseContext = function() {
			isContextPausedValue = true
		}

		var resumeContext = function() {
			isContextPausedValue = false
		}

		/*
		 * Returns a SoundResource instance.
		 *
		 * @param buffer
		 * @return {SoundResource}
		 */
		var createSound = function( buffer ) {
			return {}
		}

		var loadBuffer = function( src, soundAsset, onLoadCallback ) {
			if( !src ) {
				throw 'Error: No src provided.'
			}

			if( !onLoadCallback ) {
				throw 'Error: No onLoadCallback provided.'
			}

			onLoadCallback( {} )
		}

		var createWrapperContext = function() {
			return {
				tick             : dummy,
				play             : play,
				setLoop          : dummy,
				setVolume        : dummy,
				pause            : dummy,
				resume           : dummy,
				stop             : dummy,
				mute             : dummy,
				unmute           : dummy,
				muteContext      : muteContext,
				unmuteContext    : unmuteContext,
				isContextMuted   : isContextMuted,
				pauseContext     : pauseContext,
				resumeContext    : resumeContext,
				isContextPaused  : isContextPaused,
				createSound      : createSound,
				loadBuffer       : loadBuffer,
				getConfiguration : function() { return { type : 'dummy' } }
			}
		}

		/*
		 * Returns an audio context.
		 *
		 * @return {Object}
		 */
		var createAudioContext = function() {
			return createWrapperContext()
		}

		return createAudioContext
	}
)

define(
	'spell/shared/util/platform/private/sound/AudioFactory',
	[
		'spell/shared/util/platform/private/sound/dummyAudio/createDummyAudioContext',
		'spell/shared/util/platform/private/sound/html5Audio/createHtml5AudioContext',
		'spell/shared/util/platform/private/sound/webAudio/createWebAudioContext',
		'spell/shared/util/platform/private/sound/nativeAudio/createNativeAudioContext',
		'spell/shared/util/platform/private/sound/winPhoneAudio/createWinPhoneAudioContext'
	],
	function(
		createDummyAudioContext,
		createHtml5AudioContext,
		createWebAudioContext,
		createNativeAudioContext,
		createWinPhoneAudioContext
	) {
		'use strict'


		var BACK_END_DUMMY_AUDIO    = 'dummy',
			BACK_END_WEB_AUDIO      = 'web',
			BACK_END_HTML5_AUDIO    = 'html5',
			BACK_END_NATIVE_AUDIO   = 'native',
			BACK_END_WIN_PHONE_AUDIO = 'winPhone'

		var context = null

		/*
		 * Creates an audio context
		 *
		 * @param requestedBackEnd - when supplied, overrides the automagic audio back-end detection
		 */
		var createAudioContext = function( requestedBackEnd ) {
			try {
				if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_DUMMY_AUDIO ) ) {
					context = createDummyAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WEB_AUDIO ) ) {
					context = createWebAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_HTML5_AUDIO ) ) {
					context = createHtml5AudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_NATIVE_AUDIO ) ) {
					context = createNativeAudioContext()

				} else if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WIN_PHONE_AUDIO ) ) {
					context = createWinPhoneAudioContext()
				}

			} catch( e ) {
				context = null
			}

			if( !context ) {
				//use the dummy audio context as fallback
				context = createDummyAudioContext()
			}

			if( context ) return context
		}

		return {
			BACK_END_DUMMY_AUDIO : BACK_END_DUMMY_AUDIO,
			BACK_END_HTML5_AUDIO : BACK_END_HTML5_AUDIO,
			BACK_END_WEB_AUDIO : BACK_END_WEB_AUDIO,
			BACK_END_NATIVE_AUDIO : BACK_END_NATIVE_AUDIO,
			BACK_END_WIN_PHONE_AUDIO : BACK_END_WIN_PHONE_AUDIO,
			createAudioContext : createAudioContext
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/createCanvasNode',
	function() {
		'use strict'


		return function( id, width, height ) {
            var canvas

            if ( window && window.canvas ) {
                // if a global canvas element was specified, use this (for Ejecta style environment)
                canvas = window.canvas

            } else {
                canvas = document.createElement( 'canvas' )
            }

            canvas.id           = id + '-screen'
            canvas.width        = width
            canvas.height       = height
            canvas.className    += 'spell-canvas'

			if( id ) {
				var container = document.getElementById( id )
				if( !container ) throw 'Could not find a container with the id ' + id + ' in the DOM tree.'

				container.appendChild( canvas )

			} else {
				document.body.appendChild( canvas )
			}

			return canvas
		}
	}
)

define(
	"spell/shared/util/platform/private/graphics/webgl/shaders",
	function() {
		return {
			vertex: [
				"attribute vec2 aVertexPosition;",

				"uniform mat3 uScreenSpaceShimMatrix;",
				"uniform mat3 uModelViewMatrix;",
				"uniform mat3 uTextureMatrix;",

				"varying vec2 vTextureCoord;",


				"void main( void ) {",
					"vTextureCoord = ( uTextureMatrix * vec3( aVertexPosition, 1.0 ) ).st;",
					"gl_Position = vec4( uScreenSpaceShimMatrix * uModelViewMatrix * vec3( aVertexPosition, 1.0 ), 1.0 );",
				"}"
			].join( "\n" ),

			fragment: [
				"precision mediump float;",

				"uniform sampler2D uTexture0;",
				"uniform vec4 uGlobalColor;",
				"uniform float uGlobalAlpha;",
				"uniform bool uFillRect;",

				"varying vec2 vTextureCoord;",


				"void main( void ) {",
					"if( !uFillRect ) {",
					"	vec4 color = texture2D( uTexture0, vTextureCoord );",
					"	gl_FragColor = color * vec4( 1.0, 1.0, 1.0, uGlobalAlpha );",

					"} else {",
					"	gl_FragColor = uGlobalColor * vec4( 1.0, 1.0, 1.0, uGlobalAlpha );",
					"}",
				"}"
			].join( "\n" )
		}
	}
)

define(
	"spell/shared/util/platform/private/graphics/webgl/createContext",
	[
		'spell/functions'
	],
	function(
		_
	) {
		"use strict"


		/*
		 * Returns a rendering context. Performs some probing to account for different runtime environments.
		 *
		 * @param canvas
		 */
		var createContext = function( canvas ) {
			var gl = null
			var contextNames = [ "webgl", "experimental-webgl", "webkit-3d", "moz-webgl" ]
			var attributes = {
				alpha: false
			}

			_.find(
				contextNames,
				function( it ) {
					gl = canvas.getContext( it, attributes )

					return ( gl !== null )
				}
			)

			return gl
		}

		return createContext
	}
)

define(
	'spell/shared/util/platform/private/graphics/webgl/createWebGlContext',
	[
		'spell/shared/util/platform/private/graphics/StateStack',
		'spell/shared/util/platform/private/graphics/webgl/createContext',
		'spell/shared/util/platform/private/graphics/webgl/shaders',

		'spell/shared/util/color',
		'spell/shared/util/platform/private/nativeType/createFloatArray',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/vec3',
		'spell/math/mat3',

		'spell/functions'
	],
	function(
		StateStack,
		createContext,
		shaders,

		color,
		createFloatArray,

		mathUtil,
		vec2,
		vec3,
		mat3,

		_
	) {
		'use strict'


		/*
		 * private
		 */

		var gl, canvas,
			stateStack           = new StateStack( 32 ),
			currentState         = stateStack.getTop(),
			NUM_CIRCLE_VERTICES  = 32,
			QUAD_VERTEX_OFFSET   = 0,
			CIRCLE_VERTEX_OFFSET = QUAD_VERTEX_OFFSET + 4,
			LINE_VERTEX_OFFSET   = CIRCLE_VERTEX_OFFSET + NUM_CIRCLE_VERTICES,
			vertices             = createFloatArray( ( LINE_VERTEX_OFFSET + 2 ) * 2 ),
			positionVertexBuffer

		var screenSpaceShimMatrix = mat3.create()

		// view space to screen space transformation matrix
		var viewToScreen = mat3.create()
		mat3.identity( viewToScreen )

		// world space to view space transformation matrix
		var worldToView = mat3.create()
		mat3.identity( worldToView )

		// accumulated transformation world space to screen space transformation matrix
		var worldToScreen = mat3.create()
		mat3.identity( worldToScreen )

		var screenToWorld = mat3.create()
		mat3.identity( screenToWorld )

		var tmpMatrix            = mat3.create(),
			defaultTextureMatrix = mat3.create()

		mat3.identity( defaultTextureMatrix )

		/*
		 * Creates a projection matrix that normalizes the transformation behaviour to that of the normalized canvas-2d (that is origin is in bottom left,
		 * positive x-axis to the right, positive y-axis up, screen space coordinates as input. The matrix transforms from screen space to clip space.
		 *
		 * @param width
		 * @param height
		 * @param matrix
		 */
		var createScreenSpaceShimMatrix = function( width, height, matrix ) {
			mathUtil.mat3Ortho(
				matrix,
				0,
				width,
				0,
				height
			)

			return matrix
		}

		var createViewToScreenMatrix = function( width, height, matrix ) {
			mat3.identity( matrix )

			matrix[ 0 ] = width * 0.5
			matrix[ 4 ] = height * 0.5
			matrix[ 6 ] = width * 0.5
			matrix[ 7 ] = height * 0.5

			return matrix
		}

		var initWrapperContext = function( shaderProgram ) {
			viewport( shaderProgram, 0, 0, gl.canvas.width, gl.canvas.height )

			// gl initialization
			gl.clearColor( 0.0, 0.0, 0.0, 1.0 )
			gl.clear( gl.COLOR_BUFFER_BIT )

			// setting up blending
			gl.enable( gl.BLEND )
			gl.blendFunc( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA )

			gl.disable( gl.DEPTH_TEST )

			gl.activeTexture( gl.TEXTURE0 )
		}

		/*
		 * Creates a wrapper context for the backend context.
		 */
		var createWrapperContext = function() {
			var shaderProgram = createShaderProgram()

			initWrapperContext( shaderProgram )

			return {
				clear                   : clear,
				createTexture           : createWebGlTexture,
				drawTexture             : _.bind( drawTexture, null, shaderProgram ),
				drawSubTexture          : _.bind( drawSubTexture, null, shaderProgram ),
				drawRect                : _.bind( drawRect, null, shaderProgram ),
				drawCircle              : _.bind( drawCircle, null, shaderProgram ),
				drawLine                : _.bind( drawLine, null, shaderProgram ),
				fillRect                : _.bind( fillRect, null, shaderProgram ),
				getConfiguration        : getConfiguration,
				resizeColorBuffer       : resizeColorBuffer,
				restore                 : restore,
				rotate                  : rotate,
				save                    : save,
				scale                   : scale,
				setClearColor           : setClearColor,
				setColor                : setColor,
				setLineColor            : setLineColor,
				setGlobalAlpha          : setGlobalAlpha,
				setTransform            : setTransform,
				setViewMatrix           : setViewMatrix,
				transform               : transform,
				translate               : translate,
				viewport                : _.bind( viewport, null, shaderProgram ),
				transformScreenToWorld  : transformScreenToWorld,
				getCanvasElement        : function() { return canvas },
				flush                   : function() {}
			}
		}

		/*
		 * Returns a rendering context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @param canvas - the canvas dom element
		 */
		var createWebGlContext = function( canvasObj ) {
			if( canvasObj === undefined ) throw 'Missing first argument.'

			if( gl !== undefined ) return gl

			canvas = canvasObj
			gl = createContext( canvas )

			if( gl === null ) return null


			return createWrapperContext()
		}

		var createShaderProgram = function() {
			var shaderProgram = gl.createProgram()

			var vertexShader = gl.createShader( gl.VERTEX_SHADER )
			gl.shaderSource( vertexShader, shaders.vertex )
			gl.compileShader (vertexShader )
			gl.attachShader( shaderProgram, vertexShader )

			var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER )
			gl.shaderSource( fragmentShader, shaders.fragment )
			gl.compileShader( fragmentShader )
			gl.attachShader( shaderProgram, fragmentShader )

			gl.linkProgram( shaderProgram )
			gl.useProgram( shaderProgram )

			// storing the attribute and uniform locations
			shaderProgram.aVertexPosition        = gl.getAttribLocation( shaderProgram, 'aVertexPosition' )
			shaderProgram.uScreenSpaceShimMatrix = gl.getUniformLocation( shaderProgram, 'uScreenSpaceShimMatrix' )
			shaderProgram.uTextureMatrix         = gl.getUniformLocation( shaderProgram, 'uTextureMatrix' )
			shaderProgram.uFillRect              = gl.getUniformLocation( shaderProgram, 'uFillRect' )
			shaderProgram.uGlobalAlpha           = gl.getUniformLocation( shaderProgram, 'uGlobalAlpha' )
			shaderProgram.uGlobalColor           = gl.getUniformLocation( shaderProgram, 'uGlobalColor' )
			shaderProgram.uTexture0              = gl.getUniformLocation( shaderProgram, 'uTexture0' )
			shaderProgram.uModelViewMatrix       = gl.getUniformLocation( shaderProgram, 'uModelViewMatrix' )

			// setting up vertices
			var angleStep = Math.PI * 2 / NUM_CIRCLE_VERTICES

			// quad
			vertices[ QUAD_VERTEX_OFFSET * 2 + 0 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 1 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 2 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 3 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 4 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 5 ] = 1.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 6 ] = 0.0
			vertices[ QUAD_VERTEX_OFFSET * 2 + 7 ] = 1.0

			// circle
			for( var i = 0; i < NUM_CIRCLE_VERTICES; i++ ) {
				var angle = angleStep * i

				vertices[ CIRCLE_VERTEX_OFFSET * 2 + i * 2 ]     = Math.sin( angle )
				vertices[ CIRCLE_VERTEX_OFFSET * 2 + i * 2 + 1 ] = Math.cos( angle )
			}

			// line
			// These vertices are stubs and get overwritten once the drawLine function is called.
			vertices[ LINE_VERTEX_OFFSET * 2 + 0 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 1 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 2 ] = 0.0
			vertices[ LINE_VERTEX_OFFSET * 2 + 3 ] = 0.0

			positionVertexBuffer = gl.createBuffer()
			gl.bindBuffer( gl.ARRAY_BUFFER, positionVertexBuffer )
			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

			gl.vertexAttribPointer( shaderProgram.aVertexPosition, 2, gl.FLOAT, false, 0, 0 )
			gl.enableVertexAttribArray( shaderProgram.aVertexPosition )

			// setting up screen space shim matrix
			gl.uniformMatrix3fv( shaderProgram.uScreenSpaceShimMatrix, false, screenSpaceShimMatrix )

			// setting up texture matrix
			setTextureMatrix( shaderProgram, defaultTextureMatrix )

			return shaderProgram
		}

		var updateTextureMatrix = function( shaderProgram, ss, st, tt, ts, matrix ) {
			mat3.identity( matrix )

			matrix[ 0 ] = ss
			matrix[ 4 ] = st
			matrix[ 6 ] = tt
			matrix[ 7 ] = ts

			gl.uniformMatrix3fv( shaderProgram.uTextureMatrix, false, matrix )
		}

		var setTextureMatrix = function( shaderProgram, textureMatrix ) {
			gl.uniformMatrix3fv( shaderProgram.uTextureMatrix, false, textureMatrix )
		}


		/*
		 * public
		 */
		var transformScreenToWorld = function( vec ) {
			// transform vec to a gl-like origin (bottom left)
			// use worldPosition as temp because we need to allocate it anyway
			var worldPosition = vec2.clone( vec )

			worldPosition[ 1 ] = gl.canvas.height - worldPosition[ 1 ]

			vec2.transformMat3( worldPosition, worldPosition, screenToWorld )

			return worldPosition
		}

		var save = function() {
			stateStack.pushState()
			currentState = stateStack.getTop()
		}

		var restore = function() {
			stateStack.popState()
			currentState = stateStack.getTop()

			setViewMatrix( currentState.viewMatrix )
		}

		var setColor = function( vec ) {
			currentState.color = color.createRgba( vec )
		}

		var setLineColor = function( vec ) {
			currentState.lineColor = color.createRgba( vec )
		}

		var setGlobalAlpha = function( u ) {
			currentState.opacity = u
		}

		var setClearColor = function( vec ) {
			gl.clearColor( vec[ 0 ], vec[ 1 ], vec[ 2 ], 1.0 )
		}

		var scale = function( vec ) {
			mat3.scale( currentState.matrix, currentState.matrix, vec )
		}

		var translate = function( vec ) {
			mat3.translate( currentState.matrix, currentState.matrix, vec )
		}

		var rotate = function( u ) {
			mat3.rotate( currentState.matrix, currentState.matrix, u )
		}

		/*
		 * Clears the color buffer with the clear color
		 */
		var clear = function() {
			gl.clear( gl.COLOR_BUFFER_BIT )
		}

		var drawTexture = function( shaderProgram, texture, destinationPosition, destinationDimensions, textureMatrix ) {
			if( texture === undefined ) throw 'Texture is undefined'

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 0 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up texture
			gl.bindTexture( gl.TEXTURE_2D, texture.privateGlTextureResource )
			gl.uniform1i( shaderProgram.uTexture0, 0 )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// rotating the image so that it is not upside down
			mat3.translate( tmpMatrix, tmpMatrix, destinationPosition )
			mat3.rotate( tmpMatrix, tmpMatrix, Math.PI )
			mat3.scale( tmpMatrix, tmpMatrix, [ -1.0, 1.0 ] )
			mat3.scale( tmpMatrix, tmpMatrix, destinationDimensions )
			mat3.translate( tmpMatrix, tmpMatrix, [ 0.0, -1.0 ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			setTextureMatrix(
				shaderProgram,
				textureMatrix ?
					textureMatrix :
					defaultTextureMatrix
			)

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawSubTexture = function( shaderProgram, texture, sourcePosition, sourceDimensions, destinationPosition, destinationDimensions ) {
			if( texture === undefined ) throw 'Texture is undefined'

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 0 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up texture
			gl.bindTexture( gl.TEXTURE_2D, texture.privateGlTextureResource )
			gl.uniform1i( shaderProgram.uTexture0, 0 )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// rotating the image so that it is not upside down
			mat3.translate( tmpMatrix, tmpMatrix, destinationPosition )
			mat3.rotate( tmpMatrix, tmpMatrix, Math.PI )
			mat3.scale( tmpMatrix, tmpMatrix, [ -1.0, 1.0 ] )
			mat3.scale( tmpMatrix, tmpMatrix, destinationDimensions )
			mat3.translate( tmpMatrix, tmpMatrix, [ 0.0, -1.0 ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			// setting up the texture matrix
			var tw = texture.dimensions[ 0 ],
				th = texture.dimensions[ 1 ]

			updateTextureMatrix(
				shaderProgram,
				( sourceDimensions[ 0 ] - 1 ) / tw,
				( sourceDimensions[ 1 ] - 1 ) / th,
				( sourcePosition[ 0 ] + 0.5 ) / tw,
				( sourcePosition[ 1 ] + 0.5 ) / th,
				tmpMatrix
			)

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawRect = function( shaderProgram, dx, dy, dw, dh, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ dw, dh ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.LINE_LOOP, QUAD_VERTEX_OFFSET, 4 )
		}

		var drawCircle = function( shaderProgram, dx, dy, radius, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ radius, radius ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.LINE_LOOP, CIRCLE_VERTEX_OFFSET, NUM_CIRCLE_VERTICES )
		}

		var drawLine = function( shaderProgram, ax, ay, bx, by, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			gl.lineWidth( lineWidth )

			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.lineColor )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			// line
			vertices[ LINE_VERTEX_OFFSET * 2 + 0 ] = ax
			vertices[ LINE_VERTEX_OFFSET * 2 + 1 ] = ay
			vertices[ LINE_VERTEX_OFFSET * 2 + 2 ] = bx
			vertices[ LINE_VERTEX_OFFSET * 2 + 3 ] = by

			gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW )

			gl.drawArrays( gl.LINES, LINE_VERTEX_OFFSET, 2 )
		}

		var fillRect = function( shaderProgram, dx, dy, dw, dh ) {
			// setting up fillRect mode
			gl.uniform1i( shaderProgram.uFillRect, 1 )

			// setting up global alpha
			gl.uniform1f( shaderProgram.uGlobalAlpha, currentState.opacity )

			// setting up global color
			gl.uniform4fv( shaderProgram.uGlobalColor, currentState.color )

			// setting up transformation
			mat3.multiply( tmpMatrix, worldToScreen, currentState.matrix )

			// correcting position
			mat3.translate( tmpMatrix, tmpMatrix, [ dx, dy ] )
			mat3.scale( tmpMatrix, tmpMatrix, [ dw, dh ] )

			gl.uniformMatrix3fv( shaderProgram.uModelViewMatrix, false, tmpMatrix )

			gl.drawArrays( gl.TRIANGLE_FAN, QUAD_VERTEX_OFFSET, 4 )
		}

		var resizeColorBuffer = function( width, height ) {
			gl.canvas.width  = width
			gl.canvas.height = height

			createViewToScreenMatrix( width, height, viewToScreen )
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
		}

		var transform = function( matrix ) {
			mat3.multiply( currentState.matrix, currentState.matrix, matrix )
		}

		var setTransform = function( matrix ) {
			mat3.copy( currentState.matrix, matrix )
		}

		var setViewMatrix = function( matrix ) {
			mat3.copy( currentState.viewMatrix, matrix )

			mat3.copy( worldToView, matrix )
			createViewToScreenMatrix( gl.canvas.width, gl.canvas.height, viewToScreen )
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
			mat3.invert( screenToWorld, worldToScreen )
		}

		var viewport = function( shaderProgram, x, y, width, height ) {
			gl.viewport( x, y , width, height )

			// reinitialize screen space shim matrix
			createScreenSpaceShimMatrix( width, height, screenSpaceShimMatrix )

			gl.uniformMatrix3fv( shaderProgram.uScreenSpaceShimMatrix, false, screenSpaceShimMatrix )
		}

		/*
		 * Returns an object describing the current configuration of the rendering backend.
		 */
		var getConfiguration = function() {
			var info = gl.getParameter( gl.VENDOR ) + ';' +
				gl.getParameter( gl.RENDERER ) + ';' +
				gl.getParameter( gl.VERSION ) + ';' +
				gl.getParameter( gl.SHADING_LANGUAGE_VERSION )

			return {
				type   : 'webgl',
				width  : gl.canvas.width,
				height : gl.canvas.height,
				info   : info
			}
		}

		var isPowerOfTwo = function( number ) {
			var magnitude = ( Math.log( number ) / Math.log( 2 ) )

			return magnitude === parseInt( magnitude, 10 )
		}

		/*
		 * Returns instance of texture class
		 *
		 * The public interface of the texture class consists of the two attributes width and height.
		 *
		 * @param image
		 */
		var createWebGlTexture = function( image ) {
			var isPowerOfTwoTexture = isPowerOfTwo( image.width ) && isPowerOfTwo( image.height )

			var texture = gl.createTexture()

			gl.bindTexture( gl.TEXTURE_2D, texture )
			gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image )
			gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR )

			if( isPowerOfTwoTexture ) {
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT )
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT )
				gl.generateMipmap( gl.TEXTURE_2D )

			} else {
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE )
				gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE )
			}

			gl.bindTexture( gl.TEXTURE_2D, null )

			return {
				/*
				 * Public
				 */
				dimensions : [ image.width, image.height ],

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				privateGlTextureResource : texture
			}
		}

		return createWebGlContext
	}
)

define(
	'spell/shared/util/color',
	[
		'spell/math/util',

		'spell/math/vec3',
		'spell/functions'
	],
	function(
		mathUtil,

		vec3
	) {
		'use strict'


		var toRange = function( value ) {
			return Math.round( mathUtil.clamp( value, 0, 1 ) * 255 )
		}


		var createRgb = function( r, g, b ) {
			return [ r, g, b ]
		}


		var createRgba = function( vec ) {
			return ( vec.length === 4 ?
				[ vec[ 0 ], vec[ 1 ], vec[ 2 ], vec[ 3 ] ] :
				[ vec[ 0 ], vec[ 1 ], vec[ 2 ], 1.0 ] )
		}


		var createRandom = function() {
			var primaryColorIndex = Math.round( Math.random() * 3 )
			var colorVec = vec3.fromValues( 0.8, 0.8, 0.8 )

			for( var i = 0; i < colorVec.length; i++ ) {
				if ( i === primaryColorIndex ) {
					colorVec[ i ] = 0.95

				} else {
					colorVec[ i ] *= Math.random()
				}
			}

			return colorVec
		}


		var formatCanvas = function( vec ) {
			if( vec.length === 4 ) {
				return 'rgba('
					+ toRange( vec[ 0 ] ) + ', '
					+ toRange( vec[ 1 ] ) + ', '
					+ toRange( vec[ 2 ] ) + ', '
					+ mathUtil.clamp( vec[ 3 ], 0, 1 ) + ')'
			}

			return 'rgb('
				+ toRange( vec[ 0 ] ) + ', '
				+ toRange( vec[ 1 ] ) + ', '
				+ toRange( vec[ 2 ] ) + ')'
		}


		return {
			createRgb    : createRgb,
			createRgba   : createRgba,
			createRandom : createRandom,
			formatCanvas : formatCanvas
		}
	}
)

define(
	'spell/shared/util/platform/private/Time',
	function() {
		'use strict'

		return {
			/*
			 * Returns the number of milliseconds since midnight January 1, 1970, UTC.
			 */
			getCurrentInMs: function() {
				return Date.now()
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/Int32Array',
	function() {
		'use strict'


		var isSupported = typeof( Int32Array ) !== 'undefined',
			arrayType   = isSupported ? Int32Array : Array

		return {
			isSupported : function() {
				return isSupported
			},
			create : function( length ) {
				return new arrayType( length )
			},
			fromValues : function( values ) {
				return isSupported ?
					new arrayType( values ) :
					values.slice( 0 )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/Uint16Array',
	function() {
		'use strict'


		var isSupported = typeof( Uint16Array ) !== 'undefined',
			arrayType   = isSupported ? Uint16Array : Array

		return {
			isSupported : function() {
				return isSupported
			},
			create : function( length ) {
				return new arrayType( length )
			},
			fromValues : function( values ) {
				return isSupported ?
					new arrayType( values ) :
					values.slice( 0 )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/Int8Array',
	function() {
		'use strict'


		var isSupported = typeof( Int8Array ) !== 'undefined',
			arrayType   = isSupported ? Int8Array : Array

		return {
			isSupported : function() {
				return isSupported
			},
			create : function( length ) {
				return new arrayType( length )
			},
			fromValues : function( values ) {
				return isSupported ?
					new arrayType( values ) :
					values.slice( 0 )
			}
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/hasFloatArraySupport',
	function() {
		'use strict'


		return function() {
			return typeof( Float32Array ) !== 'undefined'
		}
	}
)

define(
	'spell/shared/util/platform/private/nativeType/createFloatArray',
	[
		'spell/shared/util/platform/private/nativeType/hasFloatArraySupport'
	],
	function(
		hasFloatArraySupport
	) {
		'use strict'


		var arrayType = ( hasFloatArraySupport() ? Float32Array : Array )

		return function( length ) {
			return new arrayType( length )
		}
	}
)

define(
	'spell/shared/util/platform/private/graphics/StateStack',
	[
		'spell/shared/util/platform/private/nativeType/createFloatArray',

		'spell/math/mat3',
		'spell/functions'
	],
	function(
		createFloatArray,

		mat3,
		_
	) {
		'use strict'


		/*
		 * private
		 */

		var createState = function( opacity, color, lineColor, matrix, viewMatrix ) {
			return {
				opacity     : opacity,
				color       : color,
				lineColor   : lineColor,
				matrix      : matrix,
				viewMatrix  : viewMatrix
			}
		}

		var createDefaultState = function() {
			var opacity     = 1.0,
				color       = createFloatArray( 4 ),
				lineColor   = createFloatArray( 4 ),
				matrix      = mat3.create(),
				viewMatrix  = mat3.create()

			color[ 0 ] = 1.0
			color[ 1 ] = 1.0
			color[ 2 ] = 1.0
			color[ 3 ] = 1.0

			lineColor[ 0 ] = 1.0
			lineColor[ 1 ] = 1.0
			lineColor[ 2 ] = 1.0
			lineColor[ 3 ] = 1.0

			mat3.identity( matrix )
			mat3.identity( viewMatrix )

			return createState( opacity, color, lineColor, matrix, viewMatrix )
		}

		var copyState = function( source, target ) {
			target.opacity = source.opacity

			target.color[ 0 ] = source.color[ 0 ]
			target.color[ 1 ] = source.color[ 1 ]
			target.color[ 2 ] = source.color[ 2 ]
			target.color[ 3 ] = source.color[ 3 ]

			target.lineColor[ 0 ] = source.lineColor[ 0 ]
			target.lineColor[ 1 ] = source.lineColor[ 1 ]
			target.lineColor[ 2 ] = source.lineColor[ 2 ]
			target.lineColor[ 3 ] = source.lineColor[ 3 ]

			mat3.copy( target.matrix, source.matrix )
			mat3.copy( target.viewMatrix, source.viewMatrix )
		}


		/*
		 * public
		 */

		var StateStack = function( depth ) {
			this.depth = depth
			this.stack = _.range( depth )
			this.index = 0

			// initializing stack
			for( var i = 0, stack = this.stack; i < depth; i++ ) {
				stack[ i ] = createDefaultState()
			}
		}

		StateStack.prototype = {
			pushState : function() {
				var index = this.index,
					stack = this.stack

				if( index === this.depth -1 ) throw 'Can not push state. Maximum state stack depth of ' + this.depth + ' was reached.'


				copyState( stack[ index ], stack[ ++this.index ] )
			},
			popState : function() {
				var index = this.index

				if( index > 0 ) {
					this.index--

				} else {
					throw 'Can not pop state. The state stack is already depleted.'
				}
			},
			getTop : function() {
				return this.stack[ this.index ]
			}
		}

		return StateStack
	}
)

define(
	'spell/shared/util/platform/private/graphics/canvas/createCanvasContext',
	[
		'spell/functions',
		'spell/shared/util/platform/private/graphics/StateStack',
		'spell/shared/util/color',

		'spell/math/util',
		'spell/math/vec2',
		'spell/math/mat3'
	],
	function(
		_,
		StateStack,
		color,

		mathUtil,
		vec2,
		mat3
	) {
		'use strict'


		var modulo = mathUtil.modulo

		var context,
			canvas,
			clearColor   = color.formatCanvas( [ 0.0, 0.0, 0.0, 1.0 ] ),
			stateStack   = new StateStack( 32 ),
			currentState = stateStack.getTop()


		// HACK: this scale factor is used to mitigate the insane canvas-2d rasterization rules
		var magicScale    = 1.015,
			negMagicScale = -magicScale

		// scaling factor which must be applied to draw a one pixel wide line
		var pixelScale

		// world space to view space transformation matrix
		var worldToView = mat3.create()
		mat3.identity( worldToView )

		// view space to screen space transformation matrix
		var viewToScreen = mat3.create()
		mat3.identity( viewToScreen )

		// accumulated transformation world space to screen space transformation matrix
		var worldToScreen = mat3.create()
		mat3.identity( worldToScreen )

		var screenToWorld = mat3.create()
		mat3.identity( screenToWorld )

		var getUntilTexCoord = function( i, numIterations, endTexCoord ) {
			if( i + 1 === numIterations ) {
				var tc = endTexCoord % 1

				return tc === 0.0 ? 1.0 : tc
			}

			return 1
		}

		var normalizeStartTexCoord = function( tc ) {
			if( tc < 0.0 ) {
				tc += 1.0
			}

			return modulo( tc, 1.0 )
		}

		/**
		 * This function emulates texture mapping on canvas-2d. Rotation transformations and negative scales are not
		 * supported.
		 *
		 * @param context
		 * @param texture
		 * @param textureMatrix
		 * @param destinationDimensions
		 */
		var mapTexture = function( context, texture, textureMatrix, destinationDimensions ) {
			var scaleX            = Math.abs( textureMatrix[ 0 ] ),
				scaleY            = Math.abs( textureMatrix[ 4 ] ),
				textureWidth      = texture.dimensions[ 0 ],
				textureHeight     = texture.dimensions[ 1 ],
				destinationWidth  = destinationDimensions[ 0 ],
				destinationHeight = destinationDimensions[ 1 ]

			var startTexCoordX = normalizeStartTexCoord( textureMatrix[ 6 ] ),
				startTexCoordY = normalizeStartTexCoord( textureMatrix[ 7 ] ),
				endTexCoordX   = startTexCoordX + Math.abs( scaleX ),
				endTexCoordY   = startTexCoordY + Math.abs( scaleY )

			var numIterationsX = Math.round( Math.ceil( endTexCoordX ) - Math.floor( startTexCoordX ) ),
				numIterationsY = Math.round( Math.ceil( endTexCoordY ) - Math.floor( startTexCoordY ) )

			for( var y = 0,
				 fromTexCoordY = startTexCoordY,
				 untilTexCoordY = 0.0,
				 texCoordRangeY = 0.0,
				 scaledTexCoordRangeY = 0.0,
				 scaledTexCoordRangeX = 0.0,
				 destinationPositionY = 0.0,
				 coveredTexCoordY = 0.0;
				 y < numIterationsY;
				 y++ ) {

				untilTexCoordY       = getUntilTexCoord( y, numIterationsY, endTexCoordY )
				texCoordRangeY       = untilTexCoordY - fromTexCoordY
				coveredTexCoordY     += texCoordRangeY
				scaledTexCoordRangeY = texCoordRangeY / scaleY

				for( var x = 0,
					 fromTexCoordX = startTexCoordX,
					 untilTexCoordX = 0.0,
					 texCoordRangeX = 0.0,
					 destinationPositionX = 0.0,
					 coveredTexCoordX = 0.0;
					 x < numIterationsX;
					 x++ ) {

					untilTexCoordX       = getUntilTexCoord( x, numIterationsX, endTexCoordX )
					texCoordRangeX       = untilTexCoordX - fromTexCoordX
					coveredTexCoordX     += texCoordRangeX
					scaledTexCoordRangeX = texCoordRangeX / scaleX

					context.drawImage(
						texture.privateImageResource,
						textureWidth * fromTexCoordX,
						textureHeight * fromTexCoordY,
						textureWidth * texCoordRangeX,
						textureHeight * texCoordRangeY,
						destinationWidth * destinationPositionX,
						destinationHeight * destinationPositionY,
						destinationWidth * scaledTexCoordRangeX,
						destinationHeight * scaledTexCoordRangeY
					)

					destinationPositionX += scaledTexCoordRangeX
					fromTexCoordX = 0
				}

				destinationPositionY += scaledTexCoordRangeY
				fromTexCoordY = 0
			}
		}

		/*
		 * Returns true if the supplied quad covers the full screen, false otherwise.
		 *
		 * @param x
		 * @param y
		 * @param width
		 * @param height
		 */
		var isFullscreenCovered = function( x, y, width, height ) {
			var leftBorder   = x,
				rightBorder  = x + width,
				topBorder    = y + height,
				bottomBorder = y

			return ( leftBorder <= 0 &&
				rightBorder >= canvas.width &&
				topBorder >= canvas.height &&
				bottomBorder <= 0 )
		}

		var setClippingRegion = function( x, y, width, height ) {
			context.beginPath()
			context.rect( x, y, width, height )
			context.closePath()
			context.clip()
		}

		var updateWorldToScreen = function( viewToScreen, worldToView ) {
			mat3.multiply( worldToScreen, viewToScreen, worldToView )
			mat3.invert( screenToWorld, worldToScreen )

			pixelScale = Math.abs( 1 / worldToScreen[ 0 ] )

			context.setTransform(
				worldToScreen[ 0 ],
				worldToScreen[ 1 ],
				worldToScreen[ 3 ],
				worldToScreen[ 4 ],
				worldToScreen[ 6 ],
				worldToScreen[ 7 ]
			)
		}

		var initWrapperContext = function() {
			viewport( 0.0, 0.0, canvas.width, canvas.height )

			// world space to view space matrix
			var cameraWidth  = canvas.width,
				cameraHeight = canvas.height

			mathUtil.mat3Ortho(
				worldToView,
				-cameraWidth * 0.5,
				cameraWidth * 0.5,
				-cameraHeight * 0.5,
				cameraHeight * 0.5
			)

			mat3.translate( worldToView, worldToView, [ -cameraWidth * 0.5, -cameraHeight * 0.5 ] ) // WATCH OUT: apply inverse translation for camera position

			updateWorldToScreen( viewToScreen, worldToView )
		}

		/*
		 * Creates a wrapper context from the backend context.
		 */
		var createWrapperContext = function() {
			initWrapperContext()

			// The gameclosure canvas wrapper exposes a flush method. It flushes accumulated state to the color buffer.
			var flush = _.isFunction( context.flush ) ? context.flush : function() {}

			return {
				clear                  : clear,
				createTexture          : createCanvasTexture,
				drawTexture            : drawTexture,
				drawSubTexture         : drawSubTexture,
				drawRect               : drawRect,
				drawCircle             : drawCircle,
				drawLine               : drawLine,
				fillRect               : fillRect,
				getConfiguration       : getConfiguration,
				resizeColorBuffer      : resizeColorBuffer,
				restore                : restore,
				rotate                 : rotate,
				save                   : save,
				scale                  : scale,
				setClearColor          : setClearColor,
				setColor               : setColor,
				setLineColor           : setLineColor,
				setGlobalAlpha         : setGlobalAlpha,
				setTransform           : setTransform,
				setViewMatrix          : setViewMatrix,
				transform              : transform,
				translate              : translate,
				viewport               : viewport,
				transformScreenToWorld : transformScreenToWorld,
				getCanvasElement       : function() { return canvas },
				flush                  : flush
			}
		}

		/*
		 * Returns a rendering context. Once a context has been created additional calls to this method return the same context instance.
		 *
		 * @param canvas - the canvas dom element
		 */
		var createCanvasContext = function( canvasObj ) {
			if( canvasObj === undefined ) throw 'Missing first argument.'

			if( context !== undefined ) return context

			canvas  = canvasObj
			context = canvas.getContext( '2d' )

			if( context === null ) return null

			return createWrapperContext()
		}


		/*
		 * public
		 */
		var transformScreenToWorld = function( vec ) {
			return vec2.transformMat3( vec2.create(), vec, screenToWorld )
		}

		var setColor = function( vec ) {
			currentState.color = color.createRgba( vec )
			context.fillStyle = color.formatCanvas( vec )
		}

		var setLineColor = function( vec ) {
			currentState.lineColor = color.createRgba( vec )
			context.strokeStyle = color.formatCanvas( vec )
		}

		var setGlobalAlpha = function( u ) {
			currentState.opacity = u
			context.globalAlpha = u
		}

		var setClearColor = function( vec ) {
			clearColor = color.formatCanvas( vec )
		}

		var save = function() {
			stateStack.pushState()
			currentState = stateStack.getTop()
		}

		var restore = function() {
			stateStack.popState()
			currentState = stateStack.getTop()

			setViewMatrix( currentState.viewMatrix )
		}

		var scale = function( vec ) {
			mat3.scale( currentState.matrix, currentState.matrix, vec )
		}

		var translate = function( vec ) {
			mat3.translate( currentState.matrix, currentState.matrix, vec )
		}

		var rotate = function( u ) {
			mat3.rotate( currentState.matrix, u )
		}

		/*
		 * Clears the color buffer with the clear color
		 */
		var clear = function() {
 			context.save()
			{
				// reset transformation to identity
				context.setTransform( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0 )

				context.globalAlpha = 1.0
				context.fillStyle = clearColor
				context.fillRect( 0.0, 0.0, canvas.width, canvas.height )
			}
			context.restore()
		}

		var drawTexture = function( texture, destinationPosition, destinationDimensions, textureMatrix ) {
			if( texture === undefined ) throw 'Texture is undefined'

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				if( !textureMatrix ) {
					// rotating the image so that it is not upside down
					context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
					context.rotate( Math.PI )
					context.scale( -1.0, 1.0 )
					context.translate( 0.0, -destinationDimensions[ 1 ] )

					context.drawImage(
						texture.privateImageResource,
						0.0,
						0.0,
						destinationDimensions[ 0 ],
						destinationDimensions[ 1 ]
					)

				} else {
					context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
					context.rotate( Math.PI )

					// Compensating for the lack of negative scales support in mapTexture by letting canvas do the work.
					// Macgyver would have been proud.
					var xAxisInverted = textureMatrix[ 0 ] < 0.0,
						yAxisInverted = textureMatrix[ 4 ] < 0.0

					context.scale(
						xAxisInverted ? 1.0 : -1.0,
						yAxisInverted ? -1.0 : 1.0
					)

					context.translate(
						xAxisInverted ? -destinationDimensions[ 0 ] : 0.0,
						yAxisInverted ? 0.0 : -destinationDimensions[ 1 ]
					)

					mapTexture( context, texture, textureMatrix, destinationDimensions )
				}
			}
			context.restore()
		}

		var drawSubTexture = function( texture, sourcePosition, sourceDimensions, destinationPosition, destinationDimensions ) {
			if( texture === undefined ) throw 'Texture is undefined'

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				// rotating the image so that it is not upside down
				context.translate( destinationPosition[ 0 ], destinationPosition[ 1 ] )
				context.rotate( Math.PI )
				context.scale( negMagicScale, magicScale )
				context.translate( 0.0, -destinationDimensions[ 1 ] )

				context.drawImage(
					texture.privateImageResource,
					sourcePosition[ 0 ],
					sourcePosition[ 1 ],
					sourceDimensions[ 0 ],
					sourceDimensions[ 1 ],
					0,
					0,
					destinationDimensions[ 0 ],
					destinationDimensions[ 1 ]
				)
			}
			context.restore()
		}

		var drawRect = function( dx, dy, dw, dh, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				context.lineWidth = pixelScale * lineWidth
			    context.strokeRect( dx, dy, dw, dh )
			}
			context.restore()
		}

		var drawCircle = function( dx, dy, radius, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				context.lineWidth = pixelScale * lineWidth
				context.beginPath()
				context.arc( dx, dy, radius, 0, Math.PI * 2, true )
				context.stroke()
			}
			context.restore()
		}

		var drawLine = function( ax, ay, bx, by, lineWidth ) {
			if( !lineWidth ) lineWidth = 1

			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				var scaledLineWidth = pixelScale * lineWidth

				context.lineWidth = scaledLineWidth

				context.beginPath()
				context.moveTo( ax, ay )
				context.lineTo( bx, by )
				context.stroke()
			}
			context.restore()
		}

		var fillRect = function( dx, dy, dw, dh ) {
			context.save()
			{
				context.globalAlpha = currentState.opacity

				var modelToWorld = currentState.matrix

				context.transform(
					modelToWorld[ 0 ],
					modelToWorld[ 1 ],
					modelToWorld[ 3 ],
					modelToWorld[ 4 ],
					modelToWorld[ 6 ],
					modelToWorld[ 7 ]
				)

				// rotating the image so that it is not upside down
				context.translate( dx, dy )
				context.rotate( Math.PI )
				context.scale( -1.0, 1.0 )
				context.translate( 0.0, -dh )

				context.fillRect( 0.0, 0.0, dw, dh )
			}
			context.restore()
		}

		var resizeColorBuffer = function( width, height ) {
			canvas.width  = width
			canvas.height = height
		}

		var transform = function( matrix ) {
			mat3.multiply( matrix, currentState.matrix )
		}

		var setTransform = function( matrix ) {
			mat3.copy( currentState.matrix, matrix )
		}

		var setViewMatrix = function( matrix ) {
			mat3.copy( currentState.viewMatrix, matrix )
			mat3.copy( worldToView, matrix )

			updateWorldToScreen( viewToScreen, worldToView )
		}

		var viewport = function( x, y, width, height ) {
			mat3.identity( viewToScreen )

			viewToScreen[ 0 ] = width * 0.5
			viewToScreen[ 4 ] = height * 0.5 * -1 // mirroring y-axis
			viewToScreen[ 6 ] = x + width * 0.5
			viewToScreen[ 7 ] = y + height * 0.5

			updateWorldToScreen( viewToScreen, worldToView )

			if( !isFullscreenCovered( x, y, width, height ) ) {
				setClippingRegion( x, y, width, height )
			}
		}

		/*
		 * Returns an object describing the current configuration of the rendering backend.
		 */
		var getConfiguration = function() {
			return {
				type   : 'canvas-2d',
				width  : canvas.width,
				height : canvas.height,
				info   : ''
			}
		}

		/*
		 * Returns instance of texture class
		 *
		 * The public interface of the texture class consists of the two attributes width and height.
		 *
		 * @param image
		 */
		var createCanvasTexture = function( image ) {
			return {
				/*
				 * Public
				 */
				dimensions : [ image.width, image.height ],

				/*
				 * Private
				 *
				 * This is an implementation detail of the class. If you write code that depends on this you better know what you are doing.
				 */
				privateImageResource : image
			}
		}

		return createCanvasContext
	}
)

define(
	'spell/shared/util/platform/private/graphics/RenderingFactory',
	[
		'spell/shared/util/platform/private/graphics/canvas/createCanvasContext',
		'spell/shared/util/platform/private/graphics/webgl/createWebGlContext',
		'spell/shared/util/platform/private/graphics/createCanvasNode'
	],
	function(
		createCanvasContext,
		createWebGlContext,
		createCanvasNode
	) {
		'use strict'


		var BACK_END_CANVAS = 'canvas-2d',
			BACK_END_WEBGL  = 'webgl'

		/*
		 * Creates a rendering context
		 *
         * @param eventManager - Eventmanager
		 * @param id - the id of the dom node the engine instance is placed in
		 * @param width - width in pixels
		 * @param height - height in pixels
		 * @param requestedBackEnd - when supplied, overrides the automagic rendering back-end detection
		 */
		var createContext2d = function( eventManager, id, width, height, requestedBackEnd ) {
			var canvas = createCanvasNode( id, width, height ),
				context

			if( canvas === null || canvas === undefined ) throw 'Could not create canvas node.'

			// webgl
			if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_WEBGL ) ) {
				context = createWebGlContext( canvas )

				if( context ) return context
			}

			// canvas-2d
			if( requestedBackEnd === undefined ? true : ( requestedBackEnd === BACK_END_CANVAS ) ) {
				// HACK: disable default canvas scaling behaviour on html5-ejecta
				if( canvas.scalingMode ) {
					canvas.scalingMode = 'none'
				}

				context = createCanvasContext( canvas )

				if( context ) return context
			}

			throw 'Could not create a rendering back-end.'
		}

		return {
			BACK_END_WEBGL : BACK_END_WEBGL,
			BACK_END_CANVAS : BACK_END_CANVAS,
			createContext2d : createContext2d
		}
	}
)

define(
	'spell/shared/util/platform/private/configurationOptions',
	[
		'spell/shared/util/platform/private/graphics/RenderingFactory',
		'spell/shared/util/platform/private/sound/AudioFactory'
	],
	function(
		RenderingFactory,
		AudioFactory
	) {
		'use strict'


		/*
		 * These are the platform specific options.
		 */
		var validOptions = {
			renderingBackEnd : {
				validValues  : [
					RenderingFactory.BACK_END_CANVAS,
					RenderingFactory.BACK_END_WEBGL
				],
				configurable : true
			},
			audioBackEnd : {
				validValues  : [
					AudioFactory.BACK_END_DUMMY_AUDIO,
					AudioFactory.BACK_END_WEB_AUDIO,
					AudioFactory.BACK_END_HTML5_AUDIO,
					AudioFactory.BACK_END_NATIVE_AUDIO
				],
				configurable : true
			},
			libraryUrl : {
				configurable : true
			}
		}

		/*
		 * These options are used when they are not overridden by the environment configuration set up by the stage-0-loader.
		 */
		var defaultOptions = {
			renderingBackEnd : 'canvas-2d',
			audioBackEnd : 'html5',
			libraryUrl : 'library'
		}

		return {
			defaultOptions : defaultOptions,
			validOptions   : validOptions
		}
	}
)

define(
	"spell/shared/util/platform/private/callNextFrame",
	[
		"spell/shared/util/platform/private/registerTimer"
	],
	function(
		registerTimer
	) {
		"use strict";


		// running in node context
		if( typeof window === "undefined" ) {
			return function( callback ) {
				registerTimer( callback, 5 )
			}
		}


		// running in browser
		var browserCallback = (
			window.requestAnimationFrame       ||
			window.webkitRequestAnimationFrame ||
			window.mozRequestAnimationFrame    ||
			window.oRequestAnimationFrame      ||
			window.msRequestAnimationFrame
		)

		var hasBrowserSupport = !!browserCallback

		if( hasBrowserSupport ) {
			return function( callback ) {
				browserCallback.call( window, callback )
			}
		}


		// no browser support
		return function( callback ) {
			registerTimer(
				function() {
					callback( new Date() )
				},
				1000 / 60 // 60 Hz
			)
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5WinPhone',
	function() {
		'use strict'

		return window.external && typeof(window.external.notify ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5Tizen',
	function() {
		'use strict'


		return typeof( tizen ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/Application',
	[
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/environment/isHtml5Tizen',
		'spell/shared/util/platform/private/environment/isHtml5WinPhone'
	],
	function(
		isHtml5TeaLeaf,
	    isHtml5Tizen,
		isHtml5WinPhone
	) {
		'use strict'


		return {
			close : function() {
				if( isHtml5TeaLeaf ) {
					NATIVE.sendActivityToBack()

				} else if ( isHtml5Tizen ) {
					tizen.application.getCurrentApplication().exit()

				} else if ( isHtml5WinPhone ) {
					window.external.notify( 'endApplication' )
				}
			}
		}
	}
)

/**
 * This class is derived from the library "Underscore" which original license follows:
 *
 * Licence Notice Underscore.js 1.3.3:
 *
 * Copyright (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */
define(
	'spell/shared/util/platform/private/functions',
	function() {
		// Baseline setup
		// --------------

		// Establish the root object, `window` in the browser, or `global` on the server.
		var root = this;

		// Save the previous value of the `_` variable.
		var previousUnderscore = root._;

		// Establish the object that gets returned to break out of a loop iteration.
		var breaker = {};

		// Save bytes in the minified (but not gzipped) version:
		var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

		// Create quick reference variables for speed access to core prototypes.
		var slice            = ArrayProto.slice,
				unshift          = ArrayProto.unshift,
				toString         = ObjProto.toString,
				hasOwnProperty   = ObjProto.hasOwnProperty;

		// All **ECMAScript 5** native function implementations that we hope to use
		// are declared here.
		var
				nativeForEach      = ArrayProto.forEach,
				nativeMap          = ArrayProto.map,
				nativeReduce       = ArrayProto.reduce,
				nativeReduceRight  = ArrayProto.reduceRight,
				nativeFilter       = ArrayProto.filter,
				nativeEvery        = ArrayProto.every,
				nativeSome         = ArrayProto.some,
				nativeIndexOf      = ArrayProto.indexOf,
				nativeLastIndexOf  = ArrayProto.lastIndexOf,
				nativeIsArray      = Array.isArray,
				nativeKeys         = Object.keys,
				nativeBind         = FuncProto.bind;

		// Create a safe reference to the Underscore object for use below.
		var _ = function(obj) { return new wrapper(obj); };

		// Export the Underscore object for **Node.js**, with
		// backwards-compatibility for the old `require()` API. If we're in
		// the browser, add `_` as a global object via a string identifier,
		// for Closure Compiler "advanced" mode.
		if (typeof exports !== 'undefined') {
			if (typeof module !== 'undefined' && module.exports) {
				exports = module.exports = _;
			}
			exports._ = _;
		} else {
			root['_'] = _;
		}

		// Current version.
		_.VERSION = '1.3.3';

		// Collection Functions
		// --------------------

		// The cornerstone, an `each` implementation, aka `forEach`.
		// Handles objects with the built-in `forEach`, arrays, and raw objects.
		// Delegates to **ECMAScript 5**'s native `forEach` if available.
		var each = _.each = _.forEach = function(obj, iterator, context) {
			if (obj == null) return;
			if (nativeForEach && obj.forEach === nativeForEach) {
				obj.forEach(iterator, context);
			} else if ( _.isArray( obj ) ) {
				for (var i = 0, l = obj.length; i < l; i++) {
					if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;
				}
			} else {
				for (var key in obj) {
					if (_.has(obj, key)) {
						if (iterator.call(context, obj[key], key, obj) === breaker) return;
					}
				}
			}
		};

		// Return the results of applying the iterator to each element.
		// Delegates to **ECMAScript 5**'s native `map` if available.
		_.map = _.collect = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
			each(obj, function(value, index, list) {
				results[results.length] = iterator.call(context, value, index, list);
			});
			if ( _.isArray( obj ) ) results.length = obj.length;
			return results;
		};

		// **Reduce** builds up a single result from a list of values, aka `inject`,
		// or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
		_.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
			var initial = arguments.length > 2;
			if (obj == null) obj = [];
			if (nativeReduce && obj.reduce === nativeReduce) {
				if (context) iterator = _.bind(iterator, context);
				return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
			}
			each(obj, function(value, index, list) {
				if (!initial) {
					memo = value;
					initial = true;
				} else {
					memo = iterator.call(context, memo, value, index, list);
				}
			});
			if (!initial) throw new TypeError('Reduce of empty array with no initial value');
			return memo;
		};

		// The right-associative version of reduce, also known as `foldr`.
		// Delegates to **ECMAScript 5**'s native `reduceRight` if available.
		_.reduceRight = _.foldr = function(obj, iterator, memo, context) {
			var initial = arguments.length > 2;
			if (obj == null) obj = [];
			if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
				if (context) iterator = _.bind(iterator, context);
				return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
			}
			var reversed = _.toArray(obj).reverse();
			if (context && !initial) iterator = _.bind(iterator, context);
			return initial ? _.reduce(reversed, iterator, memo, context) : _.reduce(reversed, iterator);
		};

		// Return the first value which passes a truth test. Aliased as `detect`.
		_.find = _.detect = function(obj, iterator, context) {
			var result;
			any(obj, function(value, index, list) {
				if (iterator.call(context, value, index, list)) {
					result = value;
					return true;
				}
			});
			return result;
		};

		// Return all the elements that pass a truth test.
		// Delegates to **ECMAScript 5**'s native `filter` if available.
		// Aliased as `select`.
		_.filter = _.select = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);
			each(obj, function(value, index, list) {
				if (iterator.call(context, value, index, list)) results[results.length] = value;
			});
			return results;
		};

		// Return all the elements for which a truth test fails.
		_.reject = function(obj, iterator, context) {
			var results = [];
			if (obj == null) return results;
			each(obj, function(value, index, list) {
				if (!iterator.call(context, value, index, list)) results[results.length] = value;
			});
			return results;
		};

		// Determine whether all of the elements match a truth test.
		// Delegates to **ECMAScript 5**'s native `every` if available.
		// Aliased as `all`.
		_.every = _.all = function(obj, iterator, context) {
			var result = true;
			if (obj == null) return result;
			if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);
			each(obj, function(value, index, list) {
				if (!(result = result && iterator.call(context, value, index, list))) return breaker;
			});
			return !!result;
		};

		// Determine if at least one element in the object matches a truth test.
		// Delegates to **ECMAScript 5**'s native `some` if available.
		// Aliased as `any`.
		var any = _.some = _.any = function(obj, iterator, context) {
			iterator || (iterator = _.identity);
			var result = false;
			if (obj == null) return result;
			if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);
			each(obj, function(value, index, list) {
				if (result || (result = iterator.call(context, value, index, list))) return breaker;
			});
			return !!result;
		};

		// Determine if a given value is included in the array or object using `===`.
		// Aliased as `contains`.
		_.include = _.contains = function(obj, target) {
			var found = false;
			if (obj == null) return found;
			if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
			found = any(obj, function(value) {
				return value === target;
			});
			return found;
		};

		// Invoke a method (with arguments) on every item in a collection.
		_.invoke = function(obj, method) {
			var args = slice.call(arguments, 2);
			return _.map(obj, function(value) {
				return (_.isFunction(method) ? method || value : value[method]).apply(value, args);
			});
		};

		// Convenience version of a common use case of `map`: fetching a property.
		_.pluck = function(obj, key) {
			return _.map(obj, function(value){ return value[key]; });
		};

		// Return the maximum element or (element-based computation).
		_.max = function(obj, iterator, context) {
			if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.max.apply(Math, obj);
			if (!iterator && _.isEmpty(obj)) return -Infinity;
			var result = {computed : -Infinity};
			each(obj, function(value, index, list) {
				var computed = iterator ? iterator.call(context, value, index, list) : value;
				computed >= result.computed && (result = {value : value, computed : computed});
			});
			return result.value;
		};

		// Return the minimum element (or element-based computation).
		_.min = function(obj, iterator, context) {
			if (!iterator && _.isArray(obj) && obj[0] === +obj[0]) return Math.min.apply(Math, obj);
			if (!iterator && _.isEmpty(obj)) return Infinity;
			var result = {computed : Infinity};
			each(obj, function(value, index, list) {
				var computed = iterator ? iterator.call(context, value, index, list) : value;
				computed < result.computed && (result = {value : value, computed : computed});
			});
			return result.value;
		};

		// Shuffle an array.
		_.shuffle = function(obj) {
			var shuffled = [], rand;
			each(obj, function(value, index, list) {
				rand = Math.floor(Math.random() * (index + 1));
				shuffled[index] = shuffled[rand];
				shuffled[rand] = value;
			});
			return shuffled;
		};

		// Sort the object's values by a criterion produced by an iterator.
		_.sortBy = function(obj, val, context) {
			var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
			return _.pluck(_.map(obj, function(value, index, list) {
				return {
					value : value,
					criteria : iterator.call(context, value, index, list)
				};
			}).sort(function(left, right) {
						var a = left.criteria, b = right.criteria;
						if (a === void 0) return 1;
						if (b === void 0) return -1;
						return a < b ? -1 : a > b ? 1 : 0;
					}), 'value');
		};

		// Groups the object's values by a criterion. Pass either a string attribute
		// to group by, or a function that returns the criterion.
		_.groupBy = function(obj, val) {
			var result = {};
			var iterator = _.isFunction(val) ? val : function(obj) { return obj[val]; };
			each(obj, function(value, index) {
				var key = iterator(value, index);
				(result[key] || (result[key] = [])).push(value);
			});
			return result;
		};

		// Use a comparator function to figure out at what index an object should
		// be inserted so as to maintain order. Uses binary search.
		_.sortedIndex = function(array, obj, iterator) {
			iterator || (iterator = _.identity);
			var low = 0, high = array.length;
			while (low < high) {
				var mid = (low + high) >> 1;
				iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;
			}
			return low;
		};

		// Safely convert anything iterable into a real, live array.
		_.toArray = function(obj) {
			if (!obj)                                     return [];
			if (_.isArray(obj))                           return slice.call(obj);
			if (_.isArguments(obj))                       return slice.call(obj);
			if (obj.toArray && _.isFunction(obj.toArray)) return obj.toArray();
			return _.values(obj);
		};

		// Return the number of elements in an object.
		_.size = function(obj) {
			return _.isArray(obj) ? obj.length : _.keys(obj).length;
		};

		// Array Functions
		// ---------------

		// Get the first element of an array. Passing **n** will return the first N
		// values in the array. Aliased as `head` and `take`. The **guard** check
		// allows it to work with `_.map`.
		_.first = _.head = _.take = function(array, n, guard) {
			return (n != null) && !guard ? slice.call(array, 0, n) : array[0];
		};

		// Returns everything but the last entry of the array. Especcialy useful on
		// the arguments object. Passing **n** will return all the values in
		// the array, excluding the last N. The **guard** check allows it to work with
		// `_.map`.
		_.initial = function(array, n, guard) {
			return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
		};

		// Get the last element of an array. Passing **n** will return the last N
		// values in the array. The **guard** check allows it to work with `_.map`.
		_.last = function(array, n, guard) {
			if ((n != null) && !guard) {
				return slice.call(array, Math.max(array.length - n, 0));
			} else {
				return array[array.length - 1];
			}
		};

		// Returns everything but the first entry of the array. Aliased as `tail`.
		// Especially useful on the arguments object. Passing an **index** will return
		// the rest of the values in the array from that index onward. The **guard**
		// check allows it to work with `_.map`.
		_.rest = _.tail = function(array, index, guard) {
			return slice.call(array, (index == null) || guard ? 1 : index);
		};

		// Trim out all falsy values from an array.
		_.compact = function(array) {
			return _.filter(array, function(value){ return !!value; });
		};

		// Return a completely flattened version of an array.
		_.flatten = function(array, shallow) {
			return _.reduce(array, function(memo, value) {
				if (_.isArray(value)) return memo.concat(shallow ? value : _.flatten(value));
				memo[memo.length] = value;
				return memo;
			}, []);
		};

		// Return a version of the array that does not contain the specified value(s).
		_.without = function(array) {
			return _.difference(array, slice.call(arguments, 1));
		};

		// Produce a duplicate-free version of the array. If the array has already
		// been sorted, you have the option of using a faster algorithm.
		// Aliased as `unique`.
		_.uniq = _.unique = function(array, isSorted, iterator) {
			var initial = iterator ? _.map(array, iterator) : array;
			var results = [];
			// The `isSorted` flag is irrelevant if the array only contains two elements.
			if (array.length < 3) isSorted = true;
			_.reduce(initial, function (memo, value, index) {
				if (isSorted ? _.last(memo) !== value || !memo.length : !_.include(memo, value)) {
					memo.push(value);
					results.push(array[index]);
				}
				return memo;
			}, []);
			return results;
		};

		// Produce an array that contains the union: each distinct element from all of
		// the passed-in arrays.
		_.union = function() {
			return _.uniq(_.flatten(arguments, true));
		};

		// Produce an array that contains every item shared between all the
		// passed-in arrays. (Aliased as "intersect" for back-compat.)
		_.intersection = _.intersect = function(array) {
			var rest = slice.call(arguments, 1);
			return _.filter(_.uniq(array), function(item) {
				return _.every(rest, function(other) {
					return _.indexOf(other, item) >= 0;
				});
			});
		};

		// Take the difference between one array and a number of other arrays.
		// Only the elements present in just the first array will remain.
		_.difference = function(array) {
			var rest = _.flatten(slice.call(arguments, 1), true);
			return _.filter(array, function(value){ return !_.include(rest, value); });
		};

		// Zip together multiple lists into a single array -- elements that share
		// an index go together.
		_.zip = function() {
			var args = slice.call(arguments);
			var length = _.max(_.pluck(args, 'length'));
			var results = new Array(length);
			for (var i = 0; i < length; i++) results[i] = _.pluck(args, "" + i);
			return results;
		};

		// If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
		// we need this function. Return the position of the first occurrence of an
		// item in an array, or -1 if the item is not included in the array.
		// Delegates to **ECMAScript 5**'s native `indexOf` if available.
		// If the array is large and already in sort order, pass `true`
		// for **isSorted** to use binary search.
		_.indexOf = function(array, item, isSorted) {
			if (array == null) return -1;
			var i, l;
			if (isSorted) {
				i = _.sortedIndex(array, item);
				return array[i] === item ? i : -1;
			}
			if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);
			for (i = 0, l = array.length; i < l; i++) if (i in array && array[i] === item) return i;
			return -1;
		};

		// Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
		_.lastIndexOf = function(array, item) {
			if (array == null) return -1;
			if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);
			var i = array.length;
			while (i--) if (i in array && array[i] === item) return i;
			return -1;
		};

		// Generate an integer Array containing an arithmetic progression. A port of
		// the native Python `range()` function. See
		// [the Python documentation](http://docs.python.org/library/functions.html#range).
		_.range = function(start, stop, step) {
			if (arguments.length <= 1) {
				stop = start || 0;
				start = 0;
			}
			step = arguments[2] || 1;

			var len = Math.max(Math.ceil((stop - start) / step), 0);
			var idx = 0;
			var range = new Array(len);

			while(idx < len) {
				range[idx++] = start;
				start += step;
			}

			return range;
		};

		// Function (ahem) Functions
		// ------------------

		// Reusable constructor function for prototype setting.
		var ctor = function(){};

		// Create a function bound to a given object (assigning `this`, and arguments,
		// optionally). Binding with arguments is also known as `curry`.
		// Delegates to **ECMAScript 5**'s native `Function.bind` if available.
		// We check for `func.bind` first, to fail fast when `func` is undefined.
		_.bind = function bind(func, context) {
			var bound, args;
			if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
			if (!_.isFunction(func)) throw new TypeError;
			args = slice.call(arguments, 2);
			return bound = function() {
				if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
				ctor.prototype = func.prototype;
				var self = new ctor;
				var result = func.apply(self, args.concat(slice.call(arguments)));
				if (Object(result) === result) return result;
				return self;
			};
		};

		// Bind all of an object's methods to that object. Useful for ensuring that
		// all callbacks defined on an object belong to it.
		_.bindAll = function(obj) {
			var funcs = slice.call(arguments, 1);
			if (funcs.length == 0) funcs = _.functions(obj);
			each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
			return obj;
		};

		// Memoize an expensive function by storing its results.
		_.memoize = function(func, hasher) {
			var memo = {};
			hasher || (hasher = _.identity);
			return function() {
				var key = hasher.apply(this, arguments);
				return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
			};
		};

		// Delays a function for the given number of milliseconds, and then calls
		// it with the arguments supplied.
		_.delay = function(func, wait) {
			var args = slice.call(arguments, 2);
			return setTimeout(function(){ return func.apply(null, args); }, wait);
		};

		// Defers a function, scheduling it to run after the current call stack has
		// cleared.
		_.defer = function(func) {
			return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
		};

		// Returns a function, that, when invoked, will only be triggered at most once
		// during a given window of time.
		_.throttle = function(func, wait) {
			var context, args, timeout, throttling, more, result;
			var whenDone = _.debounce(function(){ more = throttling = false; }, wait);
			return function() {
				context = this; args = arguments;
				var later = function() {
					timeout = null;
					if (more) func.apply(context, args);
					whenDone();
				};
				if (!timeout) timeout = setTimeout(later, wait);
				if (throttling) {
					more = true;
				} else {
					result = func.apply(context, args);
				}
				whenDone();
				throttling = true;
				return result;
			};
		};

		// Returns a function, that, as long as it continues to be invoked, will not
		// be triggered. The function will be called after it stops being called for
		// N milliseconds. If `immediate` is passed, trigger the function on the
		// leading edge, instead of the trailing.
		_.debounce = function(func, wait, immediate) {
			var timeout;
			return function() {
				var context = this, args = arguments;
				var later = function() {
					timeout = null;
					if (!immediate) func.apply(context, args);
				};
				if (immediate && !timeout) func.apply(context, args);
				clearTimeout(timeout);
				timeout = setTimeout(later, wait);
			};
		};

		// Returns a function that will be executed at most one time, no matter how
		// often you call it. Useful for lazy initialization.
		_.once = function(func) {
			var ran = false, memo;
			return function() {
				if (ran) return memo;
				ran = true;
				return memo = func.apply(this, arguments);
			};
		};

		// Returns the first function passed as an argument to the second,
		// allowing you to adjust arguments, run code before and after, and
		// conditionally execute the original function.
		_.wrap = function(func, wrapper) {
			return function() {
				var args = [func].concat(slice.call(arguments, 0));
				return wrapper.apply(this, args);
			};
		};

		// Returns a function that is the composition of a list of functions, each
		// consuming the return value of the function that follows.
		_.compose = function() {
			var funcs = arguments;
			return function() {
				var args = arguments;
				for (var i = funcs.length - 1; i >= 0; i--) {
					args = [funcs[i].apply(this, args)];
				}
				return args[0];
			};
		};

		// Returns a function that will only be executed after being called N times.
		_.after = function(times, func) {
			if (times <= 0) return func();
			return function() {
				if (--times < 1) { return func.apply(this, arguments); }
			};
		};

		// Object Functions
		// ----------------

		// Retrieve the names of an object's properties.
		// Delegates to **ECMAScript 5**'s native `Object.keys`
		_.keys = nativeKeys || function(obj) {
			if (obj !== Object(obj)) throw new TypeError('Invalid object');
			var keys = [];
			for (var key in obj) if (_.has(obj, key)) keys[keys.length] = key;
			return keys;
		};

		// Retrieve the values of an object's properties.
		_.values = function(obj) {
			return _.map(obj, _.identity);
		};

		// Return a sorted list of the function names available on the object.
		// Aliased as `methods`
		_.functions = _.methods = function(obj) {
			var names = [];
			for (var key in obj) {
				if (_.isFunction(obj[key])) names.push(key);
			}
			return names.sort();
		};

		// Extend a given object with all the properties in passed-in object(s).
		_.extend = function(obj) {
			each(slice.call(arguments, 1), function(source) {
				for (var prop in source) {
					obj[prop] = source[prop];
				}
			});
			return obj;
		};

		// Return a copy of the object only containing the whitelisted properties.
		_.pick = function(obj) {
			var result = {};
			each(_.flatten(slice.call(arguments, 1)), function(key) {
				if (key in obj) result[key] = obj[key];
			});
			return result;
		};

		// Fill in a given object with default properties.
		_.defaults = function(obj) {
			each(slice.call(arguments, 1), function(source) {
				for (var prop in source) {
					if (obj[prop] == null) obj[prop] = source[prop];
				}
			});
			return obj;
		};

		// Create a (shallow-cloned) duplicate of an object.
		_.clone = function(obj) {
			if (!_.isObject(obj)) return obj;
			return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
		};

		// Invokes interceptor with the obj, and then returns obj.
		// The primary purpose of this method is to "tap into" a method chain, in
		// order to perform operations on intermediate results within the chain.
		_.tap = function(obj, interceptor) {
			interceptor(obj);
			return obj;
		};

		// Internal recursive comparison function.
		function eq(a, b, stack) {
			// Identical objects are equal. `0 === -0`, but they aren't identical.
			// See the Harmony `egal` proposal: http://wiki.ecmascript.org/doku.php?id=harmony:egal.
			if (a === b) return a !== 0 || 1 / a == 1 / b;
			// A strict comparison is necessary because `null == undefined`.
			if (a == null || b == null) return a === b;
			// Unwrap any wrapped objects.
			if (a._chain) a = a._wrapped;
			if (b._chain) b = b._wrapped;
			// Invoke a custom `isEqual` method if one is provided.
			if (a.isEqual && _.isFunction(a.isEqual)) return a.isEqual(b);
			if (b.isEqual && _.isFunction(b.isEqual)) return b.isEqual(a);
			// Compare `[[Class]]` names.
			var className = toString.call(a);
			if (className != toString.call(b)) return false;
			switch (className) {
				// Strings, numbers, dates, and booleans are compared by value.
				case '[object String]':
					// Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
					// equivalent to `new String("5")`.
					return a == String(b);
				case '[object Number]':
					// `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
					// other numeric values.
					return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
				case '[object Date]':
				case '[object Boolean]':
					// Coerce dates and booleans to numeric primitive values. Dates are compared by their
					// millisecond representations. Note that invalid dates with millisecond representations
					// of `NaN` are not equivalent.
					return +a == +b;
				// RegExps are compared by their source patterns and flags.
				case '[object RegExp]':
					return a.source == b.source &&
							a.global == b.global &&
							a.multiline == b.multiline &&
							a.ignoreCase == b.ignoreCase;
			}
			if (typeof a != 'object' || typeof b != 'object') return false;
			// Assume equality for cyclic structures. The algorithm for detecting cyclic
			// structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
			var length = stack.length;
			while (length--) {
				// Linear search. Performance is inversely proportional to the number of
				// unique nested structures.
				if (stack[length] == a) return true;
			}
			// Add the first object to the stack of traversed objects.
			stack.push(a);
			var size = 0, result = true;
			// Recursively compare objects and arrays.
			if (className == '[object Array]') {
				// Compare array lengths to determine if a deep comparison is necessary.
				size = a.length;
				result = size == b.length;
				if (result) {
					// Deep compare the contents, ignoring non-numeric properties.
					while (size--) {
						// Ensure commutative equality for sparse arrays.
						if (!(result = size in a == size in b && eq(a[size], b[size], stack))) break;
					}
				}
			} else {
				// Objects with different constructors are not equivalent.
				if ('constructor' in a != 'constructor' in b || a.constructor != b.constructor) return false;
				// Deep compare objects.
				for (var key in a) {
					if (_.has(a, key)) {
						// Count the expected number of properties.
						size++;
						// Deep compare each member.
						if (!(result = _.has(b, key) && eq(a[key], b[key], stack))) break;
					}
				}
				// Ensure that both objects contain the same number of properties.
				if (result) {
					for (key in b) {
						if (_.has(b, key) && !(size--)) break;
					}
					result = !size;
				}
			}
			// Remove the first object from the stack of traversed objects.
			stack.pop();
			return result;
		}

		// Perform a deep comparison to check if two objects are equal.
		_.isEqual = function(a, b) {
			return eq(a, b, []);
		};

		// Is a given array, string, or object empty?
		// An "empty" object has no enumerable own-properties.
		_.isEmpty = function(obj) {
			if (obj == null) return true;
			if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
			for (var key in obj) if (_.has(obj, key)) return false;
			return true;
		};

		// Is a given value a DOM element?
		_.isElement = function(obj) {
			return !!(obj && obj.nodeType == 1);
		};

		// Is a given value an array?
		// Delegates to ECMA5's native Array.isArray
		_.isArray = nativeIsArray || function(obj) {
			return toString.call(obj) == '[object Array]';
		};

		// Is a given variable an object?
		_.isObject = function(obj) {
			return obj === Object(obj);
		};

		// Is a given variable an arguments object?
		_.isArguments = function(obj) {
			return toString.call(obj) == '[object Arguments]';
		};
		if (!_.isArguments(arguments)) {
			_.isArguments = function(obj) {
				return !!(obj && _.has(obj, 'callee'));
			};
		}

		// Is a given value a function?
		_.isFunction = function(obj) {
			return toString.call(obj) == '[object Function]';
		};

		// Is a given value a string?
		_.isString = function(obj) {
			return toString.call(obj) == '[object String]';
		};

		// Is a given value a number?
		_.isNumber = function(obj) {
			return toString.call(obj) == '[object Number]';
		};

		// Is a given object a finite number?
		_.isFinite = function(obj) {
			return _.isNumber(obj) && isFinite(obj);
		};

		// Is the given value `NaN`?
		_.isNaN = function(obj) {
			// `NaN` is the only value for which `===` is not reflexive.
			return obj !== obj;
		};

		// Is a given value a boolean?
		_.isBoolean = function(obj) {
			return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
		};

		// Is a given value a date?
		_.isDate = function(obj) {
			return toString.call(obj) == '[object Date]';
		};

		// Is the given value a regular expression?
		_.isRegExp = function(obj) {
			return toString.call(obj) == '[object RegExp]';
		};

		// Is a given value equal to null?
		_.isNull = function(obj) {
			return obj === null;
		};

		// Is a given variable undefined?
		_.isUndefined = function(obj) {
			return obj === void 0;
		};

		// Has own property?
		_.has = function(obj, key) {
			return hasOwnProperty.call(obj, key);
		};

		// Utility Functions
		// -----------------

		// Run Underscore.js in *noConflict* mode, returning the `_` variable to its
		// previous owner. Returns a reference to the Underscore object.
		_.noConflict = function() {
			root._ = previousUnderscore;
			return this;
		};

		// Keep the identity function around for default iterators.
		_.identity = function(value) {
			return value;
		};

		// Run a function **n** times.
		_.times = function (n, iterator, context) {
			for (var i = 0; i < n; i++) iterator.call(context, i);
		};

		// Escape a string for HTML interpolation.
		_.escape = function(string) {
			return (''+string).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#x27;').replace(/\//g,'&#x2F;');
		};

		// If the value of the named property is a function then invoke it;
		// otherwise, return it.
		_.result = function(object, property) {
			if (object == null) return null;
			var value = object[property];
			return _.isFunction(value) ? value.call(object) : value;
		};

		// Add your own custom functions to the Underscore object, ensuring that
		// they're correctly added to the OOP wrapper as well.
		_.mixin = function(obj) {
			each(_.functions(obj), function(name){
				addToWrapper(name, _[name] = obj[name]);
			});
		};

		// Generate a unique integer id (unique within the entire client session).
		// Useful for temporary DOM ids.
		var idCounter = 0;
		_.uniqueId = function(prefix) {
			var id = idCounter++;
			return prefix ? prefix + id : id;
		};

		// By default, Underscore uses ERB-style template delimiters, change the
		// following template settings to use alternative delimiters.
		_.templateSettings = {
			evaluate    : /<%([\s\S]+?)%>/g,
			interpolate : /<%=([\s\S]+?)%>/g,
			escape      : /<%-([\s\S]+?)%>/g
		};

		// When customizing `templateSettings`, if you don't want to define an
		// interpolation, evaluation or escaping regex, we need one that is
		// guaranteed not to match.
		var noMatch = /.^/;

		// Certain characters need to be escaped so that they can be put into a
		// string literal.
		var escapes = {
			'\\': '\\',
			"'": "'",
			'r': '\r',
			'n': '\n',
			't': '\t',
			'u2028': '\u2028',
			'u2029': '\u2029'
		};

		for (var p in escapes) escapes[escapes[p]] = p;
		var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;
		var unescaper = /\\(\\|'|r|n|t|u2028|u2029)/g;

		// Within an interpolation, evaluation, or escaping, remove HTML escaping
		// that had been previously added.
		var unescape = function(code) {
			return code.replace(unescaper, function(match, escape) {
				return escapes[escape];
			});
		};

		// JavaScript micro-templating, similar to John Resig's implementation.
		// Underscore templating handles arbitrary delimiters, preserves whitespace,
		// and correctly escapes quotes within interpolated code.
		_.template = function(text, data, settings) {
			settings = _.defaults(settings || {}, _.templateSettings);

			// Compile the template source, taking care to escape characters that
			// cannot be included in a string literal and then unescape them in code
			// blocks.
			var source = "__p+='" + text
					.replace(escaper, function(match) {
				return '\\' + escapes[match];
			})
					.replace(settings.escape || noMatch, function(match, code) {
						return "'+\n_.escape(" + unescape(code) + ")+\n'";
					})
					.replace(settings.interpolate || noMatch, function(match, code) {
						return "'+\n(" + unescape(code) + ")+\n'";
					})
					.replace(settings.evaluate || noMatch, function(match, code) {
						return "';\n" + unescape(code) + "\n;__p+='";
					}) + "';\n";

			// If a variable is not specified, place data values in local scope.
			if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

			source = "var __p='';" +
					"var print=function(){__p+=Array.prototype.join.call(arguments, '')};\n" +
					source + "return __p;\n";

			var render = new Function(settings.variable || 'obj', '_', source);
			if (data) return render(data, _);
			var template = function(data) {
				return render.call(this, data, _);
			};

			// Provide the compiled function source as a convenience for build time
			// precompilation.
			template.source = 'function(' + (settings.variable || 'obj') + '){\n' +
					source + '}';

			return template;
		};

		// Add a "chain" function, which will delegate to the wrapper.
		_.chain = function(obj) {
			return _(obj).chain();
		};

		// The OOP Wrapper
		// ---------------

		// If Underscore is called as a function, it returns a wrapped object that
		// can be used OO-style. This wrapper holds altered versions of all the
		// underscore functions. Wrapped objects may be chained.
		var wrapper = function(obj) { this._wrapped = obj; };

		// Expose `wrapper.prototype` as `_.prototype`
		_.prototype = wrapper.prototype;

		// Helper function to continue chaining intermediate results.
		var result = function(obj, chain) {
			return chain ? _(obj).chain() : obj;
		};

		// A method to easily add functions to the OOP wrapper.
		var addToWrapper = function(name, func) {
			wrapper.prototype[name] = function() {
				var args = slice.call(arguments);
				unshift.call(args, this._wrapped);
				return result(func.apply(_, args), this._chain);
			};
		};

		// Add all of the Underscore functions to the wrapper object.
		_.mixin(_);

		// Add all mutator Array functions to the wrapper.
		each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
			var method = ArrayProto[name];
			wrapper.prototype[name] = function() {
				var wrapped = this._wrapped;
				method.apply(wrapped, arguments);
				var length = wrapped.length;
				if ((name == 'shift' || name == 'splice') && length === 0) delete wrapped[0];
				return result(wrapped, this._chain);
			};
		});

		// Add all accessor Array functions to the wrapper.
		each(['concat', 'join', 'slice'], function(name) {
			var method = ArrayProto[name];
			wrapper.prototype[name] = function() {
				return result(method.apply(this._wrapped, arguments), this._chain);
			};
		});

		// Start chaining a wrapped Underscore object.
		wrapper.prototype.chain = function() {
			this._chain = true;
			return this;
		};

		// Extracts the result from a wrapped and chained object.
		wrapper.prototype.value = function() {
			return this._wrapped;
		};

		return _.noConflict()
	}
)

define(
	'spell/shared/util/platform/private/registerTimer',
	function() {
		'use strict'


		/*
		 * callback - the callback to call
		 * timeInMs - the number of milliseconds that the callback is delayed by
		 */
		return function( callback, timeInMs ) {
			setTimeout( callback, timeInMs )
		}
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
	function() {
		'use strict'


		return typeof( NATIVE ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/environment/isHtml5Ejecta',
	function() {
		'use strict'


		return typeof( ejecta ) !== 'undefined'
	}
)

define(
	'spell/shared/util/platform/private/advertisement',
	[
		'spell/shared/util/platform/private/environment/isHtml5Ejecta',
		'spell/shared/util/platform/private/environment/isHtml5TeaLeaf',
		'spell/shared/util/platform/private/registerTimer',
		'spell/functions'
	],
	function(
		isHtml5Ejecta,
		isHtml5TeaLeaf,
		registerTimer,
		_
	) {
		'use strict'


		var mutedState = false,
			isPaused   = false

		var processInterstitial = function( spell, event ) {
			if( event.isShown ) {
				if( isPaused ) return

				isPaused = true

				// delay pausing because the chartboost interstitial takes its time
				registerTimer(
					function() {
						spell.audioContext.pauseContext()
						spell.mainLoop.pause()
					},
					100
				)

			} else {
				if( !isPaused ) return

				isPaused = false

				spell.audioContext.resumeContext()
				spell.mainLoop.resume()
			}
		}

		return {
			init : function( spell, next ) {
				var processInterstitialPartial = _.bind( processInterstitial, null, spell )

				if( isHtml5Ejecta ) {
					document.addEventListener( 'interstitial', processInterstitialPartial )

				} else if( isHtml5TeaLeaf ) {
					NATIVE.events.registerHandler( 'interstitial', processInterstitialPartial )
				}

				next()
			},
			loadInterstitial : function() {
				if( isHtml5Ejecta ) {
					//ejecta.loadInterstitial()

				} else if( isHtml5TeaLeaf ) {
					NATIVE.plugins.sendEvent( 'AdMobPlugin', 'loadInterstitial', JSON.stringify( {} ) )
				}
			},
			showInterstitial : function() {
				if( isHtml5Ejecta ) {
					//ejecta.showInterstitial()

				} else if( isHtml5TeaLeaf ) {
					NATIVE.plugins.sendEvent( 'AdMobPlugin', 'showInterstitial', JSON.stringify( {} ) )
				}
			}
		}
	}
)

define( 'spell/client/isDebug', function() { return true } )
